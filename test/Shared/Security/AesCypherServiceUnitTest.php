<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use Civi\Lughauth\Shared\Security\AesCypherService;

class AesCypherServiceUnitTest extends TestCase
{
    private AesCypherService $aesService;

    protected function setUp(): void
    {
        // Inicia un nuevo servicio con una clave por defecto
        $this->aesService = new AesCypherService();
    }

    public function testEncryptForAll(): void
    {
        $value = 'plaintext';
        $encrypted = $this->aesService->encryptForAll($value);

        $this->assertNotEquals($value, $encrypted); // El valor cifrado no debe ser igual al original
        $this->assertIsString($encrypted); // El valor cifrado debe ser un string
    }

    public function testDecryptForAll(): void
    {
        $value = 'plaintext';
        $encrypted = $this->aesService->encryptForAll($value);

        $decrypted = $this->aesService->decryptForAll($encrypted);

        $this->assertEquals($value, $decrypted); // El valor descifrado debe ser igual al original
    }

    public function testEncryptWithCustomKey(): void
    {
        $customKey = 'custom-encryption-key';
        $aesServiceWithCustomKey = new AesCypherService($customKey);
        $value = 'plaintext';
        $encrypted = $aesServiceWithCustomKey->encryptForAll($value);

        $this->assertNotEquals($value, $encrypted); // El valor cifrado no debe ser igual al original
        $this->assertIsString($encrypted); // El valor cifrado debe ser un string
    }

    public function testDecryptWithCustomKey(): void
    {
        $customKey = 'custom-encryption-key';
        $aesServiceWithCustomKey = new AesCypherService($customKey);
        $value = 'plaintext';
        $encrypted = $aesServiceWithCustomKey->encryptForAll($value);

        $decrypted = $aesServiceWithCustomKey->decryptForAll($encrypted);

        $this->assertEquals($value, $decrypted); // El valor descifrado debe ser igual al original
    }

    public function testDecryptReturnsNullOnCorruptedCiphertext(): void
    {
        $value = 'plaintext';
        $encrypted = $this->aesService->encryptForAll($value);

        // Modificamos el ciphertext de alguna forma para corromperlo
        $corruptedEncrypted = substr($encrypted, 4, -4); // Eliminar un carácter para corromperlo

        $decrypted = $this->aesService->decryptForAll($corruptedEncrypted);

        $this->assertNull($decrypted); // Si el ciphertext está corrupto, el resultado debe ser null
    }

    public function testExceptionOnInvalidDecryptionKey(): void
    {
        $value = 'plaintext';
        $encrypted = $this->aesService->encryptForAll($value);

        // Usamos una clave diferente para el descifrado
        $aesServiceWithDifferentKey = new AesCypherService('wrong-key');
        $decrypted = $aesServiceWithDifferentKey->decryptForAll($encrypted);

        $this->assertNull($decrypted); // Si la clave es incorrecta, el resultado debe ser null
    }

    public function testEncryptThrowsExceptionOnFailure(): void
    {
        $this->expectException(\RuntimeException::class);

        // Simulamos un error en la función openssl_encrypt
        $mockedAesService = $this->getMockBuilder(AesCypherService::class)
            ->onlyMethods(['encrypt'])
            ->getMock();

        $mockedAesService->method('encrypt')->willThrowException(new \RuntimeException('Error en la encriptación'));

        $mockedAesService->encryptForAll('plaintext');
    }

    public function testDecryptThrowsExceptionOnFailure(): void
    {
        $this->expectException(\RuntimeException::class);

        // Simulamos un error en la función openssl_decrypt
        $mockedAesService = $this->getMockBuilder(AesCypherService::class)
            ->onlyMethods(['decrypt'])
            ->getMock();

        $mockedAesService->method('decrypt')->willThrowException(new \RuntimeException('Error al desencriptar'));

        $mockedAesService->decryptForAll('encryptedString');
    }
}
