<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use Civi\Lughauth\Shared\Security\Connection;
use Civi\Lughauth\Shared\AppConfig;

/**
 * Unit tests for Connection.
 */
final class ConnectionUnitTest extends TestCase
{
    protected function setUp(): void
    {
        $_SERVER = [
            'HTTP_ACCEPT_LANGUAGE' => 'en-US,en;q=0.9,es;q=0.8',
            'SERVER_NAME' => 'example.org',
            'REQUEST_URI' => '/callback',
            'REMOTE_ADDR' => '192.168.1.42'
        ];
    }

    /**
     * Ensures remoteHttp uses direct client IP when no proxy is configured.
     */
    public function testRemoteHttpWithoutProxy(): void
    {
        /*
         * Arrange: use the default server environment for a direct request.
         */
        $app = 'testApp';

        /*
         * Act: build a Connection from the HTTP environment.
         */
        $connection = Connection::remoteHttp($app);

        /*
         * Assert: verify the connection details match the environment.
         */
        $this->assertInstanceOf(Connection::class, $connection);
        $this->assertTrue($connection->remote);
        $this->assertSame('testApp', $connection->application);
        $this->assertSame('/callback', $connection->callback);
        $this->assertSame('192.168.1.42', $connection->source);
        $this->assertSame('example.org', $connection->target);
        $this->assertSame('en-US', $connection->locale);
    }

    /**
     * Ensures X-Forwarded-For is used when proxy support is enabled.
     */
    public function testRemoteHttpWithProxyXForwardedFor(): void
    {
        /*
         * Arrange: add X-Forwarded-For header and enable proxy support.
         */
        $_SERVER['HTTP_X_FORWARDED_FOR'] = '10.0.0.123, 10.0.0.124';
        $config = $this->createMock(AppConfig::class);
        $config->method('get')->willReturn('true');

        /*
         * Act: build a Connection from the proxied HTTP environment.
         */
        $connection = Connection::remoteHttp('proxiedApp', $config);

        /*
         * Assert: verify the client IP uses the first forwarded address.
         */
        $this->assertSame('10.0.0.123', $connection->source);
    }

    /**
     * Ensures X-Real-IP is used when X-Forwarded-For is missing.
     */
    public function testRemoteHttpWithProxyXRealIp(): void
    {
        /*
         * Arrange: remove X-Forwarded-For and set X-Real-IP.
         */
        unset($_SERVER['HTTP_X_FORWARDED_FOR']);
        $_SERVER['HTTP_X_REAL_IP'] = '10.0.0.200';

        $config = $this->createMock(AppConfig::class);
        $config->method('get')->willReturn('true');

        /*
         * Act: build a Connection from the proxied HTTP environment.
         */
        $connection = Connection::remoteHttp('realIpApp', $config);

        /*
         * Assert: verify the client IP uses X-Real-IP.
         */
        $this->assertSame('10.0.0.200', $connection->source);
    }

    /**
     * Ensures IPv6 loopback is normalized to IPv4.
     */
    public function testRemoteHttpWithIPv6Loopback(): void
    {
        /*
         * Arrange: set the IPv6 loopback address in the server data.
         */
        $_SERVER['REMOTE_ADDR'] = '::1';

        /*
         * Act: build a Connection from the HTTP environment.
         */
        $connection = Connection::remoteHttp('ipv6App');

        /*
         * Assert: verify the loopback address is normalized.
         */
        $this->assertSame('127.0.0.1', $connection->source);
    }

    /**
     * Ensures inRange returns true for matching CIDR blocks.
     */
    public function testInRangeTrue(): void
    {
        /*
         * Arrange: create a connection within the target CIDR range.
         */
        $connection = new Connection(true, new \DateTime(), 'app', '/', '192.168.1.15', 'target', 'en');

        /*
         * Act: check if the source IP is inside the CIDR block.
         */
        $inRange = $connection->inRange('192.168.1.0/24');

        /*
         * Assert: verify the IP is reported as within range.
         */
        $this->assertTrue($inRange);
    }

    /**
     * Ensures inRange returns false for non-matching CIDR blocks.
     */
    public function testInRangeFalse(): void
    {
        /*
         * Arrange: create a connection outside the target CIDR range.
         */
        $connection = new Connection(true, new \DateTime(), 'app', '/', '192.168.2.15', 'target', 'en');

        /*
         * Act: check if the source IP is inside the CIDR block.
         */
        $inRange = $connection->inRange('192.168.1.0/24');

        /*
         * Assert: verify the IP is reported as outside the range.
         */
        $this->assertFalse($inRange);
    }
}
