<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Context;
use Civi\Lughauth\Shared\Security\Identity;
use Civi\Lughauth\Shared\Security\Rbac\LughMapper;
use Psr\Http\Client\ClientInterface;
use Psr\Http\Message\RequestFactoryInterface;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\StreamFactoryInterface;
use Psr\Http\Message\StreamInterface;
use Psr\Log\LoggerInterface;
use Psr\SimpleCache\CacheInterface;

final class LughMapperUnitTest extends TestCase
{
    public function testRegisterResourceActionAndAttributeStoresData(): void
    {
        $mapper = $this->createMapper();

        $mapper->registerResourceAction('users', 'read', 'public');
        $mapper->registerResourceAttribute('users', 'email', 'hidden');

        $ref = new ReflectionClass($mapper);
        $prop = $ref->getProperty('registereds');
        $prop->setAccessible(true);
        $registereds = $prop->getValue($mapper);

        $this->assertArrayHasKey('users', $registereds);
        $this->assertSame('users', $registereds['users']['resource']['name']);
        $this->assertSame('read', $registereds['users']['scopes'][0]['name']);
        $this->assertSame('email', $registereds['users']['schemas'][0]['name']);
    }

    public function testRegisterResourceAttributeInitializesResource(): void
    {
        $mapper = $this->createMapper();

        $mapper->registerResourceAttribute('projects', 'status', 'visible');

        $ref = new ReflectionClass($mapper);
        $prop = $ref->getProperty('registereds');
        $prop->setAccessible(true);
        $registereds = $prop->getValue($mapper);

        $this->assertArrayHasKey('projects', $registereds);
        $this->assertSame('projects', $registereds['projects']['resource']['name']);
        $this->assertSame('status', $registereds['projects']['schemas'][0]['name']);
        $this->assertSame([], $registereds['projects']['scopes']);
    }

    public function testFlushSendsRegistrationsAndLogsErrors(): void
    {
        $config = $this->createConfigMock('http://auth', 'api-key');
        $context = $this->createMock(Context::class);
        $cache = $this->createMock(CacheInterface::class);
        $logger = $this->createMock(LoggerInterface::class);

        $requestFactory = $this->createMock(RequestFactoryInterface::class);
        $streamFactory = $this->createMock(StreamFactoryInterface::class);
        $client = $this->createMock(ClientInterface::class);

        $requestScope = $this->createRequestMock();
        $requestSchema = $this->createRequestMock();
        $streamScope = $this->createMock(StreamInterface::class);
        $streamSchema = $this->createMock(StreamInterface::class);
        $responseScope = $this->createErrorResponse('scope-error');
        $responseSchema = $this->createErrorResponse('schema-error');

        $requestFactory->expects($this->exactly(2))
            ->method('createRequest')
            ->willReturnOnConsecutiveCalls($requestScope, $requestSchema);

        $streamFactory->expects($this->exactly(2))
            ->method('createStream')
            ->willReturnOnConsecutiveCalls($streamScope, $streamSchema);

        $client->expects($this->exactly(2))
            ->method('sendRequest')
            ->willReturnOnConsecutiveCalls($responseScope, $responseSchema);

        $logger->expects($this->exactly(2))
            ->method('error')
            ->with($this->stringContains('Error making the scope register on http://auth:'));

        $mapper = new LughMapper(
            $config,
            $context,
            $cache,
            $logger,
            $requestFactory,
            $streamFactory,
            $client
        );
        $mapper->registerResourceAction('users', 'read', 'public');
        $mapper->registerResourceAttribute('users', 'email', 'hidden');

        $mapper->flush();
    }

    public function testHiddenUneditableAndAllowUsesCachedGrants(): void
    {
        $config = $this->createConfigMock('http://auth', 'api-key');
        $context = $this->createMock(Context::class);
        $cache = $this->createMock(CacheInterface::class);
        $logger = $this->createMock(LoggerInterface::class);
        $requestFactory = $this->createMock(RequestFactoryInterface::class);
        $streamFactory = $this->createMock(StreamFactoryInterface::class);
        $client = $this->createMock(ClientInterface::class);

        $grants = [
            'admin' => [
                'users' => [
                    'attributes' => [
                        'email' => ['view' => true, 'modify' => true],
                        'secret' => ['view' => false, 'modify' => false],
                        'name' => ['view' => true, 'modify' => false]
                    ],
                    'scope' => [
                        'read' => true,
                        'delete' => false
                    ]
                ]
            ]
        ];
        $jsonGrants = json_encode($grants);

        $cache->expects($this->exactly(4))
            ->method('has')
            ->with('lught.grants')
            ->willReturn(true);
        $cache->expects($this->exactly(4))
            ->method('get')
            ->with('lught.grants')
            ->willReturn($jsonGrants);
        $client->expects($this->never())->method('sendRequest');

        $mapper = new LughMapper(
            $config,
            $context,
            $cache,
            $logger,
            $requestFactory,
            $streamFactory,
            $client
        );

        $identity = new Identity(false, roles: ['admin']);

        $hidden = $mapper->hiddenFields($identity, 'users');
        $uneditable = $mapper->uneditableFields($identity, 'users');

        $this->assertSame(['secret'], array_values($hidden));
        $this->assertSame(['secret', 'name'], array_values($uneditable));
        $this->assertTrue($mapper->allow($identity, 'users', 'read'));
        $this->assertFalse($mapper->allow($identity, 'users', 'delete'));
    }

    public function testAllowFetchesGrantsAndCachesOnMiss(): void
    {
        $config = $this->createConfigMock('http://auth', 'api-key');
        $context = $this->createMock(Context::class);
        $cache = $this->createMock(CacheInterface::class);
        $logger = $this->createMock(LoggerInterface::class);
        $requestFactory = $this->createMock(RequestFactoryInterface::class);
        $streamFactory = $this->createMock(StreamFactoryInterface::class);
        $client = $this->createMock(ClientInterface::class);

        $request = $this->createRequestMock();
        $response = $this->createResponseWithBody(json_encode([
            'admin' => [
                'users' => [
                    'scope' => ['write' => true]
                ]
            ]
        ]));

        $cache->expects($this->once())
            ->method('has')
            ->with('lught.grants.tenant-1')
            ->willReturn(false);
        $cache->expects($this->once())
            ->method('set')
            ->with(
                'lught.grants.tenant-1',
                $this->isString(),
                $this->isInstanceOf(DateInterval::class)
            );

        $requestFactory->expects($this->once())
            ->method('createRequest')
            ->with('GET', 'http://auth/grant?tenant=tenant-1')
            ->willReturn($request);

        $client->expects($this->once())
            ->method('sendRequest')
            ->with($request)
            ->willReturn($response);

        $mapper = new LughMapper(
            $config,
            $context,
            $cache,
            $logger,
            $requestFactory,
            $streamFactory,
            $client
        );

        $identity = new Identity(false, roles: ['admin'], tenant: 'tenant-1');

        $this->assertTrue($mapper->allow($identity, 'users', 'write'));
    }

    private function createMapper(): LughMapper
    {
        $config = $this->createConfigMock('http://auth', 'api-key');
        $context = $this->createMock(Context::class);
        $cache = $this->createMock(CacheInterface::class);
        $logger = $this->createMock(LoggerInterface::class);
        $requestFactory = $this->createMock(RequestFactoryInterface::class);
        $streamFactory = $this->createMock(StreamFactoryInterface::class);
        $client = $this->createMock(ClientInterface::class);

        return new LughMapper(
            $config,
            $context,
            $cache,
            $logger,
            $requestFactory,
            $streamFactory,
            $client
        );
    }

    private function createConfigMock(string $authUrl, string $apiKey): AppConfig
    {
        $config = $this->createMock(AppConfig::class);
        $config->method('get')
            ->willReturnMap([
                ['security.rbac.lugh.location', '-', $authUrl],
                ['security.rbac.lugh.api.key', null, $apiKey]
            ]);
        return $config;
    }

    private function createRequestMock(): RequestInterface
    {
        $request = $this->createMock(RequestInterface::class);
        $request->method('withAddedHeader')->willReturnSelf();
        $request->method('withBody')->willReturnSelf();
        return $request;
    }

    private function createResponseWithBody(string $body): ResponseInterface
    {
        $stream = $this->createMock(StreamInterface::class);
        $stream->method('__toString')->willReturn($body);

        /** @var ResponseInterface&\PHPUnit\Framework\MockObject\MockObject $response */
        $response = $this->createMock(ResponseInterface::class);
        $response->method('getBody')->willReturn($stream);
        return $response;
    }

    private function createErrorResponse(string $body): ResponseInterface
    {
        /** @var ResponseInterface&\PHPUnit\Framework\MockObject\MockObject $response */
        $response = $this->createResponseWithBody($body);
        $response->method('getStatusCode')->willReturn(500);
        return $response;
    }
}
