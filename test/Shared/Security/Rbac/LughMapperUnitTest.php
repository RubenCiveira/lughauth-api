<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Context;
use Civi\Lughauth\Shared\Security\Identity;
use Civi\Lughauth\Shared\Security\Rbac\LughMapper;
use Psr\Http\Client\ClientInterface;
use Psr\Http\Message\RequestFactoryInterface;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\StreamFactoryInterface;
use Psr\Http\Message\StreamInterface;
use Psr\Log\LoggerInterface;
use Psr\SimpleCache\CacheInterface;

/**
 * Unit tests for LughMapper.
 */
final class LughMapperUnitTest extends TestCase
{
    /**
     * Ensures resource action and attribute registrations are stored.
     */
    public function testRegisterResourceActionAndAttributeStoresData(): void
    {
        /*
         * Arrange: create a mapper instance.
         */
        $mapper = $this->createMapper();

        /*
         * Act: register an action and attribute for a resource.
         */
        $mapper->registerResourceAction('users', 'read', 'public');
        $mapper->registerResourceAttribute('users', 'email', 'hidden');

        $ref = new ReflectionClass($mapper);
        $prop = $ref->getProperty('registereds');
        $prop->setAccessible(true);
        $registereds = $prop->getValue($mapper);

        /*
         * Assert: verify the resource registration includes scopes and schemas.
         */
        $this->assertArrayHasKey('users', $registereds);
        $this->assertSame('users', $registereds['users']['resource']['name']);
        $this->assertSame('read', $registereds['users']['scopes'][0]['name']);
        $this->assertSame('email', $registereds['users']['schemas'][0]['name']);
    }

    /**
     * Ensures registering an attribute initializes a resource entry.
     */
    public function testRegisterResourceAttributeInitializesResource(): void
    {
        /*
         * Arrange: create a mapper instance.
         */
        $mapper = $this->createMapper();

        /*
         * Act: register an attribute for a new resource.
         */
        $mapper->registerResourceAttribute('projects', 'status', 'visible');

        $ref = new ReflectionClass($mapper);
        $prop = $ref->getProperty('registereds');
        $prop->setAccessible(true);
        $registereds = $prop->getValue($mapper);

        /*
         * Assert: verify the resource entry and schema were created.
         */
        $this->assertArrayHasKey('projects', $registereds);
        $this->assertSame('projects', $registereds['projects']['resource']['name']);
        $this->assertSame('status', $registereds['projects']['schemas'][0]['name']);
        $this->assertSame([], $registereds['projects']['scopes']);
    }

    /**
     * Ensures flush sends registrations and logs errors on failure.
     */
    public function testFlushSendsRegistrationsAndLogsErrors(): void
    {
        /*
         * Arrange: configure mapper dependencies and error responses.
         */
        $config = $this->createConfigMock('http://auth', 'api-key');
        $context = $this->createMock(Context::class);
        $cache = $this->createMock(CacheInterface::class);
        $logger = $this->createMock(LoggerInterface::class);

        $requestFactory = $this->createMock(RequestFactoryInterface::class);
        $streamFactory = $this->createMock(StreamFactoryInterface::class);
        $client = $this->createMock(ClientInterface::class);

        $requestScope = $this->createRequestMock();
        $requestSchema = $this->createRequestMock();
        $streamScope = $this->createMock(StreamInterface::class);
        $streamSchema = $this->createMock(StreamInterface::class);
        $responseScope = $this->createErrorResponse('scope-error');
        $responseSchema = $this->createErrorResponse('schema-error');

        $requestFactory->expects($this->exactly(2))
            ->method('createRequest')
            ->willReturnOnConsecutiveCalls($requestScope, $requestSchema);

        $streamFactory->expects($this->exactly(2))
            ->method('createStream')
            ->willReturnOnConsecutiveCalls($streamScope, $streamSchema);

        $client->expects($this->exactly(2))
            ->method('sendRequest')
            ->willReturnOnConsecutiveCalls($responseScope, $responseSchema);

        $logger->expects($this->exactly(2))
            ->method('error')
            ->with($this->logicalOr(
                $this->stringContains('Error making scope register on http://auth:'),
                $this->stringContains('Error making schema register on http://auth:')
            ));

        $mapper = new LughMapper(
            $config,
            $context,
            $cache,
            $logger,
            $requestFactory,
            $streamFactory,
            $client
        );
        $mapper->registerResourceAction('users', 'read', 'public');
        $mapper->registerResourceAttribute('users', 'email', 'hidden');

        /*
         * Act: flush registrations to the remote service.
         */
        $mapper->flush();

        /*
         * Assert: verify errors are logged for non-204 responses.
         */
    }

    /**
     * Ensures cached grants are used for fields and allow checks.
     */
    public function testHiddenUneditableAndAllowUsesCachedGrants(): void
    {
        /*
         * Arrange: configure cached grants and mapper dependencies.
         */
        $config = $this->createConfigMock('http://auth', 'api-key');
        $context = $this->createMock(Context::class);
        $cache = $this->createMock(CacheInterface::class);
        $logger = $this->createMock(LoggerInterface::class);
        $requestFactory = $this->createMock(RequestFactoryInterface::class);
        $streamFactory = $this->createMock(StreamFactoryInterface::class);
        $client = $this->createMock(ClientInterface::class);

        $grants = [
            'admin' => [
                'users' => [
                    'attributes' => [
                        'email' => ['view' => true, 'modify' => true],
                        'secret' => ['view' => false, 'modify' => false],
                        'name' => ['view' => true, 'modify' => false]
                    ],
                    'scope' => [
                        'read' => true,
                        'delete' => false
                    ]
                ]
            ]
        ];
        $jsonGrants = json_encode($grants);

        $cache->expects($this->exactly(4))
            ->method('has')
            ->with('lught.grants')
            ->willReturn(true);
        $cache->expects($this->exactly(4))
            ->method('get')
            ->with('lught.grants')
            ->willReturn($jsonGrants);
        $client->expects($this->never())->method('sendRequest');

        $mapper = new LughMapper(
            $config,
            $context,
            $cache,
            $logger,
            $requestFactory,
            $streamFactory,
            $client
        );

        $identity = new Identity(false, roles: ['admin']);

        /*
         * Act: request hidden fields, uneditable fields, and allow checks.
         */
        $hidden = $mapper->hiddenFields($identity, 'users');
        $uneditable = $mapper->uneditableFields($identity, 'users');
        $canRead = $mapper->allow($identity, 'users', 'read');
        $canDelete = $mapper->allow($identity, 'users', 'delete');

        /*
         * Assert: verify cached grants drive the results.
         */
        $this->assertSame(['secret'], array_values($hidden));
        $this->assertSame(['secret', 'name'], array_values($uneditable));
        $this->assertTrue($canRead);
        $this->assertFalse($canDelete);
    }

    /**
     * Ensures grant cache misses trigger remote fetch and caching.
     */
    public function testAllowFetchesGrantsAndCachesOnMiss(): void
    {
        /*
         * Arrange: configure a cache miss and remote response.
         */
        $config = $this->createConfigMock('http://auth', 'api-key');
        $context = $this->createMock(Context::class);
        $cache = $this->createMock(CacheInterface::class);
        $logger = $this->createMock(LoggerInterface::class);
        $requestFactory = $this->createMock(RequestFactoryInterface::class);
        $streamFactory = $this->createMock(StreamFactoryInterface::class);
        $client = $this->createMock(ClientInterface::class);

        $request = $this->createRequestMock();
        $response = $this->createResponseWithBody(json_encode([
            'admin' => [
                'users' => [
                    'scope' => ['write' => true]
                ]
            ]
        ]));

        $cache->expects($this->once())
            ->method('has')
            ->with('lught.grants.tenant-1')
            ->willReturn(false);
        $cache->expects($this->once())
            ->method('set')
            ->with(
                'lught.grants.tenant-1',
                $this->isString(),
                $this->isInstanceOf(DateInterval::class)
            );

        $requestFactory->expects($this->once())
            ->method('createRequest')
            ->with('GET', 'http://auth/grant?tenant=tenant-1')
            ->willReturn($request);

        $client->expects($this->once())
            ->method('sendRequest')
            ->with($request)
            ->willReturn($response);

        $mapper = new LughMapper(
            $config,
            $context,
            $cache,
            $logger,
            $requestFactory,
            $streamFactory,
            $client
        );

        $identity = new Identity(false, roles: ['admin'], tenant: 'tenant-1');

        /*
         * Act: evaluate permissions to trigger the cache miss path.
         */
        $allowed = $mapper->allow($identity, 'users', 'write');

        /*
         * Assert: verify the permission is granted based on fetched grants.
         */
        $this->assertTrue($allowed);
    }

    private function createMapper(): LughMapper
    {
        $config = $this->createConfigMock('http://auth', 'api-key');
        $context = $this->createMock(Context::class);
        $cache = $this->createMock(CacheInterface::class);
        $logger = $this->createMock(LoggerInterface::class);
        $requestFactory = $this->createMock(RequestFactoryInterface::class);
        $streamFactory = $this->createMock(StreamFactoryInterface::class);
        $client = $this->createMock(ClientInterface::class);

        return new LughMapper(
            $config,
            $context,
            $cache,
            $logger,
            $requestFactory,
            $streamFactory,
            $client
        );
    }

    private function createConfigMock(string $authUrl, string $apiKey): AppConfig
    {
        $config = $this->createMock(AppConfig::class);
        $config->method('get')
            ->willReturnCallback(function (string $name, mixed $def = null) use ($authUrl, $apiKey) {
                return match($name) {
                    'security.rbac.lugh.location' => $authUrl,
                    'security.rbac.lugh.api.key' => $apiKey,
                    default => $def
                };
            });
        return $config;
    }

    private function createRequestMock(): RequestInterface
    {
        $request = $this->createMock(RequestInterface::class);
        $request->method('withAddedHeader')->willReturnSelf();
        $request->method('withBody')->willReturnSelf();
        return $request;
    }

    private function createResponseWithBody(string $body): ResponseInterface
    {
        $stream = $this->createMock(StreamInterface::class);
        $stream->method('__toString')->willReturn($body);

        /** @var ResponseInterface&\PHPUnit\Framework\MockObject\MockObject $response */
        $response = $this->createMock(ResponseInterface::class);
        $response->method('getBody')->willReturn($stream);
        return $response;
    }

    private function createErrorResponse(string $body): ResponseInterface
    {
        /** @var ResponseInterface&\PHPUnit\Framework\MockObject\MockObject $response */
        $response = $this->createResponseWithBody($body);
        $response->method('getStatusCode')->willReturn(500);
        return $response;
    }
}
