<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Security\Identity;
use Civi\Lughauth\Shared\Security\Rbac\Handler;
use Civi\Lughauth\Shared\Security\Rbac\LughMapper;

/**
 * Unit tests for Handler.
 */
final class HandlerUnitTest extends TestCase
{
    /**
     * Ensures the handler is disabled when no RBAC URL is configured.
     */
    public function testModeDisabledByDefault(): void
    {
        /*
         * Arrange: configure RBAC to be disabled and create a handler.
         */
        $config = $this->createMock(AppConfig::class);
        $config->expects($this->once())
            ->method('get')
            ->with('security.rbac.lugh.location', '-')
            ->willReturn('-');

        $mapper = $this->createMock(LughMapper::class);
        $mapper->expects($this->never())->method('flush');
        $mapper->expects($this->never())->method('registerResourceAction');
        $mapper->expects($this->never())->method('registerResourceAttribute');
        $mapper->expects($this->never())->method('hiddenFields');
        $mapper->expects($this->never())->method('uneditableFields');
        $mapper->expects($this->never())->method('allow');

        $handler = new Handler($config, $mapper);
        $identity = new Identity(false);

        /*
         * Act: invoke handler methods while disabled.
         */
        $handler->registerResourceAction('users', 'read', 'public');
        $handler->registerResourceAttribute('users', 'email', 'hidden');
        $handler->flush();

        $hidden = $handler->hiddenFields($identity, 'users');
        $uneditable = $handler->uneditableFields($identity, 'users');
        $allowed = $handler->allow($identity, 'users', 'read');

        /*
         * Assert: verify defaults are returned when disabled.
         */
        $this->assertSame([], $hidden);
        $this->assertSame([], $uneditable);
        $this->assertTrue($allowed);
    }

    /**
     * Ensures the handler delegates to the mapper when enabled.
     */
    public function testModeEnabledDelegatesToMapper(): void
    {
        /*
         * Arrange: configure RBAC to be enabled and mock mapper behavior.
         */
        $config = $this->createMock(AppConfig::class);
        $config->expects($this->once())
            ->method('get')
            ->with('security.rbac.lugh.location', '-')
            ->willReturn('http://lugh');

        $mapper = $this->createMock(LughMapper::class);
        $mapper->expects($this->once())
            ->method('registerResourceAction')
            ->with('users', 'read', 'public');
        $mapper->expects($this->once())
            ->method('registerResourceAttribute')
            ->with('users', 'email', 'hidden');
        $mapper->expects($this->once())->method('flush');
        $mapper->expects($this->once())
            ->method('hiddenFields')
            ->willReturn(['secret']);
        $mapper->expects($this->once())
            ->method('uneditableFields')
            ->willReturn(['createdAt']);
        $mapper->expects($this->once())
            ->method('allow')
            ->willReturn(false);

        $handler = new Handler($config, $mapper);
        $identity = new Identity(false);

        /*
         * Act: invoke handler methods while enabled.
         */
        $handler->registerResourceAction('users', 'read', 'public');
        $handler->registerResourceAttribute('users', 'email', 'hidden');
        $handler->flush();

        $hidden = $handler->hiddenFields($identity, 'users');
        $uneditable = $handler->uneditableFields($identity, 'users');
        $allowed = $handler->allow($identity, 'users', 'read');

        /*
         * Assert: verify results come from the mapper.
         */
        $this->assertSame(['secret'], $hidden);
        $this->assertSame(['createdAt'], $uneditable);
        $this->assertFalse($allowed);
    }
}
