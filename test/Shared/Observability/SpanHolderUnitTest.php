<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use OpenTelemetry\API\Trace\SpanInterface;
use OpenTelemetry\Context\ScopeInterface;
use Civi\Lughauth\Shared\Observability\SpanHolder;

/**
 * Unit tests for SpanHolder.
 */
final class SpanHolderUnitTest extends TestCase
{
    /**
     * Ensures end is safe when no span exists.
     */
    public function testEndDoesNothingWhenNoSpan(): void
    {
        /*
         * Arrange: create a holder without span or scope.
         */
        $holder = new SpanHolder(null, null);

        /*
         * Act: end the span holder.
         */
        $holder->end();

        /*
         * Assert: verify the holder reports no recording span.
         */
        $this->assertFalse($holder->isRecording());
    }

    /**
     * Ensures end closes the span and detaches the scope.
     */
    public function testEndClosesSpanAndScope(): void
    {
        /*
         * Arrange: create a holder with span and scope mocks.
         */
        $span = $this->createMock(SpanInterface::class);
        $scope = $this->createMock(ScopeInterface::class);
        $span->expects($this->once())->method('end');
        $scope->expects($this->once())->method('detach');

        /*
         * Act: end the span holder.
         */
        $holder = new SpanHolder($span, $scope);
        $holder->end();

        /*
         * Assert: confirm the span and scope were closed.
         */
    }

    /**
     * Ensures isRecording reflects the span state.
     */
    public function testIsRecordingReturnsSpanState(): void
    {
        /*
         * Arrange: create a span that reports recording state.
         */
        $span = $this->createMock(SpanInterface::class);
        $scope = $this->createMock(ScopeInterface::class);
        $span->expects($this->once())->method('isRecording')->willReturn(true);

        /*
         * Act: query the recording state through the holder.
         */
        $holder = new SpanHolder($span, $scope);

        /*
         * Assert: verify the holder reports the span is recording.
         */
        $this->assertTrue($holder->isRecording());
    }

    /**
     * Ensures span mutators return new holders.
     */
    public function testSpanMutatorsReturnNewHolder(): void
    {
        /*
         * Arrange: create a span mock that returns itself for mutations.
         */
        $span = $this->createMock(SpanInterface::class);
        $scope = $this->createMock(ScopeInterface::class);

        $span->expects($this->once())
            ->method('setAttribute')
            ->with('key', 'value')
            ->willReturn($span);
        $span->expects($this->once())
            ->method('setAttributes')
            ->with(['one' => 1])
            ->willReturn($span);
        $span->expects($this->once())
            ->method('addEvent')
            ->with('event', ['a' => 1], 123)
            ->willReturn($span);
        $span->expects($this->once())
            ->method('recordException')
            ->with($this->isInstanceOf(RuntimeException::class), ['b' => 2])
            ->willReturn($span);
        $span->expects($this->once())
            ->method('updateName')
            ->with('new')
            ->willReturn($span);
        $span->expects($this->once())
            ->method('setStatus')
            ->with('OK', 'done')
            ->willReturn($span);

        /*
         * Act: mutate the span through the holder.
         */
        $holder = new SpanHolder($span, $scope);

        /*
         * Assert: verify each mutation returns a SpanHolder.
         */
        $this->assertInstanceOf(SpanHolder::class, $holder->setAttribute('key', 'value'));
        $this->assertInstanceOf(SpanHolder::class, $holder->setAttributes(['one' => 1]));
        $this->assertInstanceOf(SpanHolder::class, $holder->addEvent('event', ['a' => 1], 123));
        $this->assertInstanceOf(SpanHolder::class, $holder->recordException(new RuntimeException('boom'), ['b' => 2]));
        $this->assertInstanceOf(SpanHolder::class, $holder->updateName('new'));
        $this->assertInstanceOf(SpanHolder::class, $holder->setStatus('OK', 'done'));
    }

    /**
     * Ensures mutators return the same holder when no span exists.
     */
    public function testSpanMutatorsOnNullSpanReturnSame(): void
    {
        /*
         * Arrange: create a holder without a span.
         */
        $holder = new SpanHolder(null, null);

        /*
         * Act: call mutator methods on the holder.
         */
        $attribute = $holder->setAttribute('k', 'v');
        $attributes = $holder->setAttributes(['k' => 'v']);
        $event = $holder->addEvent('event');
        $exception = $holder->recordException(new RuntimeException('boom'));
        $updated = $holder->updateName('new');
        $status = $holder->setStatus('OK');

        /*
         * Assert: verify the same holder instance is returned.
         */
        $this->assertSame($holder, $attribute);
        $this->assertSame($holder, $attributes);
        $this->assertSame($holder, $event);
        $this->assertSame($holder, $exception);
        $this->assertSame($holder, $updated);
        $this->assertSame($holder, $status);
    }
}
