<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Observability {
    if (!function_exists(__NAMESPACE__ . '\\error_log')) {
        function error_log(string $message): void
        {
        }
    }
}

namespace {
    use PHPUnit\Framework\TestCase;
    use Psr\Container\ContainerInterface;
    use Prometheus\CollectorRegistry;
    use Prometheus\Counter;
    use Prometheus\Histogram;
    use Prometheus\Gauge;
    use Civi\Lughauth\Shared\Observability\MetricAwareTrait;

    /**
     * Unit tests for MetricAwareTrait.
     */
    final class MetricAwareTraitUnitTest extends TestCase
    {
        /**
         * Ensures missing registry falls back without errors.
         */
        public function testSetMetricRegistryFromContainerMissing(): void
        {
            /*
             * Arrange: build a trait consumer and a container with no registry.
             */
            $service = new class () {
                use MetricAwareTrait;
            };
            $container = $this->createMock(ContainerInterface::class);
            $container->expects($this->once())
                ->method('has')
                ->with(CollectorRegistry::class)
                ->willReturn(false);
            $container->expects($this->never())->method('get');

            /*
             * Act: resolve the registry and invoke metric operations.
             */
            $service->setMetricRegistryFromContainer($container);
            $service->incrementCounter('hits');
            $service->observeHistogram('latency', 1.2);
            $service->setGauge('memory', 128);

            /*
             * Assert: confirm the fallback path completed.
             */
            $this->assertTrue(true);
        }

        /**
         * Ensures metric operations use the provided registry.
         */
        public function testMetricOperationsUseRegistry(): void
        {
            /*
             * Arrange: build a trait consumer with a mocked registry.
             */
            $service = new class () {
                use MetricAwareTrait;
            };

            $counter = $this->createMock(Counter::class);
            $counter->expects($this->once())
                ->method('incBy')
                ->with(2.5, ['api']);

            $histogram = $this->createMock(Histogram::class);
            $histogram->expects($this->once())
                ->method('observe')
                ->with(3.4, ['api']);

            $gauge = $this->createMock(Gauge::class);
            $gauge->expects($this->once())
                ->method('set')
                ->with(7.0, ['api']);

            $registry = $this->createMock(CollectorRegistry::class);
            $registry->expects($this->once())
                ->method('getOrRegisterCounter')
                ->with('app', 'hits', 'Auto-generated counter', ['route'])
                ->willReturn($counter);
            $registry->expects($this->once())
                ->method('getOrRegisterHistogram')
                ->with('app', 'latency', 'Auto-generated histogram', ['route'])
                ->willReturn($histogram);
            $registry->expects($this->once())
                ->method('getOrRegisterGauge')
                ->with('app', 'memory', 'Auto-generated gauge', ['route'])
                ->willReturn($gauge);

            /*
             * Act: set the registry and record metrics.
             */
            $service->setMetricRegistry($registry);
            $service->incrementCounter('hits', ['route' => 'api'], 2.5);
            $service->observeHistogram('latency', 3.4, ['route' => 'api']);
            $service->setGauge('memory', 7.0, ['route' => 'api']);

            /*
             * Assert: verify the registry methods were invoked.
             */
        }

        /**
         * Ensures registry resolution from container uses the registry.
         */
        public function testSetMetricRegistryFromContainerUsesRegistry(): void
        {
            /*
             * Arrange: create a container that returns a registry.
             */
            $service = new class () {
                use MetricAwareTrait;
            };

            $registry = $this->createMock(CollectorRegistry::class);
            $counter = $this->createMock(Counter::class);
            $registry->expects($this->once())
                ->method('getOrRegisterCounter')
                ->with('app', 'hits', 'Auto-generated counter', [])
                ->willReturn($counter);
            $counter->expects($this->once())
                ->method('incBy')
                ->with(1.0, []);

            $container = $this->createMock(ContainerInterface::class);
            $container->expects($this->once())
                ->method('has')
                ->with(CollectorRegistry::class)
                ->willReturn(true);
            $container->expects($this->once())
                ->method('get')
                ->with(CollectorRegistry::class)
                ->willReturn($registry);

            /*
             * Act: resolve the registry and record a counter.
             */
            $service->setMetricRegistryFromContainer($container);
            $service->incrementCounter('hits');

            /*
             * Assert: confirm the counter was recorded with defaults.
             */
        }
    }
}
