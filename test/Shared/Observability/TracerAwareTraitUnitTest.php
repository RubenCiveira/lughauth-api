<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Observability {
    if (!function_exists(__NAMESPACE__ . '\\error_log')) {
        function error_log(string $message): void
        {
        }
    }
}

namespace {
    use PHPUnit\Framework\TestCase;
    use Psr\Container\ContainerInterface;
    use OpenTelemetry\API\Trace\SpanInterface;
    use OpenTelemetry\API\Trace\SpanBuilderInterface;
    use OpenTelemetry\API\Trace\TracerInterface;
    use OpenTelemetry\Context\ScopeInterface;
    use Civi\Lughauth\Shared\Observability\SpanHolder;
    use Civi\Lughauth\Shared\Observability\TracerAwareTrait;

    final class TracerAwareTraitUnitTest extends TestCase
    {
        public function testSetTracerFromContainerMissing(): void
        {
            $service = new class () {
                use TracerAwareTrait;
            };
            $container = $this->createMock(ContainerInterface::class);
            $container->expects($this->once())
                ->method('has')
                ->with(TracerInterface::class)
                ->willReturn(false);
            $container->expects($this->never())->method('get');

            $service->setTracerFromContainer($container);

            $holder = $service->startSpan('fallback');
            $this->assertInstanceOf(SpanHolder::class, $holder);
            $this->assertFalse($holder->isRecording());
        }

        public function testStartSpanUsesTracer(): void
        {
            $service = new class () {
                use TracerAwareTrait;
            };

            $span = $this->createMock(SpanInterface::class);
            $scope = $this->createMock(ScopeInterface::class);
            $span->expects($this->once())->method('activate')->willReturn($scope);

            $builder = $this->createMock(SpanBuilderInterface::class);
            $builder->expects($this->exactly(2))
                ->method('setAttribute')
                ->willReturnSelf();
            $builder->expects($this->once())
                ->method('startSpan')
                ->willReturn($span);

            $tracer = $this->createMock(TracerInterface::class);
            $tracer->expects($this->once())
                ->method('spanBuilder')
                ->with('operation')
                ->willReturn($builder);

            $service->setTracer($tracer);

            $holder = $service->startSpan('operation', ['user' => 'u1', 'count' => 2]);
            $this->assertInstanceOf(SpanHolder::class, $holder);
        }

        public function testSetTracerFromContainerUsesTracer(): void
        {
            $service = new class () {
                use TracerAwareTrait;
            };
            $tracer = $this->createMock(TracerInterface::class);
            $container = $this->createMock(ContainerInterface::class);
            $container->expects($this->once())
                ->method('has')
                ->with(TracerInterface::class)
                ->willReturn(true);
            $container->expects($this->once())
                ->method('get')
                ->with(TracerInterface::class)
                ->willReturn($tracer);

            $service->setTracerFromContainer($container);

            $span = $this->createMock(SpanInterface::class);
            $span->expects($this->once())
                ->method('activate')
                ->willReturn($this->createMock(ScopeInterface::class));

            $builder = $this->createMock(SpanBuilderInterface::class);
            $builder->expects($this->once())
                ->method('startSpan')
                ->willReturn($span);
            $builder->expects($this->never())->method('setAttribute');

            $tracer->expects($this->once())
                ->method('spanBuilder')
                ->with('container')
                ->willReturn($builder);

            $service->startSpan('container');
        }
    }
}
