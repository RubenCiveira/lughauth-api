<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Observability {
    if (!function_exists(__NAMESPACE__ . '\\error_log')) {
        function error_log(string $message): void
        {
        }
    }
}

namespace {
    use PHPUnit\Framework\TestCase;
    use Psr\Container\ContainerInterface;
    use OpenTelemetry\API\Trace\SpanInterface;
    use OpenTelemetry\API\Trace\SpanBuilderInterface;
    use OpenTelemetry\API\Trace\TracerInterface;
    use OpenTelemetry\Context\ScopeInterface;
    use Civi\Lughauth\Shared\Observability\SpanHolder;
    use Civi\Lughauth\Shared\Observability\TracerAwareTrait;

    /**
     * Unit tests for TracerAwareTrait.
     */
    final class TracerAwareTraitUnitTest extends TestCase
    {
        /**
         * Ensures missing tracer uses fallback span holder.
         */
        public function testSetTracerFromContainerMissing(): void
        {
            /*
             * Arrange: build a trait consumer and a container with no tracer.
             */
            $service = new class () {
                use TracerAwareTrait;
            };
            $container = $this->createMock(ContainerInterface::class);
            $container->expects($this->once())
                ->method('has')
                ->with(TracerInterface::class)
                ->willReturn(false);
            $container->expects($this->never())->method('get');

            /*
             * Act: resolve the tracer and start a span.
             */
            $service->setTracerFromContainer($container);
            $holder = $service->startSpan('fallback');

            /*
             * Assert: verify the span holder is returned and not recording.
             */
            $this->assertInstanceOf(SpanHolder::class, $holder);
            $this->assertFalse($holder->isRecording());
        }

        /**
         * Ensures startSpan delegates to the configured tracer.
         */
        public function testStartSpanUsesTracer(): void
        {
            /*
             * Arrange: build a trait consumer and a tracer with a span builder.
             */
            $service = new class () {
                use TracerAwareTrait;
            };

            $span = $this->createMock(SpanInterface::class);
            $scope = $this->createMock(ScopeInterface::class);
            $span->expects($this->once())->method('activate')->willReturn($scope);

            $builder = $this->createMock(SpanBuilderInterface::class);
            $builder->expects($this->exactly(2))
                ->method('setAttribute')
                ->willReturnSelf();
            $builder->expects($this->once())
                ->method('startSpan')
                ->willReturn($span);

            $tracer = $this->createMock(TracerInterface::class);
            $tracer->expects($this->once())
                ->method('spanBuilder')
                ->with('operation')
                ->willReturn($builder);

            /*
             * Act: set the tracer and start a span with attributes.
             */
            $service->setTracer($tracer);
            $holder = $service->startSpan('operation', ['user' => 'u1', 'count' => 2]);

            /*
             * Assert: verify a span holder is returned.
             */
            $this->assertInstanceOf(SpanHolder::class, $holder);
        }

        /**
         * Ensures the tracer is resolved from the container.
         */
        public function testSetTracerFromContainerUsesTracer(): void
        {
            /*
             * Arrange: build a container that returns a tracer.
             */
            $service = new class () {
                use TracerAwareTrait;
            };
            $tracer = $this->createMock(TracerInterface::class);
            $container = $this->createMock(ContainerInterface::class);
            $container->expects($this->once())
                ->method('has')
                ->with(TracerInterface::class)
                ->willReturn(true);
            $container->expects($this->once())
                ->method('get')
                ->with(TracerInterface::class)
                ->willReturn($tracer);

            /*
             * Act: resolve the tracer and start a span.
             */
            $service->setTracerFromContainer($container);

            $span = $this->createMock(SpanInterface::class);
            $span->expects($this->once())
                ->method('activate')
                ->willReturn($this->createMock(ScopeInterface::class));

            $builder = $this->createMock(SpanBuilderInterface::class);
            $builder->expects($this->once())
                ->method('startSpan')
                ->willReturn($span);
            $builder->expects($this->never())->method('setAttribute');

            $tracer->expects($this->once())
                ->method('spanBuilder')
                ->with('container')
                ->willReturn($builder);

            $service->startSpan('container');

            /*
             * Assert: confirm the span builder was invoked via the tracer.
             */
        }
    }
}
