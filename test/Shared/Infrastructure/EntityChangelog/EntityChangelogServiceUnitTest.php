<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use Civi\Lughauth\Shared\Infrastructure\EntityChangelog\EntityChangelogService;
use Civi\Lughauth\Shared\Infrastructure\EntityChangelog\EntityChangelogEntry;

final class EntityChangelogServiceUnitTest extends TestCase
{
    private ?PDO $pdo = null;

    public function testRecordChangeInsertsWhenMissing(): void
    {
        $service = $this->createService();
        $service->recordChange('User', '1', ['name' => 'A'], []);

        $row = $this->fetchChangelogRow('User', '1');
        $this->assertSame(0, (int) $row['deleted']);
        $this->assertSame(['name' => 'A'], json_decode($row['payload'], true));
    }

    public function testRecordDeletionInsertsWhenMissing(): void
    {
        $service = $this->createService();
        $service->recordDeletion('User', '2', []);

        $row = $this->fetchChangelogRow('User', '2');
        $this->assertSame(1, (int) $row['deleted']);
        $this->assertSame([], json_decode($row['payload'], true));
    }

    public function testResyncEntityLogUpdatesChangedPayload(): void
    {
        $service = $this->createService();

        $this->insertChangelog('User', 'id-3', false, '2024-01-01 00:00:00', ['name' => 'Old']);
        $this->insertChangelog('User', 'id-4', false, '2024-01-01 00:00:00', []);

        $service->resyncEntityLog('User', ['id-3' => ['name' => 'New'], 'id-4' => ['name' => 'Same']]);

        $row = $this->fetchChangelogRow('User', 'id-3');
        $this->assertSame(['name' => 'New'], json_decode($row['payload'], true));

        $rowNew = $this->fetchChangelogRow('User', 'id-4');
        $this->assertSame(['name' => 'Same'], json_decode($rowNew['payload'], true));
    }

    public function testGetPendingChangesAndAck(): void
    {
        $service = $this->createService();

        $this->insertChangelog('User', '1', false, '2024-01-01 00:00:01', ['name' => 'A']);
        $this->insertChangelog('User', '2', false, '2024-01-01 00:00:02', ['name' => 'B']);

        $changes = $service->getPendingChanges('User', 'client', 10);

        $this->assertCount(2, $changes);
        $this->assertInstanceOf(EntityChangelogEntry::class, $changes[0]);

        $service->ackChanges('User', 'client', new DateTimeImmutable('2024-01-01 00:00:02'), '2');

        $cursor = $this->fetchCursor('client', 'User');
        $this->assertSame('2024-01-01 00:00:02', $cursor['last_changed_at']);
    }

    public function testPrivateHelpersForDrivers(): void
    {
        $service = $this->createServiceWithDriver('mysql');
        $params = [];
        $expr = $this->invokePrivateMethod($service, 'jsonTextExpr', ['field', 'param', &$params]);
        $this->assertSame("JSON_UNQUOTE(JSON_EXTRACT(payload, :path_param))", $expr);
        $this->assertSame('$.field', $params['path_param']);

        $service = $this->createServiceWithDriver('pgsql');
        $params = [];
        $expr = $this->invokePrivateMethod($service, 'jsonTextExpr', ['field', 'param', &$params]);
        $this->assertSame('(payload::json->>:key_param)', $expr);
        $this->assertSame('field', $params['key_param']);

        $service = $this->createServiceWithDriver('sqlite');
        $params = [];
        $expr = $this->invokePrivateMethod($service, 'jsonTextExpr', ['field', 'param', &$params]);
        $this->assertSame('json_extract(payload, :path_param)', $expr);
        $this->assertSame('$.field', $params['path_param']);

        $service = $this->createServiceWithDriver('unknown');
        $params = [];
        $expr = $this->invokePrivateMethod($service, 'jsonTextExpr', ['field', 'param', &$params]);
        $this->assertNull($expr);

        $pattern = $this->invokePrivateMethod($service, 'buildJsonLike', ['field', 'va%l_']);
        $this->assertSame('\%"field":"va\%l\_"\%', $pattern);
    }

    private function createService(): EntityChangelogService
    {
        $this->pdo = $this->createSqlite();
        $this->createTables($this->pdo);
        return new EntityChangelogService($this->pdo);
    }

    private function createServiceWithDriver(string $driver): EntityChangelogService
    {
        $this->pdo = new class ($driver) extends PDO {
            public function __construct(private readonly string $driver)
            {
                parent::__construct('sqlite::memory:');
                $this->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
            }

            public function getAttribute($attribute): mixed
            {
                if ($attribute === PDO::ATTR_DRIVER_NAME) {
                    return $this->driver;
                }
                return parent::getAttribute($attribute);
            }
        };
        $this->createTables($this->pdo);
        return new EntityChangelogService($this->pdo);
    }

    private function createSqlite(): PDO
    {
        $pdo = new PDO('sqlite::memory:');
        $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
        return $pdo;
    }

    private function createTables(PDO $pdo): void
    {
        $pdo->exec('CREATE TABLE _entity_changelog (
            entity_type TEXT,
            entity_id TEXT,
            deleted BOOLEAN,
            changed_at TEXT,
            payload TEXT
        )');
        $pdo->exec('CREATE TABLE _entity_changelog_cursor (
            client_id TEXT,
            entity_type TEXT,
            last_changed_at TEXT,
            last_entity_id TEXT
        )');
    }

    private function insertChangelog(string $type, string $id, bool $deleted, string $changedAt, array $payload): void
    {
        $stmt = $this->pdo->prepare('INSERT INTO _entity_changelog (entity_type, entity_id, deleted, changed_at, payload)
            VALUES (:entity_type, :entity_id, :deleted, :changed_at, :payload)');
        $stmt->execute([
            'entity_type' => $type,
            'entity_id' => $id,
            'deleted' => $deleted ? 1 : 0,
            'changed_at' => $changedAt,
            'payload' => json_encode($payload, JSON_UNESCAPED_UNICODE),
        ]);
    }

    private function fetchChangelogRow(string $type, string $id): array
    {
        $stmt = $this->pdo->prepare('SELECT * FROM _entity_changelog WHERE entity_type = :entity_type AND entity_id = :entity_id');
        $stmt->execute(['entity_type' => $type, 'entity_id' => $id]);
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }

    private function fetchCursor(string $clientId, string $entityType): array
    {
        $stmt = $this->pdo->prepare('SELECT * FROM _entity_changelog_cursor WHERE client_id = :client_id AND entity_type = :entity_type');
        $stmt->execute(['client_id' => $clientId, 'entity_type' => $entityType]);
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }

    private function invokePrivateMethod(object $target, string $method, array $args = []): mixed
    {
        $ref = new ReflectionClass($target);
        $refMethod = $ref->getMethod($method);
        $refMethod->setAccessible(true);
        return $refMethod->invokeArgs($target, $args);
    }
}
