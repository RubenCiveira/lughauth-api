<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Scheduler {
    final class SupervisorTestKernel
    {
        public static bool $procOpenSuccess = true;
        public static string $procOutput = '123';
        public static array $shellOutputs = [];
        public static array $posixKillCalls = [];
        public static bool $posixKillReturn = true;

        public static function reset(): void
        {
            self::$procOpenSuccess = true;
            self::$procOutput = '123';
            self::$shellOutputs = [];
            self::$posixKillCalls = [];
            self::$posixKillReturn = true;
        }
    }

    function shell_exec(string $command): string|false
    {
        return SupervisorTestKernel::$shellOutputs[$command] ?? '';
    }

    function proc_open($command, array $descriptorSpec, &$pipes, ?string $cwd = null)
    {
        if (!SupervisorTestKernel::$procOpenSuccess) {
            return false;
        }

        $pipes = [
            fopen('php://temp', 'r+'),
            fopen('php://temp', 'r+'),
            fopen('php://temp', 'r+'),
        ];
        fwrite($pipes[1], SupervisorTestKernel::$procOutput);
        rewind($pipes[1]);

        return fopen('php://temp', 'r+');
    }

    function proc_close($resource): int
    {
        if (is_resource($resource)) {
            fclose($resource);
        }
        return 0;
    }

    function posix_kill(int $pid, int $signal): bool
    {
        SupervisorTestKernel::$posixKillCalls[] = [$pid, $signal];
        return SupervisorTestKernel::$posixKillReturn;
    }
}

namespace {
    use PHPUnit\Framework\TestCase;
    use Civi\Lughauth\Shared\Infrastructure\Scheduler\Supervisor;
    use Civi\Lughauth\Shared\Infrastructure\Scheduler\SupervisorTestKernel;

    /**
     * Unit tests for {@see Supervisor}.
     */
    final class SupervisorUnitTest extends TestCase
    {
        protected function setUp(): void
        {
            SupervisorTestKernel::reset();
        }

        /**
         * Ensures running workers prevent spawning.
         */
        public function testEnsureRunningSkipsWhenPidIsActive(): void
        {
            /* Arrange: create a supervisor with an existing PID file. */
            $dir = $this->createTempDir();
            $pidFile = $dir . '/var/scheduler.pid';
            @mkdir(dirname($pidFile), 0775, true);
            file_put_contents($pidFile, '999');
            SupervisorTestKernel::$posixKillReturn = true;

            $supervisor = new Supervisor($dir, PHP_BINARY, $this->createWorker($dir));

            /* Act: ensure the scheduler is running. */
            $supervisor->ensureRunning('http://localhost');

            /* Assert: verify the PID file remains and posix_kill was invoked. */
            $this->assertSame('999', trim(file_get_contents($pidFile)));
            $this->assertNotEmpty(SupervisorTestKernel::$posixKillCalls);
        }

        /**
         * Ensures lock contention prevents worker startup.
         */
        public function testEnsureRunningStopsWhenLockIsHeld(): void
        {
            /* Arrange: hold the scheduler lock before invoking ensureRunning. */
            $dir = $this->createTempDir();
            $lockFile = $dir . '/var/scheduler.lock';
            @mkdir(dirname($lockFile), 0775, true);
            $lockHandle = fopen($lockFile, 'c+');
            flock($lockHandle, LOCK_EX | LOCK_NB);

            $supervisor = new Supervisor($dir, PHP_BINARY, $this->createWorker($dir));

            /* Act: attempt to ensure the worker is running. */
            $supervisor->ensureRunning('http://localhost');

            /* Assert: verify no PID file is created while lock is held. */
            $this->assertFileDoesNotExist($dir . '/var/scheduler.pid');
            flock($lockHandle, LOCK_UN);
            fclose($lockHandle);
        }

        /**
         * Ensures ensureRunning stops when lock cannot be opened.
         */
        public function testEnsureRunningStopsWhenLockCannotBeOpened(): void
        {
            /* Arrange: create a directory where lock file should be. */
            $dir = $this->createTempDir();
            $varDir = $dir . '/var';
            @mkdir($varDir, 0775, true);

            $supervisor = new Supervisor(
                $dir,
                PHP_BINARY,
                $this->createWorker($dir),
                'var/scheduler.pid',
                'var',
                'var/scheduler.log'
            );

            /* Act: attempt to ensure the worker is running. */
            $supervisor->ensureRunning('http://localhost');

            /* Assert: verify no PID or log files are created. */
            $this->assertFileDoesNotExist($dir . '/var/scheduler.pid');
            $this->assertFileDoesNotExist($dir . '/var/scheduler.log');
        }

        /**
         * Ensures background spawning returns the PID.
         */
        public function testSpawnBackgroundReturnsPid(): void
        {
            /* Arrange: configure a supervisor and stubbed process output. */
            $dir = $this->createTempDir();
            $worker = $this->createWorker($dir);
            $supervisor = new Supervisor($dir, PHP_BINARY, $worker);
            SupervisorTestKernel::$shellOutputs['command -v setsid 2>/dev/null'] = '/usr/bin/setsid';
            SupervisorTestKernel::$procOutput = '321';

            $method = new ReflectionMethod($supervisor, 'spawnBackground');
            $method->setAccessible(true);

            /* Act: spawn the worker in the background. */
            $pid = $method->invoke($supervisor, $worker, 'http://localhost', $dir . '/var/scheduler.log');

            /* Assert: verify the PID returned from the stubbed process. */
            $this->assertSame(321, $pid);
        }

        /**
         * Ensures Windows mode returns zero PID.
         */
        public function testSpawnBackgroundReturnsZeroOnWindows(): void
        {
            /* Arrange: use a Windows-marked supervisor. */
            $dir = $this->createTempDir();
            $worker = $this->createWorker($dir);
            $supervisor = new Supervisor($dir, PHP_BINARY, $worker, 'var/scheduler.pid', 'var/scheduler.lock', 'var/scheduler.log', 'Windows');
            $method = new ReflectionMethod($supervisor, 'spawnBackground');
            $method->setAccessible(true);

            /* Act: spawn the worker in Windows mode. */
            $pid = $method->invoke($supervisor, $worker, 'http://localhost', $dir . '/var/scheduler.log');

            /* Assert: verify a zero PID is returned. */
            $this->assertSame(0, $pid);
        }

        /**
         * Ensures spawn failures return zero.
         */
        public function testSpawnBackgroundReturnsZeroWhenProcOpenFails(): void
        {
            /* Arrange: configure proc_open failure. */
            $dir = $this->createTempDir();
            $worker = $this->createWorker($dir);
            $supervisor = new Supervisor($dir, PHP_BINARY, $worker);
            SupervisorTestKernel::$procOpenSuccess = false;

            $method = new ReflectionMethod($supervisor, 'spawnBackground');
            $method->setAccessible(true);

            /* Act: attempt to spawn the worker. */
            $pid = $method->invoke($supervisor, $worker, 'http://localhost', $dir . '/var/scheduler.log');

            /* Assert: verify a zero PID is returned. */
            $this->assertSame(0, $pid);
        }

        /**
         * Ensures stop sends a termination signal.
         */
        public function testStopTerminatesWorker(): void
        {
            /* Arrange: create a PID file and supervisor. */
            $dir = $this->createTempDir();
            $pidFile = $dir . '/var/scheduler.pid';
            @mkdir(dirname($pidFile), 0775, true);
            file_put_contents($pidFile, '777');
            SupervisorTestKernel::$posixKillReturn = true;

            $supervisor = new Supervisor($dir, PHP_BINARY, 'worker');

            /* Act: stop the scheduler worker. */
            $supervisor->stop();

            /* Assert: verify posix_kill was invoked with SIGTERM. */
            $this->assertSame([[777, 0], [777, SIGTERM]], SupervisorTestKernel::$posixKillCalls);
        }

        /**
         * Ensures PHP CLI resolution returns the current binary on CLI.
         */
        public function testResolvePhpCliReturnsCurrentBinary(): void
        {
            /* Arrange: create a supervisor instance. */
            $supervisor = new Supervisor($this->createTempDir(), PHP_BINARY, 'worker');
            $method = new ReflectionMethod($supervisor, 'resolvePhpCli');
            $method->setAccessible(true);

            /* Act: resolve the PHP binary path. */
            $path = $method->invoke($supervisor);

            /* Assert: verify the current PHP binary is returned. */
            $this->assertSame(PHP_BINARY, $path);
        }

        /**
         * Ensures CLI php-fpm binaries are ignored.
         */
        public function testResolvePhpCliSkipsPhpFpmBinary(): void
        {
            /* Arrange: create a supervisor with php-fpm binary override. */
            $supervisor = new Supervisor(
                $this->createTempDir(),
                '',
                'worker',
                'var/scheduler.pid',
                'var/scheduler.lock',
                'var/scheduler.log',
                null,
                null,
                'cli',
                '/usr/sbin/php-fpm'
            );
            $method = new ReflectionMethod($supervisor, 'resolvePhpCli');
            $method->setAccessible(true);

            /* Act: resolve the PHP binary path. */
            $path = $method->invoke($supervisor);

            /* Assert: verify php-fpm is not returned. */
            $this->assertNotSame('/usr/sbin/php-fpm', $path);
        }

        /**
         * Ensures non-CLI SAPIs skip PHP_BINARY preference.
         */
        public function testResolvePhpCliSkipsBinaryWhenNotCli(): void
        {
            /* Arrange: create a supervisor with non-CLI SAPI override. */
            $supervisor = new Supervisor(
                $this->createTempDir(),
                '',
                'worker',
                'var/scheduler.pid',
                'var/scheduler.lock',
                'var/scheduler.log',
                null,
                null,
                'fpm-fcgi',
                '/usr/bin/php'
            );
            $method = new ReflectionMethod($supervisor, 'resolvePhpCli');
            $method->setAccessible(true);

            /* Act: resolve the PHP binary path. */
            $path = $method->invoke($supervisor);

            /* Assert: verify PHP_BINARY is not forced when not CLI. */
            $this->assertNotSame('/usr/bin/php', $path);
        }

        /**
         * Ensures env variables are preferred for PHP CLI resolution.
         */
        public function testResolvePhpCliUsesEnvCandidates(): void
        {
            /* Arrange: set env vars pointing to executable files. */
            $dir = $this->createTempDir();
            $phpCli = $dir . '/php-cli';
            $phpAlt = $dir . '/php-alt';
            $this->createExecutable($phpCli);
            $this->createExecutable($phpAlt);

            $prevCli = getenv('PHP_CLI');
            $prevPhp = getenv('PHP');
            $prevBin = getenv('PHP_BIN');
            putenv('PHP_CLI=' . $phpCli);
            putenv('PHP=' . $phpAlt);
            putenv('PHP_BIN=' . $phpAlt);

            try {
                $supervisor = new Supervisor(
                    $dir,
                    '',
                    'worker',
                    'var/scheduler.pid',
                    'var/scheduler.lock',
                    'var/scheduler.log',
                    null,
                    null,
                    'fpm-fcgi',
                    '/usr/bin/php',
                    []
                );
                $method = new ReflectionMethod($supervisor, 'resolvePhpCli');
                $method->setAccessible(true);

                /* Act: resolve the PHP binary path. */
                $path = $method->invoke($supervisor);

                /* Assert: verify the first env candidate is returned. */
                $this->assertSame($phpCli, $path);
            } finally {
                $this->restoreEnv('PHP_CLI', $prevCli);
                $this->restoreEnv('PHP', $prevPhp);
                $this->restoreEnv('PHP_BIN', $prevBin);
            }
        }

        /**
         * Ensures `which php` candidates are honored.
         */
        public function testResolvePhpCliUsesWhichCandidate(): void
        {
            /* Arrange: stub which php to return an executable. */
            $dir = $this->createTempDir();
            $phpWhich = $dir . '/php-which';
            $this->createExecutable($phpWhich);
            SupervisorTestKernel::$shellOutputs['command -v php 2>/dev/null'] = $phpWhich;

            $prevCli = getenv('PHP_CLI');
            $prevPhp = getenv('PHP');
            $prevBin = getenv('PHP_BIN');
            putenv('PHP_CLI');
            putenv('PHP');
            putenv('PHP_BIN');

            try {
                $supervisor = new Supervisor(
                    $dir,
                    '',
                    'worker',
                    'var/scheduler.pid',
                    'var/scheduler.lock',
                    'var/scheduler.log',
                    null,
                    null,
                    'fpm-fcgi',
                    '/usr/bin/php',
                    []
                );
                $method = new ReflectionMethod($supervisor, 'resolvePhpCli');
                $method->setAccessible(true);

                /* Act: resolve the PHP binary path. */
                $path = $method->invoke($supervisor);

                /* Assert: verify the which candidate is returned. */
                $this->assertSame($phpWhich, $path);
            } finally {
                $this->restoreEnv('PHP_CLI', $prevCli);
                $this->restoreEnv('PHP', $prevPhp);
                $this->restoreEnv('PHP_BIN', $prevBin);
                SupervisorTestKernel::$shellOutputs = [];
            }
        }

        /**
         * Ensures fallback to `php` when no candidates match.
         */
        public function testResolvePhpCliFallsBackToPhpWhenNoCandidates(): void
        {
            /* Arrange: ensure no env or which candidates exist. */
            $dir = $this->createTempDir();
            $prevCli = getenv('PHP_CLI');
            $prevPhp = getenv('PHP');
            $prevBin = getenv('PHP_BIN');
            putenv('PHP_CLI');
            putenv('PHP');
            putenv('PHP_BIN');
            SupervisorTestKernel::$shellOutputs['command -v php 2>/dev/null'] = '';

            try {
                $supervisor = new Supervisor(
                    $dir,
                    '',
                    'worker',
                    'var/scheduler.pid',
                    'var/scheduler.lock',
                    'var/scheduler.log',
                    null,
                    null,
                    'fpm-fcgi',
                    '/usr/bin/php',
                    []
                );
                $method = new ReflectionMethod($supervisor, 'resolvePhpCli');
                $method->setAccessible(true);

                /* Act: resolve the PHP binary path. */
                $path = $method->invoke($supervisor);

                /* Assert: verify fallback to plain php. */
                $this->assertSame('php', $path);
            } finally {
                $this->restoreEnv('PHP_CLI', $prevCli);
                $this->restoreEnv('PHP', $prevPhp);
                $this->restoreEnv('PHP_BIN', $prevBin);
                SupervisorTestKernel::$shellOutputs = [];
            }
        }

        /**
         * Ensures relative and absolute paths are resolved correctly.
         */
        public function testPathResolvesRelativeAndAbsolute(): void
        {
            /* Arrange: create a supervisor and access the path method. */
            $dir = $this->createTempDir();
            $supervisor = new Supervisor($dir, PHP_BINARY, 'worker');
            $method = new ReflectionMethod($supervisor, 'path');
            $method->setAccessible(true);

            /* Act: resolve a relative and an absolute path. */
            $relative = $method->invoke($supervisor, 'var/logs');
            $absolute = $method->invoke($supervisor, '/tmp/absolute');

            /* Assert: verify resolved paths match expectations. */
            $this->assertSame($dir . '/var/logs', $relative);
            $this->assertSame('/tmp/absolute', $absolute);
        }

        /**
         * Ensures PID parsing handles missing and invalid files.
         */
        public function testReadPidHandlesMissingAndInvalid(): void
        {
            /* Arrange: create a supervisor and PID file fixtures. */
            $dir = $this->createTempDir();
            $supervisor = new Supervisor($dir, PHP_BINARY, 'worker');
            $method = new ReflectionMethod($supervisor, 'readPid');
            $method->setAccessible(true);

            $missing = $dir . '/missing.pid';
            $invalid = $dir . '/invalid.pid';
            file_put_contents($invalid, 'abc');

            /* Act: read missing and invalid PID files. */
            $missingPid = $method->invoke($supervisor, $missing);
            $invalidPid = $method->invoke($supervisor, $invalid);

            /* Assert: verify null results are returned. */
            $this->assertNull($missingPid);
            $this->assertNull($invalidPid);
        }

        /**
         * Ensures stale PID files are removed and failures are logged.
         */
        public function testEnsureRunningRemovesStalePidAndLogsFailure(): void
        {
            /* Arrange: create a supervisor with a stale PID and failing spawn. */
            $dir = $this->createTempDir();
            $pidFile = $dir . '/var/scheduler.pid';
            $logFile = $dir . '/var/scheduler.log';
            @mkdir(dirname($pidFile), 0775, true);
            file_put_contents($pidFile, '555');

            SupervisorTestKernel::$posixKillReturn = false;
            SupervisorTestKernel::$procOpenSuccess = false;

            $supervisor = new Supervisor($dir, PHP_BINARY, 'worker');

            /* Act: ensure the scheduler is running. */
            $supervisor->ensureRunning('http://localhost');

            /* Assert: verify stale PID is removed and failure logged. */
            $this->assertFileDoesNotExist($pidFile);
            $this->assertStringContainsString('spawn failed', file_get_contents($logFile));
        }

        /**
         * Ensures fallback is used when posix_kill is unavailable.
         */
        public function testEnsureRunningUsesProcFallbackWhenPosixUnavailable(): void
        {
            /* Arrange: create a supervisor with a stale PID and no posix support. */
            $dir = $this->createTempDir();
            $pidFile = $dir . '/var/scheduler.pid';
            $logFile = $dir . '/var/scheduler.log';
            @mkdir(dirname($pidFile), 0775, true);
            file_put_contents($pidFile, '444');

            SupervisorTestKernel::$procOpenSuccess = false;

            $supervisor = new Supervisor(
                $dir,
                PHP_BINARY,
                'worker',
                'var/scheduler.pid',
                'var/scheduler.lock',
                'var/scheduler.log',
                null,
                false
            );

            /* Act: ensure the scheduler is running. */
            $supervisor->ensureRunning('http://localhost');

            /* Assert: verify fallback path and no posix_kill usage. */
            $this->assertFileDoesNotExist($pidFile);
            $this->assertStringContainsString('spawn failed', file_get_contents($logFile));
            $this->assertEmpty(SupervisorTestKernel::$posixKillCalls);
        }

        /**
         * Ensures new PID files are written when spawning succeeds.
         */
        public function testEnsureRunningWritesPidWhenSpawnSucceeds(): void
        {
            /* Arrange: create a supervisor configured for a successful spawn. */
            $dir = $this->createTempDir();
            SupervisorTestKernel::$posixKillReturn = false;
            SupervisorTestKernel::$procOpenSuccess = true;
            SupervisorTestKernel::$procOutput = '888';

            $supervisor = new Supervisor($dir, PHP_BINARY, $this->createWorker($dir));

            /* Act: ensure the scheduler is running. */
            $supervisor->ensureRunning('http://localhost');

            /* Assert: verify a PID file is written with the spawn PID. */
            $this->assertSame('888', trim(file_get_contents($dir . '/var/scheduler.pid')));
        }

        private function createTempDir(): string
        {
            $dir = sys_get_temp_dir() . '/scheduler_' . uniqid();
            mkdir($dir, 0777, true);
            return $dir;
        }

        private function createWorker(string $dir): string
        {
            $worker = $dir . '/worker.php';
            file_put_contents($worker, "<?php echo 'worker';");
            return $worker;
        }

        private function createExecutable(string $path): void
        {
            file_put_contents($path, "#!/bin/sh\nexit 0\n");
            @chmod($path, 0755);
        }

        private function restoreEnv(string $key, string|false $value): void
        {
            if ($value === false) {
                putenv($key);
                return;
            }

            putenv($key . '=' . $value);
        }
    }
}
