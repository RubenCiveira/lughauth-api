<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Scheduler {
    final class SchedulerTestRegistry
    {
        public static array $callbacks = [];

        public static function reset(): void
        {
            self::$callbacks = [];
        }
    }

    function register_shutdown_function(callable $callback, ...$args): void
    {
        SchedulerTestRegistry::$callbacks[] = [$callback, $args];
    }
}

namespace {
    use PHPUnit\Framework\TestCase;
    use Cron\CronExpression;
    use Psr\Container\ContainerInterface;
    use Psr\SimpleCache\CacheInterface;
    use Symfony\Component\Lock\Key;
    use Symfony\Component\Lock\LockFactory;
    use Symfony\Component\Lock\PersistingStoreInterface;
    use Symfony\Component\Lock\Exception\LockConflictedException;
    use Civi\Lughauth\Shared\Infrastructure\Scheduler\SchedulerManager;
    use Civi\Lughauth\Shared\Infrastructure\Scheduler\SchedulerTestRegistry;

    /**
     * Unit tests for {@see SchedulerManager}.
     */
    final class SchedulerManagerUnitTest extends TestCase
    {
        protected function setUp(): void
        {
            SchedulerTestRegistry::reset();
        }

        /**
         * Ensures scheduled tasks execute and update cached state.
         */
        public function testRunExecutesTasksAndUpdatesState(): void
        {
            /* Arrange: register runnable tasks with different outcomes. */
            $manager = new SchedulerTestManager();
            $manager->register(CronExpression::factory('* * * * *'), SchedulerTestTask::class, 'run');
            $manager->register(CronExpression::factory('* * * * *'), SchedulerTestTask::class, 'missing');
            $manager->register(CronExpression::factory('* * * * *'), SchedulerThrowingTask::class, 'run');
            $manager->register(CronExpression::factory('* * * * *'), SchedulerMissingTask::class, 'run');

            $cache = new SchedulerTestCache([
                'last_executions' => [],
                'next_execution' => null,
            ]);
            $locker = new LockFactory(new SchedulerTestStore(true));

            $container = new SchedulerTestContainer([
                SchedulerTestTask::class => new SchedulerTestTask(),
                SchedulerThrowingTask::class => new SchedulerThrowingTask(),
            ]);

            /* Act: run the manager and invoke the shutdown callback. */
            $manager->run($locker, $cache, $container);
            [$callback, $args] = SchedulerTestRegistry::$callbacks[0];
            $callback(...$args);

            /* Assert: verify successful tasks update state and execute. */
            $this->assertTrue($container->get(SchedulerTestTask::class)->ran);
            $this->assertArrayHasKey(SchedulerTestTask::class . '::run', $cache->state['last_executions']);
            $this->assertArrayNotHasKey(SchedulerTestTask::class . '::missing', $cache->state['last_executions']);
            $this->assertArrayNotHasKey(SchedulerThrowingTask::class . '::run', $cache->state['last_executions']);
            $this->assertArrayNotHasKey(SchedulerMissingTask::class . '::run', $cache->state['last_executions']);
            $this->assertNotNull($cache->state['next_execution']);
        }

        /**
         * Ensures no shutdown callback is registered when next execution is in the future.
         */
        public function testRunSkipsWhenNextExecutionIsFuture(): void
        {
            /* Arrange: configure cached state in the future. */
            $manager = new SchedulerTestManager();
            $manager->register(CronExpression::factory('* * * * *'), SchedulerTestTask::class, 'run');

            $future = (new DateTimeImmutable('+1 hour'))->format(DATE_ATOM);
            $cache = new SchedulerTestCache([
                'last_executions' => [],
                'next_execution' => $future,
            ]);
            $locker = new LockFactory(new SchedulerTestStore(true));
            $container = new SchedulerTestContainer([SchedulerTestTask::class => new SchedulerTestTask()]);

            /* Act: run the manager with a future next execution. */
            $manager->run($locker, $cache, $container);

            /* Assert: verify no deferred callback is registered. */
            $this->assertSame([], SchedulerTestRegistry::$callbacks);
        }

        /**
         * Ensures the scheduler does not run when the lock cannot be acquired.
         */
        public function testRunSkipsWhenLockUnavailable(): void
        {
            /* Arrange: create a runnable task with a locked scheduler. */
            $manager = new SchedulerTestManager();
            $manager->register(CronExpression::factory('* * * * *'), SchedulerTestTask::class, 'run');

            $cache = new SchedulerTestCache([
                'last_executions' => [],
                'next_execution' => null,
            ]);
            $locker = new LockFactory(new SchedulerTestStore(false));
            $container = new SchedulerTestContainer([SchedulerTestTask::class => new SchedulerTestTask()]);

            /* Act: run the manager and invoke the shutdown callback. */
            $manager->run($locker, $cache, $container);
            [$callback, $args] = SchedulerTestRegistry::$callbacks[0];
            $callback(...$args);

            /* Assert: verify no task executions were recorded. */
            $this->assertFalse($container->get(SchedulerTestTask::class)->ran);
            $this->assertSame([], $cache->state['last_executions']);
        }

        /**
         * Ensures cached last execution timestamps are respected.
         */
        public function testRunRespectsLastExecutionState(): void
        {
            /* Arrange: register a task with an existing last execution. */
            $manager = new SchedulerTestManager();
            $manager->register(CronExpression::factory('* * * * *'), SchedulerTestTask::class, 'run');

            $taskKey = SchedulerTestTask::class . '::run';
            $lastExecution = (new DateTimeImmutable('now'))->format(DATE_ATOM);
            $cache = new SchedulerTestCache([
                'last_executions' => [$taskKey => $lastExecution],
                'next_execution' => null,
            ]);
            $locker = new LockFactory(new SchedulerTestStore(true));
            $container = new SchedulerTestContainer([SchedulerTestTask::class => new SchedulerTestTask()]);

            /* Act: run the manager and invoke the shutdown callback. */
            $manager->run($locker, $cache, $container);
            [$callback, $args] = SchedulerTestRegistry::$callbacks[0];
            $callback(...$args);

            /* Assert: verify the cached last execution stays unchanged. */
            $this->assertSame($lastExecution, $cache->state['last_executions'][$taskKey]);
            $this->assertFalse($container->get(SchedulerTestTask::class)->ran);
        }

        /**
         * Ensures task keys are built from type and method.
         */
        public function testGetTaskKeyUsesTypeAndMethod(): void
        {
            /* Arrange: prepare a scheduler manager and reflection access. */
            $manager = new SchedulerTestManager();
            $method = new ReflectionMethod($manager, 'getTaskKey');
            $method->setAccessible(true);

            /* Act: build a task key. */
            $key = $method->invoke($manager, 'Type', 'method');

            /* Assert: verify the expected key format. */
            $this->assertSame('Type::method', $key);
        }
    }

    final class SchedulerTestCache implements CacheInterface
    {
        public array $state;

        public function __construct(array $state)
        {
            $this->state = $state;
        }

        public function get($key, $default = null): mixed
        {
            return $this->state;
        }

        public function set($key, $value, $ttl = null): bool
        {
            $this->state = $value;
            return true;
        }

        public function delete($key): bool
        {
            return true;
        }

        public function clear(): bool
        {
            return true;
        }

        public function getMultiple($keys, $default = null): iterable
        {
            return [];
        }

        public function setMultiple($values, $ttl = null): bool
        {
            return true;
        }

        public function deleteMultiple($keys): bool
        {
            return true;
        }

        public function has($key): bool
        {
            return true;
        }
    }

    final class SchedulerTestManager extends SchedulerManager
    {
        public array $errors = [];

        public function logError($message, $context = []): void
        {
            $this->errors[] = [$message, $context];
        }
    }

    final class SchedulerTestStore implements PersistingStoreInterface
    {
        private bool $locked = false;

        public function __construct(private bool $allowAcquire)
        {
        }

        public function save(Key $key): void
        {
            if (!$this->allowAcquire) {
                throw new LockConflictedException();
            }

            $this->locked = true;
        }

        public function delete(Key $key): void
        {
            $this->locked = false;
        }

        public function exists(Key $key): bool
        {
            return $this->locked;
        }

        public function putOffExpiration(Key $key, float $ttl): void
        {
        }
    }

    final class SchedulerTestContainer implements ContainerInterface
    {
        public function __construct(private array $services)
        {
        }

        public function get(string $id)
        {
            return $this->services[$id];
        }

        public function has(string $id): bool
        {
            return array_key_exists($id, $this->services);
        }
    }

    final class SchedulerTestTask
    {
        public bool $ran = false;

        public function run(): void
        {
            $this->ran = true;
        }
    }

    final class SchedulerThrowingTask
    {
        public function run(): void
        {
            throw new RuntimeException('Boom');
        }
    }

    final class SchedulerMissingTask
    {
    }
}
