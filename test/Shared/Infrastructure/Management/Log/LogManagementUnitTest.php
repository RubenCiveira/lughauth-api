<?php

/* @autogenerated */
declare(strict_types=1);

require_once __DIR__ . '/LogManagementGzOverrides.php';

use PHPUnit\Framework\TestCase;
use Psr\Http\Message\ServerRequestInterface;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Infrastructure\Management\Log\LogManagement;

/**
 * Unit tests for {@see LogManagement}.
 */
final class LogManagementUnitTest extends TestCase
{
    /**
     * Verifies filtered log entries are returned from storage.
     */
    public function testGetFiltersAndReadsLogs(): void
    {
        /* Arrange: build log files and the management query input. */
        $dir = $this->createLogDir();
        $this->writeLog($dir . '/app-2024.jsonl', [
            ['message' => 'hello', 'level' => 100, 'level_name' => 'DEBUG', 'datetime' => '2024-01-01 00:00:00', 'extra' => ['service' => ['service.name' => 'svc'], 'traceId' => 't1']]
        ]);

        $this->writeGzLog($dir . '/app-2023.jsonl.gz', [
            ['message' => 'world', 'level' => 200, 'level_name' => 'INFO', 'datetime' => '2024-01-02 00:00:00', 'extra' => ['service' => ['service.name' => 'svc'], 'traceId' => 't2']]
        ]);

        $management = new LogManagement($this->config('app'), $dir);
        $request = $this->request(['search' => 'hello', 'limit' => 10]);

        /* Act: execute the log query handler with filter parameters. */
        $result = ($management->get())($request);

        /* Assert: verify the returned entries match the filter. */
        $this->assertCount(1, $result);
        $this->assertSame('hello', $result[0]['message']);
    }

    /**
     * Ensures invalid log lines are skipped during parsing.
     */
    public function testGetSkipsInvalidLines(): void
    {
        /* Arrange: create a log file containing invalid entries. */
        $dir = $this->createLogDir();
        file_put_contents($dir . '/app-2024.jsonl', "\ninvalid\n");

        $management = new LogManagement($this->config('app'), $dir);

        /* Act: execute the log query handler without filters. */
        $result = ($management->get())($this->request([]));

        /* Assert: verify that no results are returned. */
        $this->assertSame([], $result);
    }

    /**
     * Ensures offsets and limits are applied to matching entries.
     */
    public function testGetAppliesOffsetAndLimit(): void
    {
        /* Arrange: create logs with multiple entries. */
        $dir = $this->createLogDir();
        $this->writeLog($dir . '/app-2025.jsonl', [
            ['message' => 'first', 'level' => 100, 'level_name' => 'DEBUG', 'datetime' => '2024-01-01 00:00:00', 'extra' => ['service' => ['service.name' => 'svc']]],
            ['message' => 'second', 'level' => 100, 'level_name' => 'DEBUG', 'datetime' => '2024-01-01 00:00:01', 'extra' => ['service' => ['service.name' => 'svc']]],
            ['message' => 'third', 'level' => 100, 'level_name' => 'DEBUG', 'datetime' => '2024-01-01 00:00:02', 'extra' => ['service' => ['service.name' => 'svc']]]
        ]);

        $management = new LogManagement($this->config('app'), $dir);
        $request = $this->request(['offset' => 1, 'limit' => 1]);

        /* Act: execute the handler with pagination. */
        $result = ($management->get())($request);

        /* Assert: verify only the second entry is returned. */
        $this->assertCount(1, $result);
        $this->assertSame('second', $result[0]['message']);
    }

    /**
     * Ensures service, trace, and level filters are enforced.
     */
    public function testGetFiltersByServiceTraceAndLevel(): void
    {
        /* Arrange: create matching and non-matching entries. */
        $dir = $this->createLogDir();
        $this->writeLog($dir . '/app-2024.jsonl', [
            [
                'message' => 'hit',
                'level' => 200,
                'level_name' => 'INFO',
                'datetime' => '2024-01-02 00:00:00',
                'extra' => [
                    'service' => [
                        'service.name' => 'svc',
                        'service.namespace' => 'ns',
                        'service.version' => '1.0',
                        'service.instance.id' => 'i-1',
                        'deployment.environment' => 'prod'
                    ],
                    'traceId' => 't1',
                    'spanId' => 's1'
                ]
            ],
            [
                'message' => 'miss',
                'level' => 100,
                'level_name' => 'DEBUG',
                'datetime' => '2024-01-02 00:00:00',
                'extra' => ['service' => ['service.name' => 'other']]
            ]
        ]);

        $management = new LogManagement($this->config('app'), $dir);
        $request = $this->request([
            'service-name' => 'svc',
            'service-namespace' => 'ns',
            'service-version' => '1.0',
            'service-instance' => 'i-1',
            'deployment-environment' => 'prod',
            'trace-id' => 't1',
            'span-id' => 's1',
            'level' => 200,
            'level-name' => 'INFO',
            'from' => '2024-01-01 00:00:00',
            'to' => '2024-01-03 00:00:00'
        ]);

        /* Act: execute the handler with full filters. */
        $result = ($management->get())($request);

        /* Assert: only the matching entry is returned. */
        $this->assertCount(1, $result);
        $this->assertSame('hit', $result[0]['message']);
    }

    /**
     * Ensures each filter excludes non-matching records.
     */
    public function testGetSkipsLinesFailingAnyFilter(): void
    {
        /* Arrange: create entries each failing a different filter. */
        $dir = $this->createLogDir();
        $this->writeLog($dir . '/app-2024.jsonl', [
            ['message' => 'too-early', 'level' => 200, 'level_name' => 'INFO', 'datetime' => '2023-12-31 23:59:59', 'extra' => ['service' => ['service.name' => 'svc', 'service.namespace' => 'ns', 'service.version' => '1.0', 'service.instance.id' => 'i-1', 'deployment.environment' => 'prod'], 'traceId' => 't1', 'spanId' => 's1']],
            ['message' => 'too-late', 'level' => 200, 'level_name' => 'INFO', 'datetime' => '2024-02-01 00:00:01', 'extra' => ['service' => ['service.name' => 'svc', 'service.namespace' => 'ns', 'service.version' => '1.0', 'service.instance.id' => 'i-1', 'deployment.environment' => 'prod'], 'traceId' => 't1', 'spanId' => 's1']],
            ['message' => 'bad-service', 'level' => 200, 'level_name' => 'INFO', 'datetime' => '2024-01-15 00:00:00', 'extra' => ['service' => ['service.name' => 'other', 'service.namespace' => 'ns', 'service.version' => '1.0', 'service.instance.id' => 'i-1', 'deployment.environment' => 'prod'], 'traceId' => 't1', 'spanId' => 's1']],
            ['message' => 'bad-namespace', 'level' => 200, 'level_name' => 'INFO', 'datetime' => '2024-01-15 00:00:00', 'extra' => ['service' => ['service.name' => 'svc', 'service.namespace' => 'other', 'service.version' => '1.0', 'service.instance.id' => 'i-1', 'deployment.environment' => 'prod'], 'traceId' => 't1', 'spanId' => 's1']],
            ['message' => 'bad-version', 'level' => 200, 'level_name' => 'INFO', 'datetime' => '2024-01-15 00:00:00', 'extra' => ['service' => ['service.name' => 'svc', 'service.namespace' => 'ns', 'service.version' => '2.0', 'service.instance.id' => 'i-1', 'deployment.environment' => 'prod'], 'traceId' => 't1', 'spanId' => 's1']],
            ['message' => 'bad-instance', 'level' => 200, 'level_name' => 'INFO', 'datetime' => '2024-01-15 00:00:00', 'extra' => ['service' => ['service.name' => 'svc', 'service.namespace' => 'ns', 'service.version' => '1.0', 'service.instance.id' => 'i-2', 'deployment.environment' => 'prod'], 'traceId' => 't1', 'spanId' => 's1']],
            ['message' => 'bad-env', 'level' => 200, 'level_name' => 'INFO', 'datetime' => '2024-01-15 00:00:00', 'extra' => ['service' => ['service.name' => 'svc', 'service.namespace' => 'ns', 'service.version' => '1.0', 'service.instance.id' => 'i-1', 'deployment.environment' => 'dev'], 'traceId' => 't1', 'spanId' => 's1']],
            ['message' => 'bad-trace', 'level' => 200, 'level_name' => 'INFO', 'datetime' => '2024-01-15 00:00:00', 'extra' => ['service' => ['service.name' => 'svc', 'service.namespace' => 'ns', 'service.version' => '1.0', 'service.instance.id' => 'i-1', 'deployment.environment' => 'prod'], 'traceId' => 't2', 'spanId' => 's1']],
            ['message' => 'bad-span', 'level' => 200, 'level_name' => 'INFO', 'datetime' => '2024-01-15 00:00:00', 'extra' => ['service' => ['service.name' => 'svc', 'service.namespace' => 'ns', 'service.version' => '1.0', 'service.instance.id' => 'i-1', 'deployment.environment' => 'prod'], 'traceId' => 't1', 'spanId' => 's2']],
            ['message' => 'bad-level', 'level' => 100, 'level_name' => 'DEBUG', 'datetime' => '2024-01-15 00:00:00', 'extra' => ['service' => ['service.name' => 'svc', 'service.namespace' => 'ns', 'service.version' => '1.0', 'service.instance.id' => 'i-1', 'deployment.environment' => 'prod'], 'traceId' => 't1', 'spanId' => 's1']],
            ['message' => 'bad-level-name', 'level' => 200, 'level_name' => 'WARN', 'datetime' => '2024-01-15 00:00:00', 'extra' => ['service' => ['service.name' => 'svc', 'service.namespace' => 'ns', 'service.version' => '1.0', 'service.instance.id' => 'i-1', 'deployment.environment' => 'prod'], 'traceId' => 't1', 'spanId' => 's1']],
            ['message' => 'hit', 'level' => 200, 'level_name' => 'INFO', 'datetime' => '2024-01-15 00:00:00', 'extra' => ['service' => ['service.name' => 'svc', 'service.namespace' => 'ns', 'service.version' => '1.0', 'service.instance.id' => 'i-1', 'deployment.environment' => 'prod'], 'traceId' => 't1', 'spanId' => 's1']]
        ]);

        $management = new LogManagement($this->config('app'), $dir);
        $request = $this->request([
            'from' => '2024-01-01 00:00:00',
            'to' => '2024-02-01 00:00:00',
            'service-name' => 'svc',
            'service-namespace' => 'ns',
            'service-version' => '1.0',
            'service-instance' => 'i-1',
            'deployment-environment' => 'prod',
            'trace-id' => 't1',
            'span-id' => 's1',
            'level' => 200,
            'level-name' => 'INFO'
        ]);

        /* Act: execute the log query handler with filters. */
        $result = ($management->get())($request);

        /* Assert: only the matching entry is returned. */
        $this->assertCount(1, $result);
        $this->assertSame('hit', $result[0]['message']);
    }

    /**
     * Ensures name and write handler are exposed as expected.
     */
    public function testNameAndSet(): void
    {
        /* Arrange: create management instance. */
        $management = new LogManagement($this->config('app'), $this->createLogDir());

        /* Act: read name and set handler. */
        $name = $management->name();
        $set = $management->set();

        /* Assert: verify management metadata. */
        $this->assertSame('log', $name);
        $this->assertNull($set);
    }

    /**
     * Ensures unreadable plain log files yield no lines.
     */
    public function testIterateLinesSkipsUnreadablePlainFile(): void
    {
        /* Arrange: create an unreadable plain log file. */
        $dir = $this->createLogDir();
        $path = $dir . '/app-2024.jsonl';
        file_put_contents($path, "{\"message\":\"hello\"}\n");
        chmod($path, 0000);

        $management = new LogManagement($this->config('app'), $dir);

        /* Act: invoke iterateLines via reflection. */
        $lines = $this->invokeIterateLines($management, $path);

        /* Assert: no lines are yielded. */
        $this->assertSame([], $lines);
    }

    /**
     * Ensures unreadable gz log files yield no lines.
     */
    public function testIterateLinesSkipsUnreadableGzFile(): void
    {
        /* Arrange: create an unreadable gz log file. */
        $dir = $this->createLogDir();
        $path = $dir . '/app-2024.jsonl.gz';
        file_put_contents($path, gzencode("{\"message\":\"hello\"}\n"));
        chmod($path, 0000);

        $management = new LogManagement($this->config('app'), $dir);

        /* Act: invoke iterateLines via reflection. */
        $lines = $this->invokeIterateLines($management, $path);

        /* Assert: no lines are yielded. */
        $this->assertSame([], $lines);
    }

    /**
     * Ensures blank lines are yielded from gzipped logs.
     */
    public function testIterateLinesYieldsBlankLineFromGz(): void
    {
        /* Arrange: write a gz log containing a blank line and a value. */
        $dir = $this->createLogDir();
        $path = $dir . '/app-2024.jsonl.gz';
        file_put_contents($path, gzencode("\nvalue\n"));

        $management = new LogManagement($this->config('app'), $dir);

        /* Act: invoke iterateLines via reflection. */
        $lines = $this->invokeIterateLines($management, $path);

        /* Assert: the blank line is yielded as empty string. */
        $this->assertSame(['', 'value'], $lines);
    }

    /**
     * Ensures gzgets returning false stops iteration.
     *
     * @runInSeparateProcess
     */
    public function testIterateLinesStopsWhenGzGetsFalse(): void
    {
        $GLOBALS['__test_force_gzgets_false'] = true;

        /* Arrange: create a gz path (content ignored by overrides). */
        $dir = $this->createLogDir();
        $path = $dir . '/app-2024.jsonl.gz';
        file_put_contents($path, 'ignored');

        $management = new LogManagement($this->config('app'), $dir);

        /* Act: invoke iterateLines via reflection. */
        $lines = $this->invokeIterateLines($management, $path);

        unset($GLOBALS['__test_force_gzgets_false']);

        /* Assert: no lines are yielded when gzgets returns false. */
        $this->assertSame([], $lines);
    }

    private function createLogDir(): string
    {
        $dir = sys_get_temp_dir() . '/logs_' . uniqid();
        mkdir($dir, 0777, true);
        return $dir;
    }

    private function writeLog(string $path, array $rows): void
    {
        $lines = array_map(fn ($row) => json_encode($row, JSON_THROW_ON_ERROR), $rows);
        file_put_contents($path, implode("\n", $lines));
    }

    private function writeGzLog(string $path, array $rows): void
    {
        $lines = array_map(fn ($row) => json_encode($row, JSON_THROW_ON_ERROR), $rows);
        $content = implode("\n", $lines);
        file_put_contents($path, gzencode($content));
    }

    private function config(string $name): AppConfig
    {
        return new class ($name) extends AppConfig {
            public function __construct(private readonly string $value)
            {
                $this->develop = true;
                $this->name = $this->value;
                $this->managementEndpoint = '/management';
            }
        };
    }

    private function request(array $params): ServerRequestInterface
    {
        $request = $this->createMock(ServerRequestInterface::class);
        $request->method('getQueryParams')->willReturn($params);
        return $request;
    }

    private function invokeIterateLines(LogManagement $management, string $path): array
    {
        $method = new ReflectionMethod(LogManagement::class, 'iterateLines');
        $method->setAccessible(true);
        $generator = $method->invoke($management, $path);
        if ($generator === null) {
            return [];
        }
        return iterator_to_array($generator, false);
    }
}
