<?php

/* @autogenerated */
declare(strict_types=1);

require_once __DIR__ . '/TraceManagementGzOverrides.php';

use PHPUnit\Framework\TestCase;
use Psr\Http\Message\ServerRequestInterface;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Infrastructure\Management\Trace\TraceManagement;

/**
 * Unit tests for {@see TraceManagement}.
 */
final class TraceManagementUnitTest extends TestCase
{
    /**
     * Ensures traces can be filtered by trace identifier.
     */
    public function testGetFiltersByTraceId(): void
    {
        /* Arrange: write trace entries and prepare a filtered request. */
        $dir = $this->createTraceDir();
        $this->writeTrace($dir . '/app-2024.jsonl', [
            ['traceId' => 't1', 'name' => 'root', 'status' => 'OK', 'parentSpanId' => '0000000000000000', 'extra' => ['service' => ['service.namespace' => 'ns']]],
            ['traceId' => 't2', 'name' => 'child', 'status' => 'OK', 'parentSpanId' => '0000000000000000', 'extra' => ['service' => ['service.namespace' => 'ns']]]
        ]);

        $management = new TraceManagement($this->config('app'), $dir);
        $request = $this->request(['trace-id' => 't1']);

        /* Act: execute the trace query handler. */
        $result = ($management->get())($request);

        /* Assert: verify only the matching trace is returned. */
        $this->assertCount(1, $result);
        $this->assertSame('t1', $result[0]['traceId']);
        $this->assertNull($management->set());
        $this->assertSame('trace', $management->name());

    }

    /**
     * Ensures unfiltered queries return only root spans.
     */
    public function testGetWithoutFiltersReturnsRootSpans(): void
    {
        /* Arrange: write trace entries with root and child spans. */
        $dir = $this->createTraceDir();
        $this->writeTrace($dir . '/app-2024.jsonl', [
            ['traceId' => 't1', 'name' => 'root', 'status' => 'OK', 'parentSpanId' => '0000000000000000', 'extra' => ['service' => ['service.namespace' => 'ns']]],
            ['traceId' => 't1', 'name' => 'child', 'status' => 'OK', 'parentSpanId' => 'span', 'extra' => ['service' => ['service.namespace' => 'ns']]]
        ]);

        $management = new TraceManagement($this->config('app'), $dir);
        $request = $this->request([]);

        /* Act: execute the trace query handler without filters. */
        $result = ($management->get())($request);

        /* Assert: verify only root spans are returned. */
        $this->assertCount(1, $result);
        $this->assertSame('root', $result[0]['name']);
    }

    /**
     * Ensures invalid trace lines are ignored during parsing.
     */
    public function testGetSkipsInvalidLines(): void
    {
        /* Arrange: create a trace file containing invalid lines. */
        $dir = $this->createTraceDir();
        file_put_contents($dir . '/app-2024.jsonl', "\ninvalid\n");

        $management = new TraceManagement($this->config('app'), $dir);

        /* Act: execute the trace query handler. */
        $result = ($management->get())($this->request([]));

        /* Assert: verify no traces are returned. */
        $this->assertSame([], $result);
    }

    /**
     * Ensures all filter combinations work correctly with limit and offset.
     */
    public function testGetWithAllFiltersAndLimit(): void
    {
        /* Arrange: create comprehensive trace data with all filterable fields. */
        $dir = $this->createTraceDir();
        $this->writeTrace($dir . '/app-2024.jsonl', [
            [
                'traceId' => 'trace-123',
                'name' => 'HTTP GET /api/users',
                'status' => 'ok',
                'parentSpanId' => '0000000000000000',
                'extra' => [
                    'service' => [
                        'sdervice.name' => 'auth-service',
                        'service.namespace' => 'production',
                        'service.version' => '1.2.3',
                        'service.instance.id' => 'instance-456',
                        'deployment.environment' => 'prod'
                    ]
                ]
            ],
            [
                'traceId' => 'trace-123',
                'name' => 'Database Query',
                'status' => 'error',
                'parentSpanId' => 'span-parent-789',
                'extra' => [
                    'service' => [
                        'sdervice.name' => 'auth-service',
                        'service.namespace' => 'production',
                        'service.version' => '1.2.3',
                        'service.instance.id' => 'instance-456',
                        'deployment.environment' => 'prod'
                    ]
                ]
            ],
            [
                'traceId' => 'trace-789',
                'name' => 'HTTP POST /api/login',
                'status' => 'ok',
                'parentSpanId' => '0000000000000000',
                'extra' => [
                    'service' => [
                        'sdervice.name' => 'different-service',
                        'service.namespace' => 'staging',
                        'service.version' => '2.0.0',
                        'service.instance.id' => 'instance-999',
                        'deployment.environment' => 'dev'
                    ]
                ]
            ],
            [
                'traceId' => 'trace-456',
                'name' => 'User Authentication',
                'status' => 'ok',
                'parentSpanId' => '0000000000000000',
                'extra' => [
                    'service' => [
                        'sdervice.name' => 'auth-service',
                        'service.namespace' => 'production',
                        'service.version' => '1.2.3',
                        'service.instance.id' => 'instance-456',
                        'deployment.environment' => 'prod'
                    ]
                ]
            ]
        ]);

        $management = new TraceManagement($this->config('app'), $dir);

        /* Act & Assert: Test each individual filter */
        // When not using trace-id filter, only root spans are returned (parentSpanId === '0000000000000000')
        $result = ($management->get())($this->request(['status' => 'error']));
        $this->assertCount(0, $result); // error span is not a root span

        // With trace-id filter, all matching spans are returned
        $result = ($management->get())($this->request(['trace-id' => 'trace-123']));
        $this->assertCount(2, $result);

        // Without trace-id filter, only root spans are returned
        $result = ($management->get())($this->request(['service-name' => 'auth-service']));
        $this->assertCount(2, $result); // only root spans matching service-name

        $result = ($management->get())($this->request(['service-namespace' => 'production']));
        $this->assertCount(2, $result);

        $result = ($management->get())($this->request(['service-version' => '1.2.3']));
        $this->assertCount(2, $result);

        $result = ($management->get())($this->request(['service-instance' => 'instance-456']));
        $this->assertCount(2, $result);

        $result = ($management->get())($this->request(['deployment.environment' => 'prod']));
        $this->assertCount(2, $result);

        // With trace-id filter, all spans are returned
        $result = ($management->get())($this->request(['trace-id' => 'trace-123']));
        $this->assertCount(2, $result);

        // Without trace-id filter, only root spans are returned
        $result = ($management->get())($this->request(['search' => 'HTTP']));
        $this->assertCount(2, $result);

        $result = ($management->get())($this->request(['search' => 'authentication']));
        $this->assertCount(1, $result);

        /* Act & Assert: Test combined filters */
        $result = ($management->get())($this->request([
            'service-name' => 'auth-service',
            'service-namespace' => 'production',
            'service-version' => '1.2.3',
            'service-instance' => 'instance-456',
            'deployment.environment' => 'prod',
            'status' => 'ok'
        ]));
        $this->assertCount(2, $result); // only root spans matching all filters

        /* Act & Assert: Test limit and offset */
        $result = ($management->get())($this->request(['limit' => 2]));
        $this->assertCount(2, $result);

        $result = ($management->get())($this->request(['limit' => 2, 'offset' => 1]));
        $this->assertCount(2, $result);

        $result = ($management->get())($this->request(['limit' => 1, 'offset' => 2]));
        $this->assertCount(1, $result);

        /* Act & Assert: Test limit break condition */
        $result = ($management->get())($this->request(['limit' => 1]));
        $this->assertCount(1, $result);
    }

    /**
     * Ensures traces can be read from gzipped files.
     */
    public function testGetReadsFromGzippedFiles(): void
    {
        /* Arrange: write trace entries to both plain and gzipped files. */
        $dir = $this->createTraceDir();
        $this->writeTrace($dir . '/app-2024.jsonl', [
            ['traceId' => 't1', 'name' => 'plain', 'status' => 'OK', 'parentSpanId' => '0000000000000000', 'extra' => ['service' => ['service.namespace' => 'ns']]]
        ]);

        $this->writeGzTrace($dir . '/app-2023.jsonl.gz', [
            ['traceId' => 't2', 'name' => 'gzipped', 'status' => 'OK', 'parentSpanId' => '0000000000000000', 'extra' => ['service' => ['service.namespace' => 'ns']]]
        ]);

        $management = new TraceManagement($this->config('app'), $dir);
        $request = $this->request(['search' => 'gzipped']);

        /* Act: execute the trace query handler. */
        $result = ($management->get())($request);

        /* Assert: verify the gzipped trace is returned. */
        $this->assertCount(1, $result);
        $this->assertSame('gzipped', $result[0]['name']);
    }

    /**
     * Ensures unreadable gzipped trace files are handled gracefully.
     */
    public function testIterateLinesSkipsUnreadableGzFile(): void
    {
        /* Arrange: create an unreadable gzipped trace file. */
        $dir = $this->createTraceDir();
        $path = $dir . '/app-2024.jsonl.gz';
        file_put_contents($path, gzencode('{"traceId":"t1","name":"test"}'));
        chmod($path, 0000);

        $management = new TraceManagement($this->config('app'), $dir);

        /* Act: invoke iterateLines via reflection. */
        $lines = $this->invokeIterateLines($management, $path);

        /* Assert: no lines are yielded. */
        $this->assertSame([], $lines);
    }

    /**
     * Ensures blank lines are yielded from gzipped traces.
     */
    public function testIterateLinesYieldsBlankLineFromGz(): void
    {
        /* Arrange: write a gz trace containing a blank line and a value. */
        $dir = $this->createTraceDir();
        $path = $dir . '/app-2024.jsonl.gz';
        file_put_contents($path, gzencode("\n{\"traceId\":\"t1\",\"name\":\"test\"}\n"));

        $management = new TraceManagement($this->config('app'), $dir);

        /* Act: invoke iterateLines via reflection. */
        $lines = $this->invokeIterateLines($management, $path);

        /* Assert: the blank line is yielded as empty string. */
        $this->assertSame(['', '{"traceId":"t1","name":"test"}'], $lines);
    }

    /**
     * Ensures gzgets returning false stops iteration.
     *
     * @runInSeparateProcess
     */
    public function testIterateLinesStopsWhenGzGetsFalse(): void
    {
        $GLOBALS['__test_force_gzgets_false'] = true;

        /* Arrange: create a gz path (content ignored by overrides). */
        $dir = $this->createTraceDir();
        $path = $dir . '/app-2024.jsonl.gz';
        file_put_contents($path, 'ignored');

        $management = new TraceManagement($this->config('app'), $dir);

        /* Act: invoke iterateLines via reflection. */
        $lines = $this->invokeIterateLines($management, $path);

        unset($GLOBALS['__test_force_gzgets_false']);

        /* Assert: no lines are yielded when gzgets returns false. */
        $this->assertSame([], $lines);
    }

    /**
     * Ensures unreadable plain trace files yield no lines.
     */
    public function testIterateLinesSkipsUnreadablePlainFile(): void
    {
        /* Arrange: create an unreadable plain trace file. */
        $dir = $this->createTraceDir();
        $path = $dir . '/app-2024.jsonl';
        file_put_contents($path, '{"traceId":"t1","name":"test"}');
        chmod($path, 0000);

        $management = new TraceManagement($this->config('app'), $dir);

        /* Act: invoke iterateLines via reflection. */
        $lines = $this->invokeIterateLines($management, $path);

        /* Assert: no lines are yielded. */
        $this->assertSame([], $lines);
    }

    private function createTraceDir(): string
    {
        $dir = sys_get_temp_dir() . '/trace_' . uniqid();
        mkdir($dir, 0777, true);
        return $dir;
    }

    private function writeTrace(string $path, array $rows): void
    {
        $lines = [];
        foreach ($rows as $row) {
            $lines[] = json_encode($row, JSON_THROW_ON_ERROR);
        }
        file_put_contents($path, implode("\n", $lines));
    }

    private function writeGzTrace(string $path, array $rows): void
    {
        $lines = [];
        foreach ($rows as $row) {
            $lines[] = json_encode($row, JSON_THROW_ON_ERROR);
        }
        $content = implode("\n", $lines);
        file_put_contents($path, gzencode($content));
    }

    private function config(string $name): AppConfig
    {
        return new class ($name) extends AppConfig {
            public function __construct(private readonly string $value)
            {
                $this->develop = true;
                $this->name = $this->value;
                $this->managementEndpoint = '/management';
            }
        };
    }

    private function request(array $params): ServerRequestInterface
    {
        $request = $this->createMock(ServerRequestInterface::class);
        $request->method('getQueryParams')->willReturn($params);
        return $request;
    }

    private function invokeIterateLines(TraceManagement $management, string $path): array
    {
        $method = new \ReflectionMethod(TraceManagement::class, 'iterateLines');
        $method->setAccessible(true);
        $generator = $method->invoke($management, $path);
        if ($generator === null) {
            return [];
        }
        return iterator_to_array($generator, false);
    }
}
