<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use Psr\Http\Message\ServerRequestInterface;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Infrastructure\Management\Trace\TraceManagement;

/**
 * Unit tests for {@see TraceManagement}.
 */
final class TraceManagementUnitTest extends TestCase
{
    /**
     * Ensures traces can be filtered by trace identifier.
     */
    public function testGetFiltersByTraceId(): void
    {
        /* Arrange: write trace entries and prepare a filtered request. */
        $dir = $this->createTraceDir();
        $this->writeTrace($dir . '/app-2024.jsonl', [
            ['traceId' => 't1', 'name' => 'root', 'status' => 'OK', 'parentSpanId' => '0000000000000000', 'extra' => ['service' => ['service.namespace' => 'ns']]],
            ['traceId' => 't2', 'name' => 'child', 'status' => 'OK', 'parentSpanId' => '0000000000000000', 'extra' => ['service' => ['service.namespace' => 'ns']]]
        ]);

        $management = new TraceManagement($this->config('app'), $dir);
        $request = $this->request(['trace-id' => 't1']);

        /* Act: execute the trace query handler. */
        $result = ($management->get())($request);

        /* Assert: verify only the matching trace is returned. */
        $this->assertCount(1, $result);
        $this->assertSame('t1', $result[0]['traceId']);
        $this->assertNull($management->set());
        $this->assertSame('trace', $management->name());

    }

    /**
     * Ensures unfiltered queries return only root spans.
     */
    public function testGetWithoutFiltersReturnsRootSpans(): void
    {
        /* Arrange: write trace entries with root and child spans. */
        $dir = $this->createTraceDir();
        $this->writeTrace($dir . '/app-2024.jsonl', [
            ['traceId' => 't1', 'name' => 'root', 'status' => 'OK', 'parentSpanId' => '0000000000000000', 'extra' => ['service' => ['service.namespace' => 'ns']]],
            ['traceId' => 't1', 'name' => 'child', 'status' => 'OK', 'parentSpanId' => 'span', 'extra' => ['service' => ['service.namespace' => 'ns']]]
        ]);

        $management = new TraceManagement($this->config('app'), $dir);
        $request = $this->request([]);

        /* Act: execute the trace query handler without filters. */
        $result = ($management->get())($request);

        /* Assert: verify only root spans are returned. */
        $this->assertCount(1, $result);
        $this->assertSame('root', $result[0]['name']);
    }

    /**
     * Ensures invalid trace lines are ignored during parsing.
     */
    public function testGetSkipsInvalidLines(): void
    {
        /* Arrange: create a trace file containing invalid lines. */
        $dir = $this->createTraceDir();
        file_put_contents($dir . '/app-2024.jsonl', "\ninvalid\n");

        $management = new TraceManagement($this->config('app'), $dir);

        /* Act: execute the trace query handler. */
        $result = ($management->get())($this->request([]));

        /* Assert: verify no traces are returned. */
        $this->assertSame([], $result);
    }

    private function createTraceDir(): string
    {
        $dir = sys_get_temp_dir() . '/trace_' . uniqid();
        mkdir($dir, 0777, true);
        return $dir;
    }

    private function writeTrace(string $path, array $rows): void
    {
        $lines = [];
        foreach ($rows as $row) {
            $lines[] = json_encode($row, JSON_THROW_ON_ERROR);
        }
        file_put_contents($path, implode("\n", $lines));
    }

    private function config(string $name): AppConfig
    {
        return new class ($name) extends AppConfig {
            public function __construct(private readonly string $value)
            {
                $this->develop = true;
                $this->name = $this->value;
                $this->managementEndpoint = '/management';
            }
        };
    }

    private function request(array $params): ServerRequestInterface
    {
        $request = $this->createMock(ServerRequestInterface::class);
        $request->method('getQueryParams')->willReturn($params);
        return $request;
    }
}
