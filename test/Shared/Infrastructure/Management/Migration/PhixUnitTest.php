<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use Symfony\Component\Console\Output\BufferedOutput;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Infrastructure\Management\Migration\Phix;

/**
 * Unit tests for {@see Phix}.
 */
final class PhixUnitTest extends TestCase
{
    /**
     * Ensures the migration provider name is stable.
     */
    public function testName(): void
    {
        /* Arrange: create a Phix instance with a fake manager. */
        $phix = new TestablePhix($this->config('mysql:host=localhost;dbname=db'), $this->managerWithMigrations(true, true, ''));

        /* Act: read the provider name. */
        $name = $phix->name();

        /* Assert: verify the provider name. */
        $this->assertSame('database-schema', $name);
    }

    /**
     * Ensures status results include migration readiness.
     */
    public function testStatusUsesDumpStatus(): void
    {
        /* Arrange: build a manager with ready migrations. */
        $manager = $this->managerWithMigrations(true, true, 'output');
        $phix = new TestablePhix($this->config('mysql:host=localhost;dbname=db'), $manager);

        /* Act: request the migration status. */
        $result = $phix->status();

        /* Assert: verify the migration status payload. */
        $this->assertSame(['status' => ['Init[1]' => 'Ready']], $result);
    }

    /**
     * Ensures status reports pending migrations.
     */
    public function testStatusWithPendingMigration(): void
    {
        /* Arrange: build a manager with pending migrations. */
        $manager = $this->managerWithMigrations(false, true, 'output');
        $phix = new TestablePhix($this->config('mysql:host=localhost;dbname=db'), $manager);

        /* Act: request the migration status. */
        $result = $phix->status();

        /* Assert: verify the pending status payload. */
        $this->assertSame(['status' => ['Init[1]' => 'Pending']], $result);
    }

    /**
     * Ensures migration results reflect newly applied changes.
     */
    public function testMigrateDiff(): void
    {
        /* Arrange: create a manager with a pending migration. */
        $manager = $this->managerWithMigrations(false, true, 'output');
        $phix = new TestablePhix($this->config('mysql:host=localhost;dbname=db'), $manager);

        /* Act: execute the migration handler. */
        $result = $phix->migrate();

        /* Assert: verify the migration status and output detail. */
        $this->assertSame('Migrated', $result['status']['Init[1]']);
        $this->assertSame('output', $result['detail']);
    }

    /**
     * Ensures ready migrations remain marked as ready.
     */
    public function testMigrateKeepsReadyStatus(): void
    {
        /* Arrange: create a manager with a ready migration. */
        $manager = $this->managerWithMigrations(true, false, 'output');
        $phix = new TestablePhix($this->config('mysql:host=localhost;dbname=db'), $manager);

        /* Act: execute the migration handler. */
        $result = $phix->migrate();

        /* Assert: verify the migration remains ready. */
        $this->assertSame('Ready', $result['status']['Init[1]']);
        $this->assertSame('output', $result['detail']);
    }

    /**
     * Ensures failed migrations are flagged appropriately.
     */
    public function testMigrateMarksFailed(): void
    {
        /* Arrange: create a manager that stays pending. */
        $manager = $this->managerWithMigrations(false, false, 'output');
        $phix = new TestablePhix($this->config('mysql:host=localhost;dbname=db'), $manager);

        /* Act: execute the migration handler. */
        $result = $phix->migrate();

        /* Assert: verify the migration failure state. */
        $this->assertSame('Failed', $result['status']['Init[1]']);
        $this->assertSame('output', $result['detail']);
    }

    /**
     * Ensures empty detail output when output is not buffered.
     */
    public function testMigrateHandlesNonBufferedOutput(): void
    {
        /* Arrange: use a manager with a non-buffered output instance. */
        $output = $this->createMock(\Symfony\Component\Console\Output\OutputInterface::class);
        $manager = $this->managerWithMigrationsAndOutput(true, true, $output);
        $phix = new TestablePhix($this->config('mysql:host=localhost;dbname=db'), $manager);

        /* Act: execute the migration handler. */
        $result = $phix->migrate();

        /* Assert: verify detail is empty for non-buffered output. */
        $this->assertSame('', $result['detail']);
    }

    /**
     * Ensures DSN parsing includes credentials when provided.
     */
    public function testParseWithCredentials(): void
    {
        /* Arrange: provide environment credentials and build the parser. */
        $_ENV['DATABASE_USERNAME'] = 'user';
        $_ENV['DATABASE_PASSWORD'] = 'pass';

        $phix = new TestablePhix($this->config('mysql:host=localhost;port=3306;dbname=test'), $this->managerWithMigrations(true, true, ''));

        /* Act: parse the database DSN. */
        $data = $phix->parse();

        /* Assert: verify adapter, host, and credentials fields. */
        $this->assertSame('mysql', $data['adapter']);
        $this->assertSame('localhost', $data['host']);
        $this->assertSame('3306', $data['port']);
        $this->assertSame('test', $data['name']);
        $this->assertSame('user', $data['user']);
        $this->assertSame('pass', $data['pass']);
    }

    /**
     * Ensures DSN parsing omits credentials when env vars are absent.
     */
    public function testParseWithoutCredentials(): void
    {
        /* Arrange: clear environment credentials. */
        $previousUser = $_ENV['DATABASE_USERNAME'] ?? null;
        $previousPass = $_ENV['DATABASE_PASSWORD'] ?? null;
        $hadUser = array_key_exists('DATABASE_USERNAME', $_ENV);
        $hadPass = array_key_exists('DATABASE_PASSWORD', $_ENV);
        unset($_ENV['DATABASE_USERNAME'], $_ENV['DATABASE_PASSWORD']);

        $phix = new TestablePhix($this->config('mysql:host=localhost;dbname=test'), $this->managerWithMigrations(true, true, ''));

        /* Act: parse the database DSN. */
        $data = $phix->parse();

        /* Assert: verify credentials are not included. */
        $this->assertSame('mysql', $data['adapter']);
        $this->assertSame('localhost', $data['host']);
        $this->assertSame('test', $data['name']);
        $this->assertArrayNotHasKey('user', $data);
        $this->assertArrayNotHasKey('pass', $data);

        /* Cleanup: restore environment credentials. */
        if ($hadUser) {
            $_ENV['DATABASE_USERNAME'] = $previousUser;
        }
        if ($hadPass) {
            $_ENV['DATABASE_PASSWORD'] = $previousPass;
        }
    }

    /**
     * Ensures an invalid DSN raises an exception.
     */
    public function testParseThrowsOnInvalidDsn(): void
    {
        /* Arrange: create a parser with an invalid DSN. */
        $phix = new TestablePhix($this->config('invalid_dsn'), $this->managerWithMigrations(true, true, ''));

        /* Act: attempt to parse the invalid DSN. */
        $this->expectException(InvalidArgumentException::class);
        $phix->parse();

        /* Assert: verify an invalid argument exception is thrown. */
    }

    private function config(string $dsn): AppConfig
    {
        return new class ($dsn) extends AppConfig {
            public function __construct(private readonly string $dsn)
            {
                $this->develop = true;
                $this->name = 'app';
                $this->managementEndpoint = '/management';
            }

            public function get(string $name, mixed $def = null): mixed
            {
                if ($name === 'database.url') {
                    return $this->dsn;
                }
                if ($name === 'database.username') {
                    return 'user';
                }
                if ($name === 'database.password') {
                    return 'pass';
                }
                return $def;
            }
        };
    }

    private function managerWithMigrations(bool $beforeUp, bool $afterUp, string $output): \Phinx\Migration\Manager
    {
        $migrations = [
            '1' => new FakeMigration('Init', $beforeUp)
        ];
        $manager = $this->getMockBuilder(\Phinx\Migration\Manager::class)
            ->disableOriginalConstructor()
            ->getMock();
        $manager->method('getMigrations')->willReturnCallback(function () use (&$migrations) {
            return $migrations;
        });
        $manager->method('getOutput')->willReturn((function () use ($output) {
            $buffer = new BufferedOutput();
            $buffer->write($output);
            return $buffer;
        })());
        $manager->method('migrate')->willReturnCallback(function () use (&$migrations, $afterUp) {
            $migrations = [
                '1' => new FakeMigration('Init', $afterUp)
            ];
        });
        return $manager;
    }

    private function managerWithMigrationsAndOutput(
        bool $beforeUp,
        bool $afterUp,
        \Symfony\Component\Console\Output\OutputInterface $output
    ): \Phinx\Migration\Manager {
        $migrations = [
            '1' => new FakeMigration('Init', $beforeUp)
        ];
        $manager = $this->getMockBuilder(\Phinx\Migration\Manager::class)
            ->disableOriginalConstructor()
            ->getMock();
        $manager->method('getMigrations')->willReturnCallback(function () use (&$migrations) {
            return $migrations;
        });
        $manager->method('getOutput')->willReturn($output);
        $manager->method('migrate')->willReturnCallback(function () use (&$migrations, $afterUp) {
            $migrations = [
                '1' => new FakeMigration('Init', $afterUp)
            ];
        });
        return $manager;
    }
}

/**
 * Test double for injecting a custom Phinx manager.
 */
final class TestablePhix extends Phix
{
    /**
     * Creates a testable Phix instance with a prebuilt manager.
     */
    public function __construct(
        AppConfig $config,
        /** @var \Phinx\Migration\Manager Fake manager instance. */
        private readonly \Phinx\Migration\Manager $manager
    ) {
        parent::__construct($config);
    }

    /**
     * Exposes the protected parse operation for tests.
     */
    public function parse(): array
    {
        return parent::parse();
    }

    /**
     * Returns the injected migration manager.
     */
    protected function build(): \Phinx\Migration\Manager
    {
        return $this->manager;
    }
}

/**
 * Minimal fake migration for Phinx tests.
 */
final class FakeMigration
{
    /**
     * Creates a fake migration instance.
     */
    public function __construct(
        /** @var string Migration name. */
        private readonly string $name,
        /** @var bool Whether the migration is marked as ready. */
        private readonly bool $up
    ) {
    }

    /**
     * Returns the migration name.
     */
    public function getName(): string
    {
        return $this->name;
    }

    /**
     * Indicates whether the migration is ready to run.
     */
    public function isMigratingUp(): bool
    {
        return $this->up;
    }
}
