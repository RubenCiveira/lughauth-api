<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use Psr\Container\ContainerInterface;
use Psr\Log\LoggerInterface;
use Civi\Lughauth\Shared\Infrastructure\Management\Migration\MigrationManagement;
use Civi\Lughauth\Shared\Infrastructure\Management\Migration\MigrationInterface;
use Civi\Lughauth\Shared\Infrastructure\Management\Migration\Phix;

/**
 * Unit tests for {@see MigrationManagement}.
 */
final class MigrationManagementUnitTest extends TestCase
{
    /**
     * Ensures the status handler returns provider status data.
     */
    public function testGetReturnsStatus(): void
    {
        /* Arrange: register a provider and management handler. */
        $provider = $this->createProvider('db', ['status' => 'ok']);
        $container = $this->createMock(ContainerInterface::class);
        $container->method('get')->with(Phix::class)->willReturn($provider);
        $logger = $this->createMock(LoggerInterface::class);

        $management = new MigrationManagement($container, $logger);

        /* Act: execute the status handler. */
        $result = ($management->get())();

        /* Assert: verify the status payload. */
        $this->assertSame(['db' => ['status' => 'ok']], $result);
    }

    /**
     * Ensures the handler name is exposed.
     */
    public function testName(): void
    {
        /* Arrange: create a management handler. */
        $provider = $this->createProvider('db', ['status' => 'ok']);
        $container = $this->createMock(ContainerInterface::class);
        $container->method('get')->with(Phix::class)->willReturn($provider);
        $logger = $this->createMock(LoggerInterface::class);

        $management = new MigrationManagement($container, $logger);

        /* Act: read the name. */
        $name = $management->name();

        /* Assert: verify the endpoint name. */
        $this->assertSame('migration', $name);
    }

    /**
     * Ensures additional providers are included in status.
     */
    public function testGetIncludesAdditionalProvider(): void
    {
        /* Arrange: register two providers. */
        $primary = $this->createProvider('db', ['status' => 'ok']);
        $secondary = $this->createProvider('cache', ['status' => 'warm']);
        $container = $this->createMock(ContainerInterface::class);
        $container->method('get')->with(Phix::class)->willReturn($primary);
        $logger = $this->createMock(LoggerInterface::class);

        $management = new MigrationManagement($container, $logger);
        $management->addProvider($secondary);

        /* Act: execute the status handler. */
        $result = ($management->get())();

        /* Assert: verify both providers are returned. */
        $this->assertSame(
            ['db' => ['status' => 'ok'], 'cache' => ['status' => 'warm']],
            $result
        );
    }

    /**
     * Ensures failures are captured and logged during migrations.
     */
    public function testSetHandlesFailure(): void
    {
        /* Arrange: create a provider that throws and a logger expectation. */
        $provider = $this->createProvider('db', ['status' => 'ok'], true);
        $container = $this->createMock(ContainerInterface::class);
        $container->method('get')->with(Phix::class)->willReturn($provider);
        $logger = $this->createMock(LoggerInterface::class);
        $logger->expects($this->once())->method('critical');

        $management = new MigrationManagement($container, $logger);

        /* Act: execute the migration handler. */
        $result = ($management->set())();

        /* Assert: verify the failure is returned in the response. */
        $this->assertArrayHasKey('db', $result);
        $this->assertStringContainsString('boom', $result['db']);
    }

    /**
     * Ensures migrations return data when no failures occur.
     */
    public function testSetReturnsSuccessPayload(): void
    {
        /* Arrange: create a successful provider and logger expectation. */
        $provider = $this->createProvider('db', ['status' => 'ok']);
        $container = $this->createMock(ContainerInterface::class);
        $container->method('get')->with(Phix::class)->willReturn($provider);
        $logger = $this->createMock(LoggerInterface::class);
        $logger->expects($this->never())->method('critical');

        $management = new MigrationManagement($container, $logger);

        /* Act: execute the migration handler. */
        $result = ($management->set())();

        /* Assert: verify the migration response payload. */
        $this->assertSame(['db' => ['status' => 'ok']], $result);
    }

    private function createProvider(string $name, array $status, bool $fail = false): MigrationInterface
    {
        return new class ($name, $status, $fail) implements MigrationInterface {
            public function __construct(private readonly string $name, private readonly array $status, private readonly bool $fail)
            {
            }

            public function name(): string
            {
                return $this->name;
            }

            public function migrate(): array
            {
                if ($this->fail) {
                    throw new RuntimeException('boom');
                }
                return ['status' => 'ok'];
            }

            public function status(): array
            {
                return $this->status;
            }
        };
    }
}
