<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use Psr\Container\ContainerInterface;
use Slim\Middleware\ErrorMiddleware;
use Slim\Routing\RouteCollectorProxy;
use Civi\Lughauth\Shared\Infrastructure\AggregatedMicroPlugin;
use Civi\Lughauth\Shared\Infrastructure\MicroPlugin;
use Civi\Lughauth\Shared\Infrastructure\StartupProcessor;
use Civi\Lughauth\Shared\Infrastructure\Scheduler\SchedulerManager;
use Civi\Lughauth\Shared\Event\EventListenersRegistrarInterface;

final class AggregatedMicroPluginUnitTest extends TestCase
{
    public function testDelegatesToAllPlugins(): void
    {
        $pluginA = new class () extends MicroPlugin {
            public int $routes = 0;
            public int $events = 0;
            public int $schedulers = 0;
            public int $errors = 0;
            public int $startup = 0;
            public function registerRoutes(RouteCollectorProxy $app)
            {
                $this->routes++;
            }
            public function registerEvents(EventListenersRegistrarInterface $bus)
            {
                $this->events++;
            }
            public function registerSchedulers(SchedulerManager $bus)
            {
                $this->schedulers++;
            }
            public function registerErrorHandler(ErrorMiddleware $errorHandler)
            {
                $this->errors++;
            }
            public function registerStartup(StartupProcessor $processor): void
            {
                $this->startup++;
            }
        };

        $pluginB = new class () extends MicroPlugin {
            public int $routes = 0;
            public int $events = 0;
            public int $schedulers = 0;
            public int $errors = 0;
            public int $startup = 0;
            public function registerRoutes(RouteCollectorProxy $app)
            {
                $this->routes++;
            }
            public function registerEvents(EventListenersRegistrarInterface $bus)
            {
                $this->events++;
            }
            public function registerSchedulers(SchedulerManager $bus)
            {
                $this->schedulers++;
            }
            public function registerErrorHandler(ErrorMiddleware $errorHandler)
            {
                $this->errors++;
            }
            public function registerStartup(StartupProcessor $processor): void
            {
                $this->startup++;
            }
        };

        $aggregated = new class ([$pluginA, $pluginB]) extends AggregatedMicroPlugin {
        };

        $routeProxy = $this->createMock(RouteCollectorProxy::class);
        $bus = $this->createMock(EventListenersRegistrarInterface::class);
        $scheduler = $this->createMock(SchedulerManager::class);
        $error = $this->createMock(ErrorMiddleware::class);
        $startup = $this->createMock(StartupProcessor::class);

        $aggregated->registerRoutes($routeProxy);
        $aggregated->registerEvents($bus);
        $aggregated->registerSchedulers($scheduler);
        $aggregated->registerErrorHandler($error);
        $aggregated->registerStartup($startup);

        $this->assertSame(1, $pluginA->routes);
        $this->assertSame(1, $pluginA->events);
        $this->assertSame(1, $pluginA->schedulers);
        $this->assertSame(1, $pluginA->errors);
        $this->assertSame(1, $pluginA->startup);
        $this->assertSame(1, $pluginB->routes);
        $this->assertSame(1, $pluginB->events);
        $this->assertSame(1, $pluginB->schedulers);
        $this->assertSame(1, $pluginB->errors);
        $this->assertSame(1, $pluginB->startup);
    }

    public function testAggregatesManagementInterfacesInReverseOrder(): void
    {
        $pluginA = new class () extends MicroPlugin {
            public function getManagementsInterfaces(ContainerInterface $container): array
            {
                return ['a'];
            }
        };
        $pluginB = new class () extends MicroPlugin {
            public function getManagementsInterfaces(ContainerInterface $container): array
            {
                return ['b'];
            }
        };

        $aggregated = new class ([$pluginA, $pluginB]) extends AggregatedMicroPlugin {
        };
        $container = $this->createMock(ContainerInterface::class);

        $result = $aggregated->getManagementsInterfaces($container);

        $this->assertSame(['b', 'a'], $result);
    }

    public function testRegisterServiceDefinitionChainsDefinitions(): void
    {
        $pluginA = new class () extends MicroPlugin {
            public function registerServiceDefinition(array $def): array
            {
                $def['a'] = 1;
                return $def;
            }
        };
        $pluginB = new class () extends MicroPlugin {
            public function registerServiceDefinition(array $def): array
            {
                $def['b'] = 2;
                return $def;
            }
        };

        $aggregated = new class ([$pluginA, $pluginB]) extends AggregatedMicroPlugin {
        };

        $result = $aggregated->registerServiceDefinition(['base' => 0]);

        $this->assertSame(['base' => 0, 'a' => 1, 'b' => 2], $result);
    }
}
