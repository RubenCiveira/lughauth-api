<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use Civi\Lughauth\Shared\Infrastructure\Audit\AuditContext;
use Civi\Lughauth\Shared\Infrastructure\Audit\AuditablePdoWrapper;
use Civi\Lughauth\Shared\Infrastructure\Audit\AuditablePdoStatement;

final class AuditablePdoStatementUnitTest extends TestCase
{
    public function testExecuteRecordsInsertAndUpdateChanges(): void
    {
        $context = new AuditContext();
        $pdo = $this->createWrapper($context);

        $pdo->exec('CREATE TABLE items (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT)');

        $context->setActionId('action-1');
        $stmt = $pdo->prepare('INSERT INTO items (name) VALUES (:name)');
        $this->assertInstanceOf(AuditablePdoStatement::class, $stmt);
        $stmt->execute(['name' => 'first']);

        $changes = $context->consumeChanges();
        $this->assertCount(1, $changes);
        $this->assertSame('insert', $changes[0]->changeType);

        $context->setActionId('action-2');
        $stmt = $pdo->prepare('UPDATE items SET name = :name WHERE id = :id');
        $stmt->bindValue('name', 'second');
        $stmt->bindValue('id', 1, PDO::PARAM_INT);
        $stmt->execute();

        $changes = $context->consumeChanges();
        $this->assertCount(1, $changes);
        $this->assertSame('update', $changes[0]->changeType);
        $this->assertSame('Items', $changes[0]->targetType);
        $this->assertSame('1', $changes[0]->targetId);
    }

    public function testExecuteSkipsWhenNoActionOrNonWrite(): void
    {
        $context = new AuditContext();
        $pdo = $this->createWrapper($context);
        $pdo->exec('CREATE TABLE items (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT)');
        $pdo->exec("INSERT INTO items (name) VALUES ('demo')");

        $stmt = $pdo->prepare('SELECT * FROM items');
        $stmt->execute();
        $this->assertSame([], $context->consumeChanges());

        $context->setActionId('action-3');
        $stmt = $pdo->prepare('SELECT * FROM items');
        $stmt->execute();
        $this->assertSame([], $context->consumeChanges());
    }

    public function testExtractTableParsesSql(): void
    {
        $context = new AuditContext();
        $pdo = $this->createWrapper($context);
        $pdo->exec('CREATE TABLE items (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT)');

        $stmt = $pdo->prepare('UPDATE items SET name = :name WHERE id = :id');
        $method = new ReflectionMethod($stmt, 'extractTable');
        $method->setAccessible(true);

        $this->assertSame('items', $method->invoke($stmt, 'UPDATE items SET name = :name WHERE id = :id'));
        $this->assertNull($method->invoke($stmt, 'SELECT * FROM items'));
    }

    public function testFindPrimaryKeyColumnForDrivers(): void
    {
        $stmt = $this->createStatementWithPdo(new FakePdo('mysql', 'id'));
        $method = new ReflectionMethod($stmt, 'findPrimaryKeyColumn');
        $method->setAccessible(true);
        $result = $method->invoke($stmt, 'users', 'mysql');
        $this->assertSame('id', $result);
        $this->assertStringContainsString('INFORMATION_SCHEMA.COLUMNS', $stmt->getPdo()->preparedSql[0]);
        $this->assertSame('users', $stmt->getPdo()->statements[0]->executedParams[0]['table']);

        $stmt = $this->createStatementWithPdo(new FakePdo('pgsql', 'pk'));
        $method = new ReflectionMethod($stmt, 'findPrimaryKeyColumn');
        $method->setAccessible(true);
        $result = $method->invoke($stmt, 'accounts', 'pgsql');
        $this->assertSame('pk', $result);
        $this->assertStringContainsString('pg_index', $stmt->getPdo()->preparedSql[0]);

        $stmt = $this->createStatementWithPdo(new FakePdo('sqlsrv', 'col'));
        $method = new ReflectionMethod($stmt, 'findPrimaryKeyColumn');
        $method->setAccessible(true);
        $result = $method->invoke($stmt, 'orders', 'sqlsrv');
        $this->assertSame('col', $result);
        $this->assertStringContainsString('TABLE_CONSTRAINTS', $stmt->getPdo()->preparedSql[0]);
    }

    public function testResolvePrimaryKeyValueUsesDriverLogic(): void
    {
        $pdo = new FakePdo('mysql');
        $pdo->lastInsertIdResult = '10';
        $stmt = $this->createStatementWithPdo($pdo);

        $method = new ReflectionMethod($stmt, 'resolvePrimaryKeyValue');
        $method->setAccessible(true);

        $result = $method->invoke($stmt, 'INSERT', 'id', 'mysql');
        $this->assertSame('10', $result);
        $this->assertSame(1, $pdo->lastInsertIdCalls);

        $pdo = new FakePdo('pgsql');
        $pdo->lastInsertIdResult = '22';
        $stmt = $this->createStatementWithPdo($pdo);
        $method = new ReflectionMethod($stmt, 'resolvePrimaryKeyValue');
        $method->setAccessible(true);
        $this->assertSame('22', $method->invoke($stmt, 'INSERT', 'id', 'pgsql'));

        $pdo = new FakePdo('sqlsrv');
        $pdo->queryFetchColumnResult = '33';
        $stmt = $this->createStatementWithPdo($pdo);
        $method = new ReflectionMethod($stmt, 'resolvePrimaryKeyValue');
        $method->setAccessible(true);
        $this->assertSame('33', $method->invoke($stmt, 'INSERT', 'id', 'sqlsrv'));
        $this->assertSame('SELECT SCOPE_IDENTITY()', $pdo->preparedSql[0]);
    }

    public function testBindParamStoresBoundValue(): void
    {
        $context = new AuditContext();
        $pdo = $this->createWrapper($context);
        $pdo->exec('CREATE TABLE items (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT)');

        $stmt = $pdo->prepare('UPDATE items SET name = :name WHERE id = :id');
        $id = 1;
        $stmt->bindParam('id', $id, PDO::PARAM_INT, 0);

        $property = new ReflectionProperty($stmt, 'boundParams');
        $property->setAccessible(true);
        $bound = $property->getValue($stmt);

        $this->assertSame(1, $bound['id']);
    }

    public function testExecuteReturnsFalseWhenParentFails(): void
    {
        $context = new AuditContext();
        $context->setActionId('action-fail');
        $pdo = $this->createWrapper($context, PDO::ERRMODE_SILENT);
        $pdo->exec('CREATE TABLE items (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL)');

        $stmt = $pdo->prepare('INSERT INTO items (name) VALUES (:name)');
        $result = $stmt->execute(['name' => null]);

        $this->assertFalse($result);
        $this->assertSame([], $context->consumeChanges());
    }

    public function testExecuteSkipsWhenNoPrimaryKey(): void
    {
        $context = new AuditContext();
        $pdo = $this->createWrapper($context);
        $pdo->exec('CREATE TABLE no_pk (name TEXT)');

        $context->setActionId('action-4');
        $stmt = $pdo->prepare('INSERT INTO no_pk (name) VALUES (:name)');
        $this->assertTrue($stmt->execute(['name' => 'demo']));
        $this->assertSame([], $context->consumeChanges());
    }

    public function testExecuteSkipsWhenPrimaryKeyMissing(): void
    {
        $context = new AuditContext();
        $pdo = $this->createWrapper($context);
        $pdo->exec('CREATE TABLE items (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT)');
        $pdo->exec("INSERT INTO items (name) VALUES ('demo')");

        $context->setActionId('action-5');
        $stmt = $pdo->prepare('UPDATE items SET name = :name');
        $this->assertTrue($stmt->execute(['name' => 'changed']));

        $this->assertSame([], $context->consumeChanges());
    }

    public function testExecuteSkipsWhenRowMissing(): void
    {
        $context = new AuditContext();
        $pdo = $this->createWrapper($context);
        $pdo->exec('CREATE TABLE items (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT)');
        $pdo->exec("INSERT INTO items (name) VALUES ('demo')");

        $context->setActionId('action-6');
        $stmt = $pdo->prepare('UPDATE items SET name = :name WHERE id = :id');
        $stmt->bindValue('name', 'changed');
        $stmt->bindValue('id', 999, PDO::PARAM_INT);
        $this->assertTrue($stmt->execute());

        $this->assertSame([], $context->consumeChanges());
    }

    private function createWrapper(AuditContext $context, int $errorMode = PDO::ERRMODE_EXCEPTION): AuditablePdoWrapper
    {
        $wrapper = new AuditablePdoWrapper(
            $context,
            'sqlite::memory:',
            '',
            '',
            [PDO::ATTR_ERRMODE => $errorMode]
        );
        $wrapper->setAttribute(PDO::ATTR_ERRMODE, $errorMode);
        return $wrapper;
    }

    private function createStatementWithPdo(FakePdo $pdo): AuditablePdoStatementProbe
    {
        return new AuditablePdoStatementProbe(new AuditContext(), $pdo);
    }
}

final class FakePdo extends PDO
{
    public array $preparedSql = [];
    public array $statements = [];
    public int $lastInsertIdCalls = 0;
    public ?string $lastInsertIdResult = null;
    public ?string $queryFetchColumnResult = null;

    public function __construct(private readonly string $driver, ?string $fetchColumnResult = null)
    {
        parent::__construct('sqlite::memory:');
        $this->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
        $this->queryFetchColumnResult = $fetchColumnResult;
    }

    public function getAttribute($attribute): mixed
    {
        if ($attribute === PDO::ATTR_DRIVER_NAME) {
            return $this->driver;
        }
        return parent::getAttribute($attribute);
    }

    public function prepare(string $query, array $options = []): PDOStatement|false
    {
        $this->preparedSql[] = $query;
        $stmt = FakeStatement::create($this->queryFetchColumnResult);
        $this->statements[] = $stmt;
        return $stmt;
    }

    public function query(string $query, ?int $fetchMode = null, mixed ...$fetchModeArgs): PDOStatement|false
    {
        $this->preparedSql[] = $query;
        $stmt = FakeStatement::create($this->queryFetchColumnResult);
        $this->statements[] = $stmt;
        return $stmt;
    }

    public function lastInsertId($name = null): string
    {
        $this->lastInsertIdCalls++;
        return $this->lastInsertIdResult ?? '0';
    }
}

final class FakeStatement extends PDOStatement
{
    public array $executedParams = [];
    private ?string $fetchColumnResult = null;

    public static function create(?string $fetchColumnResult = null): self
    {
        $ref = new ReflectionClass(self::class);
        /** @var self $instance */
        $instance = $ref->newInstanceWithoutConstructor();
        $instance->fetchColumnResult = $fetchColumnResult;
        return $instance;
    }

    public function execute(?array $params = null): bool
    {
        $this->executedParams[] = $params ?? [];
        return true;
    }

    public function fetchColumn(int $column = 0): mixed
    {
        return $this->fetchColumnResult;
    }
}

final class AuditablePdoStatementProbe extends AuditablePdoStatement
{
    public function __construct(AuditContext $context, PDO $pdo)
    {
        parent::__construct($context, $pdo);
    }

    public function getPdo(): FakePdo
    {
        $ref = new ReflectionClass(AuditablePdoStatement::class);
        $prop = $ref->getProperty('pdo');
        $prop->setAccessible(true);
        return $prop->getValue($this);
    }
}
