<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\UriInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Context;
use Civi\Lughauth\Shared\Security\Connection;
use Civi\Lughauth\Shared\Security\Identity;
use Civi\Lughauth\Shared\Infrastructure\Audit\AuditChange;
use Civi\Lughauth\Shared\Infrastructure\Audit\AuditContext;
use Civi\Lughauth\Shared\Infrastructure\Audit\AuditMiddleware;

final class AuditMiddlewareUnitTest extends TestCase
{
    public function testProcessPersistsAuditActionAndChanges(): void
    {
        $pdo = $this->createSqlite();
        $this->createAuditTables($pdo);

        $auditContext = new AuditContext();
        $auditContext->setActionId('action-1');
        $auditContext->addChange(new AuditChange('action-1', 'User', '1', 'update', ['name' => 'A']));

        $identity = new Identity(false, name: 'user', token: 'token', tenant: 'tenant-1');
        $connection = new Connection(true, new DateTime(), 'app', '/path', '127.0.0.1', 'host', 'en');

        $context = $this->createMock(Context::class);
        $context->method('getIdentity')->willReturn($identity);
        $context->method('getConnection')->willReturn($connection);

        $config = $this->createMock(AppConfig::class);
        $config->method('get')->with('app.audit.retention-weeks', 0)->willReturn(0);

        $middleware = new AuditMiddleware($pdo, $auditContext, $context, $config);

        $request = $this->createRequest('POST', '/path', 'UA');
        $response = $this->createResponse(200);
        $handler = $this->createHandler($response);

        $result = $middleware->process($request, $handler);
        $this->assertSame($response, $result);

        $this->assertSame(1, (int) $pdo->query('SELECT COUNT(*) FROM _audit_action')->fetchColumn());
        $this->assertSame(1, (int) $pdo->query('SELECT COUNT(*) FROM _audit_change')->fetchColumn());
    }

    public function testProcessSkipsWhenNotAuditable(): void
    {
        $pdo = $this->createSqlite();
        $this->createAuditTables($pdo);

        $auditContext = new AuditContext();
        $context = $this->createMock(Context::class);
        $context->method('getIdentity')->willReturn(new Identity(true));
        $context->method('getConnection')->willReturn(new Connection(true, new DateTime(), 'app', '/', '0.0.0.0', 'host', 'en'));

        $config = $this->createMock(AppConfig::class);
        $config->method('get')->with('app.audit.retention-weeks', 0)->willReturn(0);

        $middleware = new AuditMiddleware($pdo, $auditContext, $context, $config);

        $request = $this->createRequest('GET', '/skip', 'UA');
        $response = $this->createResponse(200);
        $handler = $this->createHandler($response);

        $middleware->process($request, $handler);

        $this->assertSame(0, (int) $pdo->query('SELECT COUNT(*) FROM _audit_action')->fetchColumn());
    }

    public function testClearExportsAndDeletesOldData(): void
    {
        $pdo = $this->createSqlite();
        $this->createAuditTables($pdo);

        $pdo->exec("INSERT INTO _audit_action (id, occurred_at, actor_id, actor_type, actor_ip, tenant_id, session_id, client_id, user_agent, request_method, request_path, action_type)
            VALUES ('a1', '2000-01-01 00:00:00', 'user', 'user', '127.0.0.1', 't1', '', 'app', 'UA', 'POST', '/old', 'POST /old')");
        $pdo->exec("INSERT INTO _audit_change (id, action_id, target_type, target_id, change_type, change_order, payload, metadata)
            VALUES ('c1', 'a1', 'User', '1', 'update', 0, '{}', NULL)");

        $config = $this->createMock(AppConfig::class);
        $config->method('get')->with('app.audit.retention-weeks', 0)->willReturn(0);

        $auditContext = new AuditContext();
        $context = $this->createMock(Context::class);
        $context->method('getIdentity')->willReturn(new Identity(true));
        $context->method('getConnection')->willReturn(new Connection(true, new DateTime(), 'app', '/', '0.0.0.0', 'host', 'en'));

        $middleware = new AuditMiddleware($pdo, $auditContext, $context, $config);

        $pdo->exec("INSERT INTO _audit_action (id, occurred_at, actor_id, actor_type, actor_ip, tenant_id, session_id, client_id, user_agent, request_method, request_path, action_type)
            VALUES ('a2', '2000-01-01 00:00:00', 'user', 'user', '127.0.0.1', 't1', '', 'app', 'UA', 'POST', '/old', 'POST /old')");
        $pdo->exec("INSERT INTO _audit_change (id, action_id, target_type, target_id, change_type, change_order, payload, metadata)
            VALUES ('c2', 'a2', 'User', '1', 'update', 0, '{}', NULL)");

        $method = new ReflectionMethod($middleware, 'exportAndDeleteBefore');
        $method->setAccessible(true);
        $method->invoke($middleware, new DateTimeImmutable('2024-01-01 00:00:00'));

        $this->assertSame(0, (int) $pdo->query('SELECT COUNT(*) FROM _audit_action')->fetchColumn());

        $files = glob(__DIR__ . '/../../../../var/audit/audit-*.json.gz');
        $this->assertNotEmpty($files);

        foreach ($files as $file) {
            unlink($file);
        }
    }

    public function testExportAndDeleteBeforeSkipsWhenNoData(): void
    {
        $pdo = $this->createSqlite();
        $this->createAuditTables($pdo);

        $config = $this->createMock(AppConfig::class);
        $config->method('get')->with('app.audit.retention-weeks', 0)->willReturn(0);

        $auditContext = new AuditContext();
        $context = $this->createMock(Context::class);
        $context->method('getIdentity')->willReturn(new Identity(true));
        $context->method('getConnection')->willReturn(new Connection(true, new DateTime(), 'app', '/', '0.0.0.0', 'host', 'en'));

        $middleware = new AuditMiddleware($pdo, $auditContext, $context, $config);

        $method = new ReflectionMethod($middleware, 'exportAndDeleteBefore');
        $method->setAccessible(true);
        $method->invoke($middleware, new DateTimeImmutable('2024-01-01 00:00:00'));

        $this->assertSame(0, (int) $pdo->query('SELECT COUNT(*) FROM _audit_action')->fetchColumn());
    }

    private function createSqlite(): PDO
    {
        $pdo = new PDO('sqlite::memory:');
        $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
        return $pdo;
    }

    private function createAuditTables(PDO $pdo): void
    {
        $pdo->exec('CREATE TABLE _audit_action (
            id TEXT PRIMARY KEY,
            occurred_at TEXT,
            actor_id TEXT,
            actor_type TEXT,
            actor_ip TEXT,
            tenant_id TEXT,
            session_id TEXT,
            client_id TEXT,
            user_agent TEXT,
            request_method TEXT,
            request_path TEXT,
            action_type TEXT
        )');
        $pdo->exec('CREATE TABLE _audit_change (
            id TEXT PRIMARY KEY,
            action_id TEXT,
            target_type TEXT,
            target_id TEXT,
            change_type TEXT,
            change_order INTEGER,
            payload TEXT,
            metadata TEXT
        )');
    }

    private function createRequest(string $method, string $path, string $userAgent): ServerRequestInterface
    {
        $uri = $this->createMock(UriInterface::class);
        $uri->method('getPath')->willReturn($path);

        $request = $this->createMock(ServerRequestInterface::class);
        $request->method('getMethod')->willReturn($method);
        $request->method('getHeaderLine')->with('User-Agent')->willReturn($userAgent);
        $request->method('getUri')->willReturn($uri);

        return $request;
    }

    private function createResponse(int $status): ResponseInterface
    {
        $response = $this->createMock(ResponseInterface::class);
        $response->method('getStatusCode')->willReturn($status);
        return $response;
    }

    private function createHandler(ResponseInterface $response): RequestHandlerInterface
    {
        $handler = $this->createMock(RequestHandlerInterface::class);
        $handler->method('handle')->willReturn($response);
        return $handler;
    }
}
