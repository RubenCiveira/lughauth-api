<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use Slim\Psr7\Response;
use Slim\Interfaces\DispatcherInterface;
use Slim\Interfaces\RouteInterface;
use Slim\Interfaces\RouteParserInterface;
use Slim\Routing\RouteContext;
use Slim\Routing\RoutingResults;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Prometheus\CollectorRegistry;
use Prometheus\Counter;
use Prometheus\Gauge;
use Prometheus\Histogram;
use Prometheus\Storage\InMemory;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Infrastructure\Middelware\PrometheusMetricMiddleware;
use Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\PrometheusRegistryExporter;
use Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\MetricsFS;
use Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\TimeWindowPolicy;

final class PrometheusMetricMiddlewareUnitTest extends TestCase
{
    public function testRecordsMetrics(): void
    {
        $registry = $this->createMock(CollectorRegistry::class);
        $gauges = [$this->createMock(Gauge::class), $this->createMock(Gauge::class)];
        $histogram = $this->createMock(Histogram::class);
        $counters = [
            $this->createMock(Counter::class),
            $this->createMock(Counter::class),
            $this->createMock(Counter::class)
        ];

        foreach ($gauges as $gauge) {
            $gauge->expects($this->once())->method('set');
        }
        $histogram->expects($this->once())->method('observe');
        foreach ($counters as $counter) {
            $counter->expects($this->once())->method('incBy');
        }

        $registry->method('getOrRegisterGauge')->willReturnOnConsecutiveCalls(...$gauges);
        $registry->method('getOrRegisterHistogram')->willReturn($histogram);
        $registry->method('getOrRegisterCounter')->willReturnOnConsecutiveCalls(...$counters);

        $exporter = $this->exporter();

        $middleware = new PrometheusMetricMiddleware($this->config(), $exporter, $registry);
        $request = $this->request('/users');
        $handler = $this->handler(401);

        $response = $middleware($request, $handler);
        $this->assertSame(401, $response->getStatusCode());

        $this->invokePrivateMethod($middleware, 'shutdownFlush');
    }

    public function testManagementPathSkipsMetrics(): void
    {
        $registry = $this->createMock(CollectorRegistry::class);
        $registry->expects($this->never())->method('getOrRegisterCounter');
        $registry->expects($this->never())->method('getOrRegisterGauge');

        $exporter = $this->exporter();
        $middleware = new PrometheusMetricMiddleware($this->config(), $exporter, $registry);
        $request = $this->request('/management/health');
        $handler = $this->handler(200);

        $response = $middleware($request, $handler);
        $this->assertSame(200, $response->getStatusCode());
    }

    private function config(): AppConfig
    {
        return new class () extends AppConfig {
            public function __construct()
            {
                $this->develop = true;
                $this->name = 'app';
                $this->managementEndpoint = '/management';
            }
        };
    }

    private function request(string $path): ServerRequestInterface
    {
        $route = $this->createMock(RouteInterface::class);
        $route->method('getPattern')->willReturn($path);

        $dispatcher = $this->createMock(DispatcherInterface::class);
        $routeParser = $this->createMock(RouteParserInterface::class);
        $routingResults = new RoutingResults($dispatcher, 'GET', $path, RoutingResults::FOUND);

        $request = $this->createMock(ServerRequestInterface::class);
        $request->method('getAttribute')->willReturnMap([
            [RouteContext::ROUTE, null, $route],
            [RouteContext::ROUTE_PARSER, null, $routeParser],
            [RouteContext::ROUTING_RESULTS, null, $routingResults],
            [RouteContext::BASE_PATH, null, ''],
        ]);
        return $request;
    }

    private function handler(int $status): RequestHandlerInterface
    {
        return new class ($status) implements RequestHandlerInterface {
            public function __construct(private readonly int $status)
            {
            }

            public function handle(ServerRequestInterface $request): \Psr\Http\Message\ResponseInterface
            {
                return new Response($this->status);
            }
        };
    }

    private function invokePrivateMethod(object $target, string $method, array $args = []): mixed
    {
        $ref = new ReflectionClass($target);
        $refMethod = $ref->getMethod($method);
        $refMethod->setAccessible(true);
        return $refMethod->invokeArgs($target, $args);
    }

    private function exporter(): PrometheusRegistryExporter
    {
        $policy = new class () implements TimeWindowPolicy {
            public function mustTrace(): bool
            {
                return false;
            }
        };
        $registry = new CollectorRegistry(new InMemory());
        $fs = new MetricsFS(sys_get_temp_dir() . '/export_' . uniqid());
        return new PrometheusRegistryExporter($policy, $registry, $fs);
    }
}
