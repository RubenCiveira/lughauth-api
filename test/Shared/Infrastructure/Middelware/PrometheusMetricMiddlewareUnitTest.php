<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use Slim\Psr7\Response;
use Slim\Interfaces\DispatcherInterface;
use Slim\Interfaces\RouteInterface;
use Slim\Interfaces\RouteParserInterface;
use Slim\Routing\RouteContext;
use Slim\Routing\RoutingResults;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Prometheus\CollectorRegistry;
use Prometheus\Counter;
use Prometheus\Gauge;
use Prometheus\Histogram;
use Prometheus\Storage\InMemory;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Infrastructure\Middelware\PrometheusMetricMiddleware;
use Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\PrometheusRegistryExporter;
use Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\MetricsFS;
use Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\TimeWindowPolicy;

/**
 * Unit tests for PrometheusMetricMiddleware.
 */
final class PrometheusMetricMiddlewareUnitTest extends TestCase
{
    /**
     * Ensures metrics are recorded for non-management requests.
     */
    public function testRecordsMetrics(): void
    {
        /*
         * Arrange: build registry mocks and middleware dependencies.
         */
        $registry = $this->registryWithCounters(3);

        $exporter = $this->exporter();

        $middleware = new PrometheusMetricMiddleware($this->config(), $exporter, $registry);
        $request = $this->request('/users');
        $handler = $this->handler(401);

        /*
         * Act: handle the request through the middleware.
         */
        $response = $middleware($request, $handler);

        /*
         * Assert: verify the response status and flush behavior.
         */
        $this->assertSame(401, $response->getStatusCode());

        $this->invokePrivateMethod($middleware, 'shutdownFlush');
    }

    /**
     * Ensures status 200 records success counters.
     */
    public function testRecordsMetricsForStatus200(): void
    {
        /*
         * Arrange: build a middleware with a 200 response.
         */
        $registry = $this->registryWithCounters(2);
        $exporter = $this->exporter();
        $middleware = new PrometheusMetricMiddleware($this->config(), $exporter, $registry);
        $request = $this->request('/users');
        $handler = $this->handler(200);

        /*
         * Act: handle the request through the middleware.
         */
        $response = $middleware($request, $handler);

        /*
         * Assert: verify the response status is successful.
         */
        $this->assertSame(200, $response->getStatusCode());
    }

    /**
     * Ensures status 403 records 4xx and forbidden counters.
     */
    public function testRecordsMetricsForStatus403(): void
    {
        /*
         * Arrange: build a middleware with a 403 response.
         */
        $registry = $this->registryWithCounters(3);
        $exporter = $this->exporter();
        $middleware = new PrometheusMetricMiddleware($this->config(), $exporter, $registry);
        $request = $this->request('/users');
        $handler = $this->handler(403);

        /*
         * Act: handle the request through the middleware.
         */
        $response = $middleware($request, $handler);

        /*
         * Assert: verify the response status is forbidden.
         */
        $this->assertSame(403, $response->getStatusCode());
    }

    /**
     * Ensures status 500 records 5xx counters.
     */
    public function testRecordsMetricsForStatus500(): void
    {
        /*
         * Arrange: build a middleware with a 500 response.
         */
        $registry = $this->registryWithCounters(2);
        $exporter = $this->exporter();
        $middleware = new PrometheusMetricMiddleware($this->config(), $exporter, $registry);
        $request = $this->request('/users');
        $handler = $this->handler(500);

        /*
         * Act: handle the request through the middleware.
         */
        $response = $middleware($request, $handler);

        /*
         * Assert: verify the response status is server error.
         */
        $this->assertSame(500, $response->getStatusCode());
    }

    /**
     * Ensures status 502 records 5xx and bad gateway counters.
     */
    public function testRecordsMetricsForStatus502(): void
    {
        /*
         * Arrange: build a middleware with a 502 response.
         */
        $registry = $this->registryWithCounters(3);
        $exporter = $this->exporter();
        $middleware = new PrometheusMetricMiddleware($this->config(), $exporter, $registry);
        $request = $this->request('/users');
        $handler = $this->handler(502);

        /*
         * Act: handle the request through the middleware.
         */
        $response = $middleware($request, $handler);

        /*
         * Assert: verify the response status is bad gateway.
         */
        $this->assertSame(502, $response->getStatusCode());
    }

    /**
     * Ensures management paths skip metric recording.
     */
    public function testManagementPathSkipsMetrics(): void
    {
        /*
         * Arrange: create a registry mock that should not be used.
         */
        $registry = $this->createMock(CollectorRegistry::class);
        $registry->expects($this->never())->method('getOrRegisterCounter');
        $registry->expects($this->never())->method('getOrRegisterGauge');

        $exporter = $this->exporter();
        $middleware = new PrometheusMetricMiddleware($this->config(), $exporter, $registry);
        $request = $this->request('/management/health');
        $handler = $this->handler(200);

        /*
         * Act: handle the management request.
         */
        $response = $middleware($request, $handler);

        /*
         * Assert: verify the request completes successfully.
         */
        $this->assertSame(200, $response->getStatusCode());
    }

    private function config(): AppConfig
    {
        return new class () extends AppConfig {
            public function __construct()
            {
                $this->develop = true;
                $this->name = 'app';
                $this->managementEndpoint = '/management';
            }
        };
    }

    private function request(string $path): ServerRequestInterface
    {
        $route = $this->createMock(RouteInterface::class);
        $route->method('getPattern')->willReturn($path);

        $dispatcher = $this->createMock(DispatcherInterface::class);
        $routeParser = $this->createMock(RouteParserInterface::class);
        $routingResults = new RoutingResults($dispatcher, 'GET', $path, RoutingResults::FOUND);

        $request = $this->createMock(ServerRequestInterface::class);
        $request->method('getAttribute')->willReturnMap([
            [RouteContext::ROUTE, null, $route],
            [RouteContext::ROUTE_PARSER, null, $routeParser],
            [RouteContext::ROUTING_RESULTS, null, $routingResults],
            [RouteContext::BASE_PATH, null, ''],
        ]);
        return $request;
    }

    private function handler(int $status): RequestHandlerInterface
    {
        return new class ($status) implements RequestHandlerInterface {
            public function __construct(private readonly int $status)
            {
            }

            public function handle(ServerRequestInterface $request): \Psr\Http\Message\ResponseInterface
            {
                return new Response($this->status);
            }
        };
    }

    private function invokePrivateMethod(object $target, string $method, array $args = []): mixed
    {
        $ref = new ReflectionClass($target);
        $refMethod = $ref->getMethod($method);
        $refMethod->setAccessible(true);
        return $refMethod->invokeArgs($target, $args);
    }

    private function registryWithCounters(int $counterCount): CollectorRegistry
    {
        $registry = $this->createMock(CollectorRegistry::class);
        $gauges = [$this->createMock(Gauge::class), $this->createMock(Gauge::class)];
        $histogram = $this->createMock(Histogram::class);
        $counters = [];
        for ($i = 0; $i < $counterCount; $i++) {
            $counters[] = $this->createMock(Counter::class);
        }

        foreach ($gauges as $gauge) {
            $gauge->expects($this->once())->method('set');
        }
        $histogram->expects($this->once())->method('observe');
        foreach ($counters as $counter) {
            $counter->expects($this->once())->method('incBy');
        }

        $registry->method('getOrRegisterGauge')->willReturnOnConsecutiveCalls(...$gauges);
        $registry->method('getOrRegisterHistogram')->willReturn($histogram);
        $registry->method('getOrRegisterCounter')->willReturnOnConsecutiveCalls(...$counters);

        return $registry;
    }

    private function exporter(): PrometheusRegistryExporter
    {
        $policy = new class () implements TimeWindowPolicy {
            public function mustTrace(): bool
            {
                return false;
            }
        };
        $registry = new CollectorRegistry(new InMemory());
        $fs = new MetricsFS(sys_get_temp_dir() . '/export_' . uniqid());
        return new PrometheusRegistryExporter($policy, $registry, $fs);
    }
}
