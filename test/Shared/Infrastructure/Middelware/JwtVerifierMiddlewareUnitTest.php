<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use Psr\Http\Client\ClientInterface;
use Psr\Http\Message\RequestFactoryInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\SimpleCache\CacheInterface;
use Jose\Component\KeyManagement\JWKFactory;
use Jose\Component\Core\AlgorithmManager;
use Jose\Component\Signature\Algorithm\RS256;
use Jose\Component\Signature\JWSBuilder;
use Jose\Component\Signature\Serializer\CompactSerializer;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Context;
use Civi\Lughauth\Shared\Exception\UnauthorizedException;
use Civi\Lughauth\Shared\Security\Identity;
use Civi\Lughauth\Shared\Infrastructure\Middelware\JwtVerifierMiddleware;

/**
 * Unit tests for JwtVerifierMiddleware.
 */
final class JwtVerifierMiddlewareUnitTest extends TestCase
{
    /**
     * Ensures JWT verification is skipped when disabled.
     */
    public function testInvokeSkipsWhenDisabled(): void
    {
        /*
         * Arrange: create middleware with JWT verification disabled.
         */
        $middleware = $this->middleware(['security.jwt.verify.publickey.location' => '-']);
        $request = $this->request('Bearer token');

        /*
         * Act: handle the request through the middleware.
         */
        $response = $middleware($request, $this->handler());

        /*
         * Assert: verify the request is allowed.
         */
        $this->assertSame(200, $response->getStatusCode());
    }

    /**
     * Ensures cached errors raise an unauthorized exception.
     */
    public function testVerifyAuthUsesCachedError(): void
    {
        /*
         * Arrange: seed the cache with an error payload.
         */
        $cache = new ArrayCache([
            'verify_access_token' => json_encode([null, null, 'fail'])
        ]);
        $middleware = $this->middleware(['security.jwt.verify.publickey.location' => 'http://jwks'], $cache);

        /*
         * Act: handle the request and expect an exception.
         */
        $this->expectException(UnauthorizedException::class);
        $middleware($this->request('Bearer token'), $this->handler());

        /*
         * Assert: verify unauthorized exception is raised.
         */
    }

    /**
     * Ensures cached data populates the security context.
     */
    public function testVerifyAuthUsesCachedData(): void
    {
        /*
         * Arrange: seed the cache with serialized identity data.
         */
        $connection = [
            'remote' => true,
            'startTime' => ['date' => '2024-01-01 00:00:00.000000'],
            'application' => 'app',
            'callback' => '/',
            'source' => '127.0.0.1',
            'target' => 'host',
            'locale' => 'en'
        ];
        $identity = [
            'anonimous' => false,
            'authScope' => Identity::AUTH_SCOPE_BOTH,
            'id' => 'user',
            'name' => 'user',
            'issuer' => 'issuer',
            'roles' => ['admin'],
            'groups' => [],
            'tenant' => 'main',
            'claims' => []
        ];
        $cache = new ArrayCache([
            'verify_access_token' => json_encode([$connection, $identity, null])
        ]);

        $context = $this->createMock(Context::class);
        $context->expects($this->once())
            ->method('setSecurityContext')
            ->with($this->isInstanceOf(\Civi\Lughauth\Shared\Security\Connection::class), $this->isInstanceOf(Identity::class));

        $middleware = $this->middleware(['security.jwt.verify.publickey.location' => 'http://jwks'], $cache, $context);

        /*
         * Act: handle the request with cached identity data.
         */
        $response = $middleware($this->request('Bearer token'), $this->handler());

        /*
         * Assert: verify the request succeeds.
         */
        $this->assertSame(200, $response->getStatusCode());
    }

    /**
     * Ensures valid JWTs are verified and accepted.
     */
    public function testVerifyAuthSuccessFlow(): void
    {
        /*
         * Arrange: create a valid JWT and JWKS payload.
         */
        $_SERVER['REQUEST_URI'] = '/';
        $_SERVER['SERVER_NAME'] = 'host';
        $_SERVER['REMOTE_ADDR'] = '127.0.0.1';
        $now = time();
        $key = JWKFactory::createRSAKey(1024, ['use' => 'sig', 'alg' => 'RS256', 'kid' => 'k1']);
        $jwks = json_encode(['keys' => [$key->jsonSerialize()]], JSON_THROW_ON_ERROR);
        $token = $this->jwt([
            'sub' => 'user',
            'name' => 'User',
            'email' => 'user@example.com',
            'iss' => 'issuer',
            'aud' => 'aud1',
            'azp' => 'app',
            'nbf' => $now - 10,
            'exp' => $now + 1000,
            'tenant' => 'main',
            'realm_access' => ['roles' => ['admin']]
        ], $key);

        $cache = new ArrayCache([
            'jwks.verify.publickey' => $jwks
        ]);
        $context = $this->createMock(Context::class);
        $context->expects($this->once())
            ->method('setSecurityContext')
            ->with($this->isInstanceOf(\Civi\Lughauth\Shared\Security\Connection::class), $this->isInstanceOf(Identity::class));

        $middleware = $this->middleware([
            'security.jwt.verify.publickey.location' => 'http://jwks',
            'security.jwt.verify.issuer' => 'issuer',
            'security.jwt.verify.audiences' => 'aud1',
            'security.jwt.verify.path.roles' => 'realm_access/roles'
        ], $cache, $context);

        /*
         * Act: handle the request with the valid token.
         */
        $response = $middleware($this->request('Bearer ' . $token), $this->handler());

        /*
         * Assert: verify the request succeeds.
         */
        $this->assertSame(200, $response->getStatusCode());
    }

    /**
     * Ensures expired tokens are rejected.
     */
    public function testVerifyAuthExpiredToken(): void
    {
        /*
         * Arrange: create an expired JWT token.
         */
        $_SERVER['REQUEST_URI'] = '/';
        $_SERVER['SERVER_NAME'] = 'host';
        $_SERVER['REMOTE_ADDR'] = '127.0.0.1';
        $now = time();
        $key = JWKFactory::createRSAKey(1024, ['use' => 'sig', 'alg' => 'RS256', 'kid' => 'k1']);
        $jwks = json_encode(['keys' => [$key->jsonSerialize()]], JSON_THROW_ON_ERROR);
        $token = $this->jwt([
            'sub' => 'user',
            'iss' => 'issuer',
            'aud' => 'aud1',
            'azp' => 'app',
            'nbf' => $now - 10,
            'exp' => $now - 1
        ], $key);

        $cache = new ArrayCache([
            'jwks.verify.publickey' => $jwks
        ]);

        $middleware = $this->middleware([
            'security.jwt.verify.publickey.location' => 'http://jwks',
            'security.jwt.verify.issuer' => 'issuer',
            'security.jwt.verify.audiences' => 'aud1',
        ], $cache);

        /*
         * Act: handle the request and expect an exception.
         */
        $this->expectException(UnauthorizedException::class);
        $middleware($this->request('Bearer ' . $token), $this->handler());

        /*
         * Assert: verify unauthorized exception is raised.
         */
    }

    /**
     * Ensures tokens with invalid signatures are rejected.
     */
    public function testVerifyAuthInvalidSignature(): void
    {
        /*
         * Arrange: create a token signed with a mismatched key.
         */
        $_SERVER['REQUEST_URI'] = '/';
        $_SERVER['SERVER_NAME'] = 'host';
        $_SERVER['REMOTE_ADDR'] = '127.0.0.1';
        $now = time();
        $key = JWKFactory::createRSAKey(1024, ['use' => 'sig', 'alg' => 'RS256', 'kid' => 'k1']);
        $badKey = JWKFactory::createRSAKey(1024, ['use' => 'sig', 'alg' => 'RS256', 'kid' => 'k2']);
        $jwks = json_encode(['keys' => [$badKey->jsonSerialize()]], JSON_THROW_ON_ERROR);
        $token = $this->jwt([
            'sub' => 'user',
            'iss' => 'issuer',
            'aud' => 'aud1',
            'azp' => 'app',
            'nbf' => $now - 10,
            'exp' => $now + 1000
        ], $key);

        $cache = new ArrayCache([
            'jwks.verify.publickey' => $jwks
        ]);

        $middleware = $this->middleware([
            'security.jwt.verify.publickey.location' => 'http://jwks',
            'security.jwt.verify.issuer' => 'issuer',
            'security.jwt.verify.audiences' => 'aud1',
        ], $cache);

        /*
         * Act: handle the request and expect an exception.
         */
        $this->expectException(UnauthorizedException::class);
        $middleware($this->request('Bearer ' . $token), $this->handler());

        /*
         * Assert: verify unauthorized exception is raised.
         */
    }

    /**
     * Ensures malformed tokens are rejected.
     */
    public function testVerifyAuthInvalidToken(): void
    {
        /*
         * Arrange: configure middleware with an invalid token input.
         */
        $cache = new ArrayCache(['jwks.verify.publickey' => json_encode(['keys' => []])]);
        $middleware = $this->middleware(['security.jwt.verify.publickey.location' => 'http://jwks'], $cache);

        /*
         * Act: handle the request and expect an exception.
         */
        $this->expectException(UnauthorizedException::class);
        $middleware($this->request('Bearer invalid.token'), $this->handler());

        /*
         * Assert: verify unauthorized exception is raised.
         */
    }

    /**
     * Ensures issuer mismatches are rejected.
     */
    public function testVerifyTokenIssuerMismatch(): void
    {
        /*
         * Arrange: access the verifyToken method with a mismatched issuer.
         */
        $middleware = $this->middleware(['security.jwt.verify.issuer' => 'issuer']);
        $method = new ReflectionMethod($middleware, 'verifyToken');
        $method->setAccessible(true);

        /*
         * Act: invoke verifyToken and expect an exception.
         */
        $this->expectException(UnauthorizedException::class);
        $method->invoke($middleware, (object) ['iss' => 'other']);

        /*
         * Assert: verify unauthorized exception is raised.
         */
    }

    /**
     * Ensures audience mismatches are rejected.
     */
    public function testVerifyTokenAudienceMismatch(): void
    {
        /*
         * Arrange: access the verifyToken method with a mismatched audience.
         */
        $middleware = $this->middleware(['security.jwt.verify.audiences' => 'aud1,aud2']);
        $method = new ReflectionMethod($middleware, 'verifyToken');
        $method->setAccessible(true);

        /*
         * Act: invoke verifyToken and expect an exception.
         */
        $this->expectException(UnauthorizedException::class);
        $method->invoke($middleware, (object) ['aud' => 'aud3']);

        /*
         * Assert: verify unauthorized exception is raised.
         */
    }

    /**
     * Ensures missing role paths return an empty array.
     */
    public function testExtractRolesMissingPath(): void
    {
        /*
         * Arrange: access the extractRoles method with missing data.
         */
        $middleware = $this->middleware(['security.jwt.verify.path.roles' => 'realm_access/roles']);
        $method = new ReflectionMethod($middleware, 'extractRoles');
        $method->setAccessible(true);

        /*
         * Act: invoke extractRoles with an empty payload.
         */
        $this->assertSame([], $method->invoke($middleware, (object) []));

        /*
         * Assert: verify the roles list is empty.
         */
    }

    /**
     * Ensures JWKS data is fetched and cached.
     */
    public function testGetJwksFetchesFromClient(): void
    {
        /*
         * Arrange: configure cache and client with a JWKS response.
         */
        $cache = new ArrayCache();
        $response = $this->createMock(ResponseInterface::class);
        $response->method('getBody')->willReturn($this->stream('jwks'));

        $client = $this->createMock(ClientInterface::class);
        $client->expects($this->once())->method('sendRequest')->willReturn($response);

        $middleware = $this->middleware(['security.jwt.verify.publickey.location' => 'http://jwks'], $cache, null, $client);
        $method = new ReflectionMethod($middleware, 'getJwks');
        $method->setAccessible(true);

        /*
         * Act: invoke the JWKS retrieval method.
         */
        $result = $method->invoke($middleware);

        /*
         * Assert: verify the JWKS data is returned and cached.
         */
        $this->assertSame('jwks', $result);
        $this->assertTrue($cache->has('jwks.verify.publickey'));
    }

    private function middleware(array $configOverrides = [], ?CacheInterface $cache = null, ?Context $context = null, ?ClientInterface $client = null): JwtVerifierMiddleware
    {
        $config = new class ($configOverrides) extends AppConfig {
            public function __construct(private readonly array $overrides)
            {
                $this->develop = true;
                $this->name = 'app';
                $this->managementEndpoint = '/management';
            }

            public function get(string $name, mixed $def = null): mixed
            {
                return $this->overrides[$name] ?? $def;
            }
        };

        $context = $context ?? $this->createMock(Context::class);
        $cache = $cache ?? new ArrayCache();
        $requestFactory = $this->createMock(RequestFactoryInterface::class);
        $request = $this->createMock(\Psr\Http\Message\RequestInterface::class);
        $request->method('withHeader')->willReturnSelf();
        $requestFactory->method('createRequest')->willReturn($request);
        $client = $client ?? $this->createMock(ClientInterface::class);

        return new JwtVerifierMiddleware($config, $context, $cache, $requestFactory, $client);
    }

    private function request(string $authorization): ServerRequestInterface
    {
        $request = $this->createMock(ServerRequestInterface::class);
        $request->method('getHeader')->willReturn([$authorization]);
        $request->method('getMethod')->willReturn('GET');
        return $request;
    }

    private function handler(): \Psr\Http\Server\RequestHandlerInterface
    {
        return new class () implements \Psr\Http\Server\RequestHandlerInterface {
            public function handle(ServerRequestInterface $request): \Psr\Http\Message\ResponseInterface
            {
                return new \Slim\Psr7\Response(200);
            }
        };
    }

    private function jwt(array $payload, $key): string
    {
        $jwsBuilder = new JWSBuilder(new AlgorithmManager([new RS256()]));
        $jws = $jwsBuilder
            ->create()
            ->withPayload(json_encode($payload, JSON_THROW_ON_ERROR))
            ->addSignature($key, ['alg' => 'RS256', 'kid' => 'k1'])
            ->build();

        return (new CompactSerializer())->serialize($jws, 0);
    }

    private function stream(string $contents): \Psr\Http\Message\StreamInterface
    {
        return (new \Slim\Psr7\Factory\StreamFactory())->createStream($contents);
    }
}

/**
 * In-memory cache for middleware tests.
 */
final class ArrayCache implements CacheInterface
{
    public function __construct(
        /** @var array<string, mixed> Cached values. */
        private array $values = []
    ) {
    }

    public function get(string $key, mixed $default = null): mixed
    {
        return $this->values[$key] ?? $default;
    }

    public function set(string $key, mixed $value, null|int|DateInterval $ttl = null): bool
    {
        $this->values[$key] = $value;
        return true;
    }

    public function delete(string $key): bool
    {
        unset($this->values[$key]);
        return true;
    }

    public function clear(): bool
    {
        $this->values = [];
        return true;
    }

    public function getMultiple(iterable $keys, mixed $default = null): iterable
    {
        $result = [];
        foreach ($keys as $key) {
            $result[$key] = $this->get($key, $default);
        }
        return $result;
    }

    public function setMultiple(iterable $values, null|int|DateInterval $ttl = null): bool
    {
        foreach ($values as $key => $value) {
            $this->set($key, $value, $ttl);
        }
        return true;
    }

    public function deleteMultiple(iterable $keys): bool
    {
        foreach ($keys as $key) {
            $this->delete($key);
        }
        return true;
    }

    public function has(string $key): bool
    {
        return array_key_exists($key, $this->values);
    }
}
