<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use Slim\App;
use Slim\Psr7\Response;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Message\UriInterface;
use Psr\Http\Server\RequestHandlerInterface;
use OpenTelemetry\API\Trace\SpanInterface;
use OpenTelemetry\API\Trace\SpanBuilderInterface;
use OpenTelemetry\API\Trace\TracerInterface;
use OpenTelemetry\Context\ScopeInterface;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Observability\TraceContext;
use Civi\Lughauth\Shared\Infrastructure\Middelware\TelemetrySpanMiddleware;

/**
 * Unit tests for TelemetrySpanMiddleware.
 */
final class TelemetrySpanMiddlewareUnitTest extends TestCase
{
    /**
     * Ensures a span is created and closed around the request.
     */
    public function testSpanStartsAndEnds(): void
    {
        /*
         * Arrange: create span mocks and a middleware instance.
         */
        $span = $this->createMock(SpanInterface::class);
        $scope = $this->createMock(ScopeInterface::class);
        $span->expects($this->once())->method('activate')->willReturn($scope);
        $span->expects($this->once())->method('end');
        $scope->expects($this->once())->method('detach');

        $builder = $this->createMock(SpanBuilderInterface::class);
        $builder->expects($this->once())
            ->method('setParent')
            ->with($this->isInstanceOf(\OpenTelemetry\Context\Context::class))
            ->willReturnSelf();
        $builder->expects($this->once())
            ->method('startSpan')
            ->willReturn($span);

        $tracer = $this->createMock(TracerInterface::class);
        $tracer->expects($this->once())
            ->method('spanBuilder')
            ->with('Request GET /users')
            ->willReturn($builder);

        $middleware = new TelemetrySpanMiddleware($this->app('/api'), $this->config(), $tracer, new TraceContext([]));
        $request = $this->request('/api/users', ['traceparent' => ['00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01']]);
        $handler = $this->handler();

        /*
         * Act: handle the request through the middleware.
         */
        $response = $middleware($request, $handler);

        /*
         * Assert: verify the response is returned.
         */
        $this->assertSame(200, $response->getStatusCode());
    }

    /**
     * Ensures management paths skip span creation.
     */
    public function testManagementPathSkipsSpan(): void
    {
        /*
         * Arrange: create a tracer mock and management request.
         */
        $tracer = $this->createMock(TracerInterface::class);
        $tracer->expects($this->never())->method('spanBuilder');

        $middleware = new TelemetrySpanMiddleware($this->app(''), $this->config(), $tracer, new TraceContext([]));
        $request = $this->request('/management/health');
        $handler = $this->handler();

        /*
         * Act: handle the management request through the middleware.
         */
        $response = $middleware($request, $handler);

        /*
         * Assert: verify the request completes successfully.
         */
        $this->assertSame(200, $response->getStatusCode());
    }

    /**
     * Ensures empty paths after base path trimming are normalized to '/'.
     */
    public function testBasePathTrimProducesRootPath(): void
    {
        /*
         * Arrange: create span mocks for a base path that matches the request path.
         */
        $span = $this->createMock(SpanInterface::class);
        $scope = $this->createMock(ScopeInterface::class);
        $span->expects($this->once())->method('activate')->willReturn($scope);
        $span->expects($this->once())->method('end');
        $scope->expects($this->once())->method('detach');

        $builder = $this->createMock(SpanBuilderInterface::class);
        $builder->expects($this->once())
            ->method('setParent')
            ->with($this->isInstanceOf(\OpenTelemetry\Context\Context::class))
            ->willReturnSelf();
        $builder->expects($this->once())
            ->method('startSpan')
            ->willReturn($span);

        $tracer = $this->createMock(TracerInterface::class);
        $tracer->expects($this->once())
            ->method('spanBuilder')
            ->with('Request GET /')
            ->willReturn($builder);

        $middleware = new TelemetrySpanMiddleware($this->app('/api'), $this->config(), $tracer, new TraceContext([]));
        $request = $this->request('/api');
        $handler = $this->handler();

        /*
         * Act: handle the request through the middleware.
         */
        $response = $middleware($request, $handler);

        /*
         * Assert: verify the response is returned successfully.
         */
        $this->assertSame(200, $response->getStatusCode());
    }

    private function app(string $basePath): App
    {
        $app = $this->createMock(App::class);
        $app->method('getBasePath')->willReturn($basePath);
        return $app;
    }

    private function config(): AppConfig
    {
        return new class () extends AppConfig {
            public function __construct()
            {
                $this->develop = true;
                $this->name = 'app';
                $this->managementEndpoint = '/management';
            }
        };
    }

    private function request(string $path, array $headers = []): ServerRequestInterface
    {
        $uri = $this->createMock(UriInterface::class);
        $uri->method('getPath')->willReturn($path);

        $request = $this->createMock(ServerRequestInterface::class);
        $request->method('getUri')->willReturn($uri);
        $request->method('getMethod')->willReturn('GET');
        $request->method('getHeader')->willReturnCallback(function (string $name) use ($headers) {
            return $headers[$name] ?? [];
        });
        return $request;
    }

    private function handler(): RequestHandlerInterface
    {
        return new class () implements RequestHandlerInterface {
            public function handle(ServerRequestInterface $request): \Psr\Http\Message\ResponseInterface
            {
                return new Response(200);
            }
        };
    }
}
