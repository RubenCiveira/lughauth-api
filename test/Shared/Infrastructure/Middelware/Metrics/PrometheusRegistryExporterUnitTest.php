<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics {
    final class PrometheusRegistryExporterTestHook
    {
        public static bool $captureJsonlWrites = false;
        public static int $jsonlWrites = 0;
        public static bool $forceArrayCombineFalse = false;
    }

    if (!function_exists(__NAMESPACE__ . '\\file_put_contents')) {
        function file_put_contents(string $filename, mixed $data, int $flags = 0, $context = null): int|false
        {
            if (PrometheusRegistryExporterTestHook::$captureJsonlWrites && str_ends_with($filename, '.jsonl')) {
                PrometheusRegistryExporterTestHook::$jsonlWrites++;
            }

            if ($context !== null) {
                return \file_put_contents($filename, $data, $flags, $context);
            }

            return \file_put_contents($filename, $data, $flags);
        }
    }

    if (!function_exists(__NAMESPACE__ . '\\array_combine')) {
        function array_combine(array $keys, array $values): array|false
        {
            if (PrometheusRegistryExporterTestHook::$forceArrayCombineFalse) {
                return false;
            }

            return \array_combine($keys, $values);
        }
    }
}

namespace {
use PHPUnit\Framework\TestCase;
use Prometheus\CollectorRegistry;
use Prometheus\MetricFamilySamples;
use Prometheus\Storage\InMemory;
use Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\PrometheusRegistryExporter;
use Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\PrometheusRegistryExporterTestHook;
use Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\MetricsFS;
use Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\TimeWindowPolicy;

/**
 * Unit tests for PrometheusRegistryExporter.
 */
final class PrometheusRegistryExporterUnitTest extends TestCase
{
    /**
     * Ensures dump skips when policy returns false.
     */
    public function testDumpSkipsWhenPolicyFalse(): void
    {
        /*
         * Arrange: create an exporter with a disabled policy.
         */
        $root = sys_get_temp_dir() . '/export_' . uniqid();
        $fs = new MetricsFS($root);
        $registry = new CollectorRegistry(new InMemory());
        $policy = $this->policy(false);

        $exporter = new PrometheusRegistryExporter($policy, $registry, $fs);

        /*
         * Act: attempt to dump metrics.
         */
        $exporter->dump();

        /*
         * Assert: verify no files are created.
         */
        $this->assertSame([], glob($root . '/*'));
    }

    /**
     * Ensures force dump writes metric files.
     */
    public function testForceDumpWritesFiles(): void
    {
        /*
         * Arrange: create an exporter with sample metrics.
         */
        $root = sys_get_temp_dir() . '/export_' . uniqid();
        $fs = new MetricsFS($root);
        $registry = $this->registryWithSample();
        $policy = $this->policy(true);

        $exporter = new PrometheusRegistryExporter($policy, $registry, $fs, [
            'include' => ['~^app_~'],
            'exclude' => ['~skip~'],
            'label_allow' => ['path']
        ]);

        /*
         * Act: force a metrics dump.
         */
        $exporter->dump();

        /*
         * Assert: verify metric files are written.
         */
        $files = glob($root . '/app_metric/series/*/*/raw/*/*/*.jsonl');
        $this->assertNotEmpty($files);
    }

    /**
     * Ensures compile and match behavior handles patterns.
     */
    public function testCompileAndMatch(): void
    {
        /*
         * Arrange: create an exporter and access helper methods.
         */
        $exporter = new PrometheusRegistryExporter($this->policy(true), $this->registryWithSample(), new MetricsFS(sys_get_temp_dir() . '/export_' . uniqid()));

        $compile = new ReflectionMethod($exporter, 'compile');
        $compile->setAccessible(true);
        $match = new ReflectionMethod($exporter, 'match');
        $match->setAccessible(true);

        /*
         * Act: compile patterns and evaluate matches.
         */
        $patterns = $compile->invoke($exporter, ['[invalid']);
        $includeMiss = $match->invoke($exporter, 'metric', ['~^ok$~'], []);
        $excludeHit = $match->invoke($exporter, 'metric', [], ['~metric~']);
        $includeHit = $match->invoke($exporter, 'metric', ['~metric~'], []);

        /*
         * Assert: verify compiled patterns and match results.
         */
        $this->assertStringStartsWith('~', $patterns[0]);
        $this->assertFalse($includeMiss);
        $this->assertFalse($excludeHit);
        $this->assertTrue($includeHit);
    }

    /**
     * Ensures label mismatches throw a ValueError.
     */
    public function testEscapeAllLabelsThrowsOnMismatch(): void
    {
        /*
         * Arrange: create a metric with mismatched labels.
         */
        $exporter = new PrometheusRegistryExporter($this->policy(true), $this->registryWithSample(), new MetricsFS(sys_get_temp_dir() . '/export_' . uniqid()));
        $metric = new MetricFamilySamples([
            'name' => 'metric',
            'type' => 'counter',
            'help' => 'help',
            'labelNames' => ['a', 'b'],
            'samples' => [[
                'name' => 'metric',
                'labelNames' => [],
                'labelValues' => [],
                'value' => 1
            ]]
        ]);

        $method = new ReflectionMethod($exporter, 'escapeAllLabels');
        $method->setAccessible(true);

        /*
         * Act: invoke the label escape method and expect an exception.
         */
        $this->expectException(ValueError::class);
        $method->invoke($exporter, $metric, $metric->getLabelNames(), $metric->getSamples()[0]);

        /*
         * Assert: verify the ValueError is thrown.
         */
    }

    /**
     * Ensures escapeAllLabels throws when combine fails.
     */
    public function testEscapeAllLabelsThrowsWhenCombineFails(): void
    {
        /*
         * Arrange: force array_combine to fail.
         */
        $exporter = new PrometheusRegistryExporter($this->policy(true), $this->registryWithSample(), new MetricsFS(sys_get_temp_dir() . '/export_' . uniqid()));
        $metric = new MetricFamilySamples([
            'name' => 'metric',
            'type' => 'counter',
            'help' => 'help',
            'labelNames' => [],
            'samples' => [[
                'name' => 'metric',
                'labelNames' => [],
                'labelValues' => [],
                'value' => 1
            ]]
        ]);

        $method = new ReflectionMethod($exporter, 'escapeAllLabels');
        $method->setAccessible(true);

        PrometheusRegistryExporterTestHook::$forceArrayCombineFalse = true;
        try {
            /*
             * Act: invoke escapeAllLabels expecting a RuntimeException.
             */
            $this->expectException(RuntimeException::class);
            $method->invoke($exporter, $metric, $metric->getLabelNames(), $metric->getSamples()[0]);
        } finally {
            PrometheusRegistryExporterTestHook::$forceArrayCombineFalse = false;
        }

        /*
         * Assert: exception is thrown.
         */
    }

    /**
     * Ensures ingestBatch skips non-matching metrics.
     */
    public function testIngestBatchSkipsNonMatchingMetrics(): void
    {
        /*
         * Arrange: create an exporter with a restrictive include filter.
         */
        $root = sys_get_temp_dir() . '/export_' . uniqid();
        $fs = new MetricsFS($root);
        $registry = new CollectorRegistry(new InMemory());
        $exporter = new PrometheusRegistryExporter($this->policy(true), $registry, $fs, [
            'include' => ['~^only_this$~'],
            'label_allow' => ['path']
        ]);

        $payload = [
            'other_metric' => [
                ['labels' => ['path' => '/api'], 'value' => 1]
            ]
        ];

        /*
         * Act: ingest the batch with a non-matching metric.
         */
        $exporter->ingestBatch($payload, 1000);

        /*
         * Assert: verify no files are created.
         */
        $this->assertSame([], glob($root . '/*'));
    }

    /**
     * Ensures ingestBatch flushes when threshold is reached.
     */
    public function testIngestBatchFlushesWhenThresholdReached(): void
    {
        /*
         * Arrange: create an exporter with a low flush threshold.
         */
        $root = sys_get_temp_dir() . '/export_' . uniqid();
        $fs = new MetricsFS($root);
        $registry = $this->createMock(CollectorRegistry::class);
        $exporter = new PrometheusRegistryExporter($this->policy(true), $registry, $fs, [
            'max_lines_flush' => 1,
            'label_allow' => []
        ]);

        $payload = [
            'metric' => [
                ['labels' => [], 'value' => 1],
                ['labels' => [], 'value' => 2]
            ]
        ];

        PrometheusRegistryExporterTestHook::$jsonlWrites = 0;
        PrometheusRegistryExporterTestHook::$captureJsonlWrites = true;
        try {
            /*
             * Act: ingest enough items to trigger the flush.
             */
            $exporter->ingestBatch($payload, 1000);
        } finally {
            PrometheusRegistryExporterTestHook::$captureJsonlWrites = false;
        }

        /*
         * Assert: verify the jsonl file was flushed during the loop.
         */
        $this->assertSame(2, PrometheusRegistryExporterTestHook::$jsonlWrites);
    }

    private function registryWithSample(): CollectorRegistry
    {
        $registry = $this->createMock(CollectorRegistry::class);
        $metric = new MetricFamilySamples([
            'name' => 'app_metric',
            'type' => 'counter',
            'help' => 'help',
            'labelNames' => ['path'],
            'samples' => [[
                'name' => 'app_metric',
                'labelNames' => [],
                'labelValues' => ["/api\n"],
                'value' => 1
            ]]
        ]);
        $registry->method('getMetricFamilySamples')->willReturn([$metric]);
        return $registry;
    }

    private function policy(bool $value): TimeWindowPolicy
    {
        return new class ($value) implements TimeWindowPolicy {
            public function __construct(private readonly bool $value)
            {
            }

            public function mustTrace(): bool
            {
                return $this->value;
            }
        };
    }
}
}
