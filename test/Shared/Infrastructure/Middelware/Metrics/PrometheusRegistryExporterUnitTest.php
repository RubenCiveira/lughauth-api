<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use Prometheus\CollectorRegistry;
use Prometheus\MetricFamilySamples;
use Prometheus\Storage\InMemory;
use Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\PrometheusRegistryExporter;
use Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\MetricsFS;
use Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\TimeWindowPolicy;

/**
 * Unit tests for PrometheusRegistryExporter.
 */
final class PrometheusRegistryExporterUnitTest extends TestCase
{
    /**
     * Ensures dump skips when policy returns false.
     */
    public function testDumpSkipsWhenPolicyFalse(): void
    {
        /*
         * Arrange: create an exporter with a disabled policy.
         */
        $root = sys_get_temp_dir() . '/export_' . uniqid();
        $fs = new MetricsFS($root);
        $registry = new CollectorRegistry(new InMemory());
        $policy = $this->policy(false);

        $exporter = new PrometheusRegistryExporter($policy, $registry, $fs);

        /*
         * Act: attempt to dump metrics.
         */
        $exporter->dump();

        /*
         * Assert: verify no files are created.
         */
        $this->assertSame([], glob($root . '/*'));
    }

    /**
     * Ensures force dump writes metric files.
     */
    public function testForceDumpWritesFiles(): void
    {
        /*
         * Arrange: create an exporter with sample metrics.
         */
        $root = sys_get_temp_dir() . '/export_' . uniqid();
        $fs = new MetricsFS($root);
        $registry = $this->registryWithSample();
        $policy = $this->policy(true);

        $exporter = new PrometheusRegistryExporter($policy, $registry, $fs, [
            'include' => ['~^app_~'],
            'exclude' => ['~skip~'],
            'label_allow' => ['path']
        ]);

        /*
         * Act: force a metrics dump.
         */
        $exporter->dump();

        /*
         * Assert: verify metric files are written.
         */
        $files = glob($root . '/app_metric/series/*/*/raw/*/*/*.jsonl');
        $this->assertNotEmpty($files);
    }

    /**
     * Ensures compile and match behavior handles patterns.
     */
    public function testCompileAndMatch(): void
    {
        /*
         * Arrange: create an exporter and access helper methods.
         */
        $exporter = new PrometheusRegistryExporter($this->policy(true), $this->registryWithSample(), new MetricsFS(sys_get_temp_dir() . '/export_' . uniqid()));

        $compile = new ReflectionMethod($exporter, 'compile');
        $compile->setAccessible(true);
        $match = new ReflectionMethod($exporter, 'match');
        $match->setAccessible(true);

        /*
         * Act: compile patterns and evaluate matches.
         */
        $patterns = $compile->invoke($exporter, ['[invalid']);
        $includeMiss = $match->invoke($exporter, 'metric', ['~^ok$~'], []);
        $excludeHit = $match->invoke($exporter, 'metric', [], ['~metric~']);
        $includeHit = $match->invoke($exporter, 'metric', ['~metric~'], []);

        /*
         * Assert: verify compiled patterns and match results.
         */
        $this->assertStringStartsWith('~', $patterns[0]);
        $this->assertFalse($includeMiss);
        $this->assertFalse($excludeHit);
        $this->assertTrue($includeHit);
    }

    /**
     * Ensures label mismatches throw a ValueError.
     */
    public function testEscapeAllLabelsThrowsOnMismatch(): void
    {
        /*
         * Arrange: create a metric with mismatched labels.
         */
        $exporter = new PrometheusRegistryExporter($this->policy(true), $this->registryWithSample(), new MetricsFS(sys_get_temp_dir() . '/export_' . uniqid()));
        $metric = new MetricFamilySamples([
            'name' => 'metric',
            'type' => 'counter',
            'help' => 'help',
            'labelNames' => ['a', 'b'],
            'samples' => [[
                'name' => 'metric',
                'labelNames' => [],
                'labelValues' => [],
                'value' => 1
            ]]
        ]);

        $method = new ReflectionMethod($exporter, 'escapeAllLabels');
        $method->setAccessible(true);

        /*
         * Act: invoke the label escape method and expect an exception.
         */
        $this->expectException(ValueError::class);
        $method->invoke($exporter, $metric, $metric->getLabelNames(), $metric->getSamples()[0]);

        /*
         * Assert: verify the ValueError is thrown.
         */
    }

    /**
     * Ensures ingestBatch skips non-matching metrics.
     */
    public function testIngestBatchSkipsNonMatchingMetrics(): void
    {
        /*
         * Arrange: create an exporter with a restrictive include filter.
         */
        $root = sys_get_temp_dir() . '/export_' . uniqid();
        $fs = new MetricsFS($root);
        $registry = new CollectorRegistry(new InMemory());
        $exporter = new PrometheusRegistryExporter($this->policy(true), $registry, $fs, [
            'include' => ['~^only_this$~'],
            'label_allow' => ['path']
        ]);

        $payload = [
            'other_metric' => [
                ['labels' => ['path' => '/api'], 'value' => 1]
            ]
        ];

        /*
         * Act: ingest the batch with a non-matching metric.
         */
        $exporter->ingestBatch($payload, 1000);

        /*
         * Assert: verify no files are created.
         */
        $this->assertSame([], glob($root . '/*'));
    }

    private function registryWithSample(): CollectorRegistry
    {
        $registry = $this->createMock(CollectorRegistry::class);
        $metric = new MetricFamilySamples([
            'name' => 'app_metric',
            'type' => 'counter',
            'help' => 'help',
            'labelNames' => ['path'],
            'samples' => [[
                'name' => 'app_metric',
                'labelNames' => [],
                'labelValues' => ["/api\n"],
                'value' => 1
            ]]
        ]);
        $registry->method('getMetricFamilySamples')->willReturn([$metric]);
        return $registry;
    }

    private function policy(bool $value): TimeWindowPolicy
    {
        return new class ($value) implements TimeWindowPolicy {
            public function __construct(private readonly bool $value)
            {
            }

            public function mustTrace(): bool
            {
                return $this->value;
            }
        };
    }
}
