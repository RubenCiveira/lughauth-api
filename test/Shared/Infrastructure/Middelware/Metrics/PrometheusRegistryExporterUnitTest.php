<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use Prometheus\CollectorRegistry;
use Prometheus\MetricFamilySamples;
use Prometheus\Storage\InMemory;
use Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\PrometheusRegistryExporter;
use Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\MetricsFS;
use Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\TimeWindowPolicy;

final class PrometheusRegistryExporterUnitTest extends TestCase
{
    public function testDumpSkipsWhenPolicyFalse(): void
    {
        $root = sys_get_temp_dir() . '/export_' . uniqid();
        $fs = new MetricsFS($root);
        $registry = new CollectorRegistry(new InMemory());
        $policy = $this->policy(false);

        $exporter = new PrometheusRegistryExporter($policy, $registry, $fs);
        $exporter->dump();

        $this->assertSame([], glob($root . '/*'));
    }

    public function testForceDumpWritesFiles(): void
    {
        $root = sys_get_temp_dir() . '/export_' . uniqid();
        $fs = new MetricsFS($root);
        $registry = $this->registryWithSample();
        $policy = $this->policy(true);

        $exporter = new PrometheusRegistryExporter($policy, $registry, $fs, [
            'include' => ['~^app_~'],
            'exclude' => ['~skip~'],
            'label_allow' => ['path']
        ]);

        $exporter->dump();

        $files = glob($root . '/app_metric/series/*/*/raw/*/*/*.jsonl');
        $this->assertNotEmpty($files);
    }

    public function testCompileAndMatch(): void
    {
        $exporter = new PrometheusRegistryExporter($this->policy(true), $this->registryWithSample(), new MetricsFS(sys_get_temp_dir() . '/export_' . uniqid()));

        $compile = new ReflectionMethod($exporter, 'compile');
        $compile->setAccessible(true);
        $match = new ReflectionMethod($exporter, 'match');
        $match->setAccessible(true);

        $patterns = $compile->invoke($exporter, ['[invalid']);
        $this->assertStringStartsWith('~', $patterns[0]);

        $this->assertFalse($match->invoke($exporter, 'metric', ['~^ok$~'], []));
        $this->assertFalse($match->invoke($exporter, 'metric', [], ['~metric~']));
        $this->assertTrue($match->invoke($exporter, 'metric', ['~metric~'], []));
    }

    public function testEscapeAllLabelsThrowsOnMismatch(): void
    {
        $exporter = new PrometheusRegistryExporter($this->policy(true), $this->registryWithSample(), new MetricsFS(sys_get_temp_dir() . '/export_' . uniqid()));
        $metric = new MetricFamilySamples([
            'name' => 'metric',
            'type' => 'counter',
            'help' => 'help',
            'labelNames' => ['a', 'b'],
            'samples' => [[
                'name' => 'metric',
                'labelNames' => [],
                'labelValues' => [],
                'value' => 1
            ]]
        ]);

        $method = new ReflectionMethod($exporter, 'escapeAllLabels');
        $method->setAccessible(true);

        $this->expectException(ValueError::class);
        $method->invoke($exporter, $metric, $metric->getLabelNames(), $metric->getSamples()[0]);
    }

    private function registryWithSample(): CollectorRegistry
    {
        $registry = $this->createMock(CollectorRegistry::class);
        $metric = new MetricFamilySamples([
            'name' => 'app_metric',
            'type' => 'counter',
            'help' => 'help',
            'labelNames' => ['path'],
            'samples' => [[
                'name' => 'app_metric',
                'labelNames' => [],
                'labelValues' => ["/api\n"],
                'value' => 1
            ]]
        ]);
        $registry->method('getMetricFamilySamples')->willReturn([$metric]);
        return $registry;
    }

    private function policy(bool $value): TimeWindowPolicy
    {
        return new class ($value) implements TimeWindowPolicy {
            public function __construct(private readonly bool $value)
            {
            }

            public function mustTrace(): bool
            {
                return $this->value;
            }
        };
    }
}
