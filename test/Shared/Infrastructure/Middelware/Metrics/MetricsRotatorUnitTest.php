<?php

/* @autogenerated */
declare(strict_types=1);

namespace {
    use PHPUnit\Framework\TestCase;
    use Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\MetricsRotator;
    use Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\FixedIntervalWindowPolicyTestHook;

    /**
     * Unit tests for MetricsRotator.
     */
    final class MetricsRotatorUnitTest extends TestCase
    {
        /**
         * Ensures rotation gzips and deletes old files.
         */
        public function testRotateMetricGzipsAndDeletes(): void
        {
            /*
             * Arrange: create a metrics file that should be rotated.
             */
            $root = sys_get_temp_dir() . '/rotator_' . uniqid();
            $metricDir = $root . '/metric/series/aa/bb/raw/2020/01';
            mkdir($metricDir, 0777, true);
            $oldFile = $metricDir . '/01.jsonl';
            file_put_contents($oldFile, "{}");

            /*
             * Act: rotate the metric files.
             */
            $rotator = new MetricsRotator($root, ['raw' => 1], true, ['raw']);
            $rotator->rotateMetric('metric');

            /*
             * Assert: verify the old file is removed.
             */
            $this->assertFalse(file_exists($oldFile));
        }

        /**
         * Ensures gzip is skipped for configured partitions.
         */
        public function testRotateMetricSkipsGzipPartition(): void
        {
            /*
             * Arrange: create a metrics file in a skipped partition.
             */
            $root = sys_get_temp_dir() . '/rotator_' . uniqid();
            $metricDir = $root . '/metric/series/aa/bb/raw/2020/01';
            mkdir($metricDir, 0777, true);
            $oldFile = $metricDir . '/01.jsonl';
            file_put_contents($oldFile, "{}");

            /*
             * Act: rotate the metric files with gzip skipped.
             */
            $rotator = new MetricsRotator($root, ['raw' => 9999], true, ['raw']);
            $rotator->rotateMetric('metric');

            /*
             * Assert: verify the original file remains.
             */
            $this->assertTrue(file_exists($oldFile));
        }

        /**
         * Ensures rotateAll works when no metrics are present.
         */
        public function testRotateAllSkipsMissingMetric(): void
        {
            /*
             * Arrange: create an empty metrics root.
             */
            $root = sys_get_temp_dir() . '/rotator_' . uniqid();
            mkdir($root, 0777, true);
            $rotator = new MetricsRotator($root, ['raw' => 1], false);

            /*
             * Act: rotate all metrics.
             */
            $rotator->rotateAll();

            /*
             * Assert: verify the root directory still exists.
             */
            $this->assertTrue(is_dir($root));
        }

        /**
         * Ensures rotateMetric skips when metric directory is missing.
         */
        public function testRotateMetricSkipsMissingMetricDir(): void
        {
            /*
             * Arrange: create an empty metrics root.
             */
            $root = sys_get_temp_dir() . '/rotator_' . uniqid();
            mkdir($root, 0777, true);
            $rotator = new MetricsRotator($root, ['raw' => 1], true);

            /*
             * Act: rotate a non-existing metric directory.
             */
            $rotator->rotateMetric('missing');

            /*
             * Assert: verify the root directory remains.
             */
            $this->assertTrue(is_dir($root));
        }

        /**
         * Ensures rotateMetric exits when the lock is held.
         */
        public function testRotateMetricSkipsWhenLockHeld(): void
        {
            /*
             * Arrange: create a metric directory and hold the lock file.
             */
            $root = sys_get_temp_dir() . '/rotator_' . uniqid();
            $metricDir = $root . '/metric/series/aa/bb/raw/2020/01';
            mkdir($metricDir, 0777, true);
            $oldFile = $metricDir . '/01.jsonl';
            file_put_contents($oldFile, "{}");

            $lockFile = $root . '/metric/.rotator.lock';
            $lockHandle = fopen($lockFile, 'c+');
            flock($lockHandle, LOCK_EX);

            /*
             * Act: attempt to rotate while the lock is held.
             */
            $rotator = new MetricsRotator($root, ['raw' => 1], true);
            $rotator->rotateMetric('metric');

            /*
             * Assert: verify the original file remains untouched.
             */
            $this->assertTrue(file_exists($oldFile));

            flock($lockHandle, LOCK_UN);
            fclose($lockHandle);
        }

        /**
         * Ensures gzip is skipped when gzip rotation is disabled.
         */
        public function testRotateMetricSkipsWhenGzipDisabled(): void
        {
            /*
             * Arrange: create an old metric file with gzip disabled.
             */
            $root = sys_get_temp_dir() . '/rotator_' . uniqid();
            $metricDir = $root . '/metric/series/aa/bb/raw/2020/01';
            mkdir($metricDir, 0777, true);
            $oldFile = $metricDir . '/01.jsonl';
            file_put_contents($oldFile, "{}");

            /*
             * Act: rotate with gzip disabled and long TTL.
             */
            $rotator = new MetricsRotator($root, ['raw' => 9999], false);
            $rotator->rotateMetric('metric');

            /*
             * Assert: verify the file is not gzipped or deleted.
             */
            $this->assertTrue(file_exists($oldFile));
            $this->assertFalse(file_exists($oldFile . '.gz'));
        }

        /**
         * Ensures gzipped files are not reprocessed.
         */
        public function testRotateMetricSkipsAlreadyGzippedFile(): void
        {
            /*
             * Arrange: create a pre-gzipped metric file.
             */
            $root = sys_get_temp_dir() . '/rotator_' . uniqid();
            $metricDir = $root . '/metric/series/aa/bb/raw/2020/01';
            mkdir($metricDir, 0777, true);
            $gzFile = $metricDir . '/01.jsonl.gz';
            file_put_contents($gzFile, "{}");

            /*
             * Act: rotate with long TTL to avoid deletion.
             */
            $rotator = new MetricsRotator($root, ['raw' => 9999], true);
            $rotator->rotateMetric('metric');

            /*
             * Assert: verify the gzipped file remains.
             */
            $this->assertTrue(file_exists($gzFile));
        }

        /**
         * Ensures invalid date files are not deleted when file dates are invalid.
         */
        public function testRotateMetricSkipsInvalidDateForDeletion(): void
        {
            /*
             * Arrange: create a metric file with an invalid date path.
             */
            $root = sys_get_temp_dir() . '/rotator_' . uniqid();
            $metricDir = $root . '/metric/series/aa/bb/raw/2020/13';
            mkdir($metricDir, 0777, true);
            $badFile = $metricDir . '/40.jsonl';
            file_put_contents($badFile, "{}");

            /*
             * Act: rotate with gzip disabled to hit the delete path only.
             */
            $rotator = new MetricsRotator($root, ['raw' => 1], false);
            $rotator->rotateMetric('metric');

            /*
             * Assert: verify the invalid date file remains.
             */
            $this->assertTrue(file_exists($badFile));
        }

        /**
         * Ensures invalid year directories are skipped.
         */
        public function testRotateMetricSkipsInvalidYearDirectory(): void
        {
            /*
             * Arrange: create a metric file under an invalid year directory.
             */
            $root = sys_get_temp_dir() . '/rotator_' . uniqid();
            $metricDir = $root . '/metric/series/aa/bb/raw/abcd/01';
            mkdir($metricDir, 0777, true);
            $badFile = $metricDir . '/01.jsonl';
            file_put_contents($badFile, "{}");

            /*
             * Act: rotate with gzip enabled and short TTL.
             */
            $rotator = new MetricsRotator($root, ['raw' => 1], true);
            $rotator->rotateMetric('metric');

            /*
             * Assert: verify the invalid year file remains.
             */
            $this->assertTrue(file_exists($badFile));
            $this->assertFalse(file_exists($badFile . '.gz'));
        }

        /**
         * Ensures invalid paths return null when extracting dates.
         */
        public function testExtractYmdInvalidPath(): void
        {
            /*
             * Arrange: create a rotator and access the private method.
             */
            $root = sys_get_temp_dir() . '/rotator_' . uniqid();
            $rotator = new MetricsRotator($root, ['raw' => 1], false);
            $method = new ReflectionMethod($rotator, 'extractYmdFromPath');
            $method->setAccessible(true);

            /*
             * Act: extract YMD from an invalid path.
             */
            $result = $method->invoke($rotator, '/invalid/path.jsonl');

            /*
             * Assert: verify null is returned.
             */
            $this->assertNull($result);
        }

        /**
         * Ensures gzip is skipped for today's files.
         */
        public function testRotateMetricSkipsTodayFile(): void
        {
            /*
             * Arrange: create a metrics file for today.
             */
            $today = new DateTimeImmutable('now', new DateTimeZone('UTC'));
            $root = sys_get_temp_dir() . '/rotator_' . uniqid();
            $metricDir = $root . '/metric/series/aa/bb/raw/' . $today->format('Y/m');
            mkdir($metricDir, 0777, true);
            $todayFile = $metricDir . '/' . $today->format('d') . '.jsonl';
            file_put_contents($todayFile, "{}");

            /*
             * Act: rotate the metric files.
             */
            $rotator = new MetricsRotator($root, ['raw' => 9999], true);
            $rotator->rotateMetric('metric');

            /*
             * Assert: verify today's file remains uncompressed.
             */
            $this->assertTrue(file_exists($todayFile));
            $this->assertFalse(file_exists($todayFile . '.gz'));
        }

        /**
         * Ensures gzip exits when date cannot be extracted.
         */
        public function testMaybeGzipSkipsWhenDateCannotBeExtracted(): void
        {
            /*
             * Arrange: access maybeGzip and use an invalid path.
             */
            $root = sys_get_temp_dir() . '/rotator_' . uniqid();
            $rotator = new MetricsRotator($root, ['raw' => 1], true);
            $method = new ReflectionMethod($rotator, 'maybeGzip');
            $method->setAccessible(true);

            /*
             * Act: invoke maybeGzip with an invalid path.
             */
            $method->invoke($rotator, $root . '/invalid.jsonl', 'raw');

            /*
             * Assert: verify no gzipped file is created.
             */
            $this->assertFalse(file_exists($root . '/invalid.jsonl.gz'));
        }

        /**
         * Ensures gzip exits when input file cannot be opened.
         */
        public function testMaybeGzipSkipsWhenFopenFails(): void
        {
            /*
             * Arrange: force fopen failure for a valid dated file.
             */
            $root = sys_get_temp_dir() . '/rotator_' . uniqid();
            $metricDir = $root . '/metric/series/aa/bb/raw/2020/01';
            mkdir($metricDir, 0777, true);
            $file = $metricDir . '/01.jsonl';
            file_put_contents($file, "{}");

            $rotator = new MetricsRotator($root, ['raw' => 1], true);
            $method = new ReflectionMethod($rotator, 'maybeGzip');
            $method->setAccessible(true);

            FixedIntervalWindowPolicyTestHook::$forceFopenFail = true;
            try {
                /*
                 * Act: invoke maybeGzip while fopen fails.
                 */
                $method->invoke($rotator, $file, 'raw');
            } finally {
                FixedIntervalWindowPolicyTestHook::$forceFopenFail = false;
            }

            /*
             * Assert: verify the file remains and no gzip is created.
             */
            $this->assertTrue(file_exists($file));
            $this->assertFalse(file_exists($file . '.gz'));
        }

        /**
         * Ensures gzip exits when output file cannot be opened.
         */
        public function testMaybeGzipSkipsWhenGzopenFails(): void
        {
            /*
             * Arrange: force gzopen failure for a valid dated file.
             */
            $root = sys_get_temp_dir() . '/rotator_' . uniqid();
            $metricDir = $root . '/metric/series/aa/bb/raw/2020/01';
            mkdir($metricDir, 0777, true);
            $file = $metricDir . '/01.jsonl';
            file_put_contents($file, "{}");

            $rotator = new MetricsRotator($root, ['raw' => 1], true);
            $method = new ReflectionMethod($rotator, 'maybeGzip');
            $method->setAccessible(true);

            FixedIntervalWindowPolicyTestHook::$forceGzopenFail = true;
            try {
                /*
                 * Act: invoke maybeGzip while gzopen fails.
                 */
                $method->invoke($rotator, $file, 'raw');
            } finally {
                FixedIntervalWindowPolicyTestHook::$forceGzopenFail = false;
            }

            /*
             * Assert: verify the file remains and no gzip is created.
             */
            $this->assertTrue(file_exists($file));
            $this->assertFalse(file_exists($file . '.gz'));
        }

        /**
         * Ensures gzip handles fread failures gracefully.
         */
        public function testMaybeGzipHandlesFreadFailure(): void
        {
            /*
             * Arrange: force fread failure during gzip.
             */
            $root = sys_get_temp_dir() . '/rotator_' . uniqid();
            $metricDir = $root . '/metric/series/aa/bb/raw/2020/01';
            mkdir($metricDir, 0777, true);
            $file = $metricDir . '/01.jsonl';
            file_put_contents($file, "{\"a\":1}");

            $rotator = new MetricsRotator($root, ['raw' => 1], true);
            $method = new ReflectionMethod($rotator, 'maybeGzip');
            $method->setAccessible(true);

            FixedIntervalWindowPolicyTestHook::$forceFreadFail = true;
            FixedIntervalWindowPolicyTestHook::$freadCalls = 0;

            /*
             * Act: invoke maybeGzip with a forced fread failure.
             */
            $method->invoke($rotator, $file, 'raw');

            /*
             * Assert: verify the original file is removed after gzip attempt.
             */
            $this->assertFalse(file_exists($file));
            $this->assertTrue(file_exists($file . '.gz'));
            $this->assertGreaterThanOrEqual(1, FixedIntervalWindowPolicyTestHook::$freadCalls);
        }

        /**
         * Ensures gzip writes data when fread returns chunks.
         */
        public function testMaybeGzipWritesDataWhenReadable(): void
        {
            /*
             * Arrange: create a valid dated file with content.
             */
            $root = sys_get_temp_dir() . '/rotator_' . uniqid();
            $metricDir = $root . '/metric/series/aa/bb/raw/2020/01';
            mkdir($metricDir, 0777, true);
            $file = $metricDir . '/01.jsonl';
            file_put_contents($file, "line1\nline2\n");

            $rotator = new MetricsRotator($root, ['raw' => 1], true);
            $method = new ReflectionMethod($rotator, 'maybeGzip');
            $method->setAccessible(true);

            /*
             * Act: invoke maybeGzip with normal read/write flow.
             */
            $method->invoke($rotator, $file, 'raw');

            /*
             * Assert: verify gzipped file is created with content.
             */
            $this->assertFalse(file_exists($file));
            $this->assertTrue(file_exists($file . '.gz'));
            $this->assertSame("line1\nline2\n", gzdecode((string) file_get_contents($file . '.gz')));
        }

        /**
         * Ensures deletion is skipped when TTL is not configured.
         */
        public function testMaybeDeleteSkipsWhenTtlMissing(): void
        {
            /*
             * Arrange: create a dated file with no TTL configured.
             */
            $root = sys_get_temp_dir() . '/rotator_' . uniqid();
            $metricDir = $root . '/metric/series/aa/bb/raw/2020/01';
            mkdir($metricDir, 0777, true);
            $file = $metricDir . '/01.jsonl';
            file_put_contents($file, "{}");

            $rotator = new MetricsRotator($root, [], false);
            $method = new ReflectionMethod($rotator, 'maybeDelete');
            $method->setAccessible(true);

            /*
             * Act: invoke maybeDelete without TTL configuration.
             */
            $method->invoke($rotator, $file, 'raw');

            /*
             * Assert: verify the file is not deleted.
             */
            $this->assertTrue(file_exists($file));
        }

        /**
         * Ensures deletion is skipped when date cannot be extracted.
         */
        public function testMaybeDeleteSkipsWhenDateCannotBeExtracted(): void
        {
            /*
             * Arrange: create a file with an invalid date path.
             */
            $root = sys_get_temp_dir() . '/rotator_' . uniqid();
            mkdir($root, 0777, true);
            $file = $root . '/invalid.jsonl';
            file_put_contents($file, "{}");
            $rotator = new MetricsRotator($root, ['raw' => 1], false);
            $method = new ReflectionMethod($rotator, 'maybeDelete');
            $method->setAccessible(true);

            /*
             * Act: invoke maybeDelete with an invalid path.
             */
            $method->invoke($rotator, $file, 'raw');

            /*
             * Assert: verify the file remains.
             */
            $this->assertTrue(file_exists($file));
        }

        /**
         * Ensures deletion is skipped when file date is invalid.
         */
        public function testMaybeDeleteSkipsWhenFileDateInvalid(): void
        {
            /*
             * Arrange: create a file with invalid date values.
             */
            $root = sys_get_temp_dir() . '/rotator_' . uniqid();
            $metricDir = $root . '/metric/series/aa/bb/raw/2099/19';
            mkdir($metricDir, 0777, true);
            $file = $metricDir . '/39.jsonl';
            file_put_contents($file, "{}");

            $rotator = new MetricsRotator($root, ['raw' => 1], false);
            $method = new ReflectionMethod($rotator, 'maybeDelete');
            $method->setAccessible(true);

            /*
             * Act: invoke maybeDelete with invalid date components.
             */
            $method->invoke($rotator, $file, 'raw');

            /*
             * Assert: verify the file remains.
             */
            $this->assertTrue(file_exists($file));
        }


        /**
         * Ensures pruneEmptyDirs keeps the root directory.
         */
        public function testPruneEmptyDirsKeepsRoot(): void
        {
            /*
             * Arrange: create a root with an empty child directory.
             */
            $root = sys_get_temp_dir() . '/rotator_' . uniqid();
            $child = $root . '/metric/series/aa/bb/raw';
            mkdir($child, 0777, true);

            $rotator = new MetricsRotator($root, ['raw' => 1], false);
            $method = new ReflectionMethod($rotator, 'pruneEmptyDirs');
            $method->setAccessible(true);

            /*
             * Act: prune empty directories.
             */
            $method->invoke($rotator, $root);

            /*
             * Assert: verify the root directory is preserved.
             */
            $this->assertTrue(is_dir($root));
        }

        /**
         * Ensures prune skips the root while removing empty children.
         */
        public function testPruneEmptyDirsSkipsRootDirectory(): void
        {
            /*
             * Arrange: create a root with an empty child directory.
             */
            $root = sys_get_temp_dir() . '/rotator_' . uniqid();
            $child = $root . '/metric/series/aa/bb/raw/2020/01';
            mkdir($child, 0777, true);

            $rotator = new MetricsRotator($root, ['raw' => 1], false);
            $method = new ReflectionMethod($rotator, 'pruneEmptyDirs');
            $method->setAccessible(true);

            /*
             * Act: prune empty directories.
             */
            $method->invoke($rotator, $root);

            /*
             * Assert: verify the root remains and the child is removed.
             */
            $this->assertTrue(is_dir($root));
            $this->assertFalse(is_dir($child));
        }

    }
}
