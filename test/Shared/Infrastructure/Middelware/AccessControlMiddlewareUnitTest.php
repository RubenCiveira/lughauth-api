<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use Psr\Http\Client\ClientInterface;
use Psr\Http\Message\RequestFactoryInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Message\StreamFactoryInterface;
use Psr\Http\Message\UriInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Psr\SimpleCache\CacheInterface;
use Slim\App;
use Slim\Psr7\Response;
use Symfony\Component\Yaml\Yaml;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Context;
use Civi\Lughauth\Shared\Security\Connection;
use Civi\Lughauth\Shared\Security\Identity;
use Civi\Lughauth\Shared\Infrastructure\Middelware\AccessControlMiddleware;
use Civi\Lughauth\Shared\Exception\UnauthorizedException;

final class AccessControlMiddlewareUnitTest extends TestCase
{
    public function testNoRulePasses(): void
    {
        $middleware = $this->middleware([]);
        $response = $middleware($this->request('/api/open'), $this->handler());

        $this->assertSame(200, $response->getStatusCode());
    }

    public function testAnonymousDenied(): void
    {
        $middleware = $this->middleware([
            '/secure' => ['anonimous' => false]
        ], new Identity(true));

        $response = $middleware($this->request('/api/secure'), $this->handler());
        $this->assertSame(401, $response->getStatusCode());
    }

    public function testRoleDenied(): void
    {
        $middleware = $this->middleware([
            '/roles' => ['roles' => ['admin']]
        ], new Identity(false, roles: ['user']));

        $response = $middleware($this->request('/api/roles'), $this->handler());
        $this->assertSame(403, $response->getStatusCode());
    }

    public function testGroupDenied(): void
    {
        $middleware = $this->middleware([
            '/groups' => ['groups' => ['admins']]
        ], new Identity(false, groups: ['users']));

        $response = $middleware($this->request('/api/groups'), $this->handler());
        $this->assertSame(403, $response->getStatusCode());
    }

    public function testScopeDenied(): void
    {
        $identity = new Identity(false);
        $middleware = $this->middleware([
            '/scopes' => ['scopes' => ['write']]
        ], $identity);

        $response = $middleware($this->request('/api/scopes'), $this->handler());
        $this->assertSame(403, $response->getStatusCode());
    }

    public function testApiKeyMissingDenied(): void
    {
        $middleware = $this->middleware([
            '/apikey' => ['api-key-scope' => 'scope']
        ]);

        $response = $middleware($this->request('/api/apikey'), $this->handler());
        $this->assertSame(401, $response->getStatusCode());
    }

    public function testApiKeyInvalidScopeThrows(): void
    {
        $cache = new InMemoryCache(['api-key-verify--key' => json_encode(['scopes' => ['other']])]);
        $middleware = $this->middleware([
            '/apikey' => ['api-key-scope' => 'scope']
        ], new Identity(false), $cache);

        $request = $this->request('/api/apikey', ['x-api-key' => 'key']);

        $this->expectException(UnauthorizedException::class);
        $middleware($request, $this->handler());
    }

    public function testApiKeyValidPasses(): void
    {
        $cache = new InMemoryCache(['api-key-verify--key' => json_encode(['scopes' => ['scope']])]);
        $middleware = $this->middleware([
            '/apikey' => ['api-key-scope' => 'scope']
        ], new Identity(false), $cache);

        $request = $this->request('/api/apikey', ['x-api-key' => 'key']);

        $response = $middleware($request, $this->handler());
        $this->assertSame(200, $response->getStatusCode());
    }

    public function testCidrDenied(): void
    {
        $connection = new class () extends Connection {
            public function __construct()
            {
                parent::__construct(true, new DateTime(), 'app', '/', '127.0.0.1', 'host', 'en');
            }

            public function inRange(string $cidr): bool
            {
                return false;
            }
        };
        $middleware = $this->middleware([
            '/cidr' => ['cidr' => ['10.0.0.0/8']]
        ], new Identity(false), null, $connection);

        $response = $middleware($this->request('/api/cidr'), $this->handler());
        $this->assertSame(403, $response->getStatusCode());
    }

    public function testCidrAllowed(): void
    {
        $connection = new class () extends Connection {
            public function __construct()
            {
                parent::__construct(true, new DateTime(), 'app', '/', '10.0.0.1', 'host', 'en');
            }

            public function inRange(string $cidr): bool
            {
                return true;
            }
        };
        $middleware = $this->middleware([
            '/cidr' => ['cidr' => ['10.0.0.0/8']]
        ], new Identity(false), null, $connection);

        $response = $middleware($this->request('/api/cidr'), $this->handler());
        $this->assertSame(200, $response->getStatusCode());
    }

    public function testScopeAllowed(): void
    {
        $identity = new Identity(false, scope: 'write');
        $middleware = $this->middleware([
            '/scopes' => ['scopes' => ['write']]
        ], $identity);

        $response = $middleware($this->request('/api/scopes'), $this->handler());
        $this->assertSame(200, $response->getStatusCode());
    }

    public function testApiKeyRequestFailsOnNon200(): void
    {
        $cache = new InMemoryCache();
        $response = $this->createMock(\Psr\Http\Message\ResponseInterface::class);
        $response->method('getStatusCode')->willReturn(500);
        $response->method('getBody')->willReturn($this->stream(''));

        $client = $this->createMock(ClientInterface::class);
        $client->method('sendRequest')->willReturn($response);

        $middleware = $this->middleware([
            '/apikey' => ['api-key-scope' => 'scope']
        ], new Identity(false), $cache, null, $client);

        $request = $this->request('/api/apikey', ['x-api-key' => 'key']);

        $this->expectException(UnauthorizedException::class);
        $middleware($request, $this->handler());
    }

    public function testApiKeyRequestCachesSuccess(): void
    {
        $cache = new InMemoryCache();
        $response = $this->createMock(\Psr\Http\Message\ResponseInterface::class);
        $response->method('getStatusCode')->willReturn(200);
        $response->method('getBody')->willReturn($this->stream(json_encode(['scopes' => ['scope']])));

        $client = $this->createMock(ClientInterface::class);
        $client->method('sendRequest')->willReturn($response);

        $middleware = $this->middleware([
            '/apikey' => ['api-key-scope' => 'scope']
        ], new Identity(false), $cache, null, $client);

        $request = $this->request('/api/apikey', ['x-api-key' => 'key']);

        $response = $middleware($request, $this->handler());
        $this->assertSame(200, $response->getStatusCode());
        $this->assertTrue($cache->has('api-key-verify--key'));
    }

    private function middleware(array $rules, ?Identity $identity = null, ?CacheInterface $cache = null, ?Connection $connection = null, ?ClientInterface $client = null): AccessControlMiddleware
    {
        $rulesFile = sys_get_temp_dir() . '/rules_' . uniqid() . '.yaml';
        file_put_contents($rulesFile, Yaml::dump($rules));

        $app = $this->createMock(App::class);
        $app->method('getBasePath')->willReturn('/api');

        $context = $this->createMock(Context::class);
        $context->method('getIdentity')->willReturn($identity ?? new Identity(false));
        $context->method('getConnection')->willReturn($connection ?? new Connection(true, new DateTime(), 'app', '/', '127.0.0.1', 'host', 'en'));

        $config = $this->createMock(AppConfig::class);
        $cache = $cache ?? new InMemoryCache();
        $requestFactory = $this->createMock(RequestFactoryInterface::class);
        $request = $this->createMock(\Psr\Http\Message\RequestInterface::class);
        $request->method('withHeader')->willReturnSelf();
        $request->method('withBody')->willReturnSelf();
        $requestFactory->method('createRequest')->willReturn($request);
        $client = $client ?? $this->createMock(ClientInterface::class);
        $streamFactory = $this->createMock(StreamFactoryInterface::class);
        $streamFactory->method('createStream')->willReturn($this->stream(''));

        return new AccessControlMiddleware($app, $context, $config, $cache, $requestFactory, $client, $streamFactory, $rulesFile);
    }

    private function request(string $path, array $headers = []): ServerRequestInterface
    {
        $uri = $this->createMock(UriInterface::class);
        $uri->method('getPath')->willReturn($path);

        $request = $this->createMock(ServerRequestInterface::class);
        $request->method('getUri')->willReturn($uri);
        $request->method('getHeaderLine')->willReturnCallback(function (string $name) use ($headers) {
            return $headers[$name] ?? '';
        });
        return $request;
    }

    private function handler(): RequestHandlerInterface
    {
        return new class () implements RequestHandlerInterface {
            public function handle(ServerRequestInterface $request): \Psr\Http\Message\ResponseInterface
            {
                return new Response(200);
            }
        };
    }

    private function stream(string $contents): \Psr\Http\Message\StreamInterface
    {
        $stream = (new \Slim\Psr7\Factory\StreamFactory())->createStream($contents);
        return $stream;
    }
}

final class InMemoryCache implements CacheInterface
{
    public function __construct(private array $values = [])
    {
    }

    public function get(string $key, mixed $default = null): mixed
    {
        return $this->values[$key] ?? $default;
    }

    public function set(string $key, mixed $value, null|int|DateInterval $ttl = null): bool
    {
        $this->values[$key] = $value;
        return true;
    }

    public function delete(string $key): bool
    {
        unset($this->values[$key]);
        return true;
    }

    public function clear(): bool
    {
        $this->values = [];
        return true;
    }

    public function getMultiple(iterable $keys, mixed $default = null): iterable
    {
        $result = [];
        foreach ($keys as $key) {
            $result[$key] = $this->get($key, $default);
        }
        return $result;
    }

    public function setMultiple(iterable $values, null|int|DateInterval $ttl = null): bool
    {
        foreach ($values as $key => $value) {
            $this->set($key, $value, $ttl);
        }
        return true;
    }

    public function deleteMultiple(iterable $keys): bool
    {
        foreach ($keys as $key) {
            $this->delete($key);
        }
        return true;
    }

    public function has(string $key): bool
    {
        return array_key_exists($key, $this->values);
    }
}
