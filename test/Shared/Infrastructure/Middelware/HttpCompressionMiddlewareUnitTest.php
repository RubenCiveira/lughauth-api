<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use Slim\Psr7\Response;
use Slim\Psr7\Factory\StreamFactory;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Civi\Lughauth\Shared\Infrastructure\Middelware\HttpCompressionMiddleware;

/**
 * Unit tests for HttpCompressionMiddleware.
 */
final class HttpCompressionMiddlewareUnitTest extends TestCase
{
    /**
     * Ensures 304 is returned when ETag matches.
     */
    public function testReturnsNotModified(): void
    {
        /*
         * Arrange: build a middleware and an ETag-matching request.
         */
        $middleware = new HttpCompressionMiddleware();
        $etag = '"' . sha1('body') . '"';

        $request = $this->request(['If-None-Match' => $etag]);
        $handler = $this->handler('body');

        /*
         * Act: handle the request through the middleware.
         */
        $response = $middleware($request, $handler);

        /*
         * Assert: verify the response is not modified.
         */
        $this->assertSame(304, $response->getStatusCode());
        $this->assertSame('0', $response->getHeaderLine('Content-Length'));
    }

    /**
     * Ensures gzip compression is applied when supported.
     */
    public function testGzipCompression(): void
    {
        /*
         * Arrange: build a request that accepts gzip encoding.
         */
        $middleware = new HttpCompressionMiddleware();
        $request = $this->request(['Accept-Encoding' => 'gzip']);
        $handler = $this->handler('body');

        /*
         * Act: handle the request through the middleware.
         */
        $response = $middleware($request, $handler);

        /*
         * Assert: verify the response is gzip-compressed.
         */
        $this->assertSame('gzip', $response->getHeaderLine('Content-Encoding'));
        $this->assertNotEmpty((string) $response->getBody());
    }

    /**
     * Ensures extra output is included when building the payload length.
     */
    public function testIncludesExtraOutputInContentLength(): void
    {
        /*
         * Arrange: build a handler that echoes extra output before returning a body.
         */
        $middleware = new HttpCompressionMiddleware();
        $request = $this->request(['Accept-Encoding' => 'identity']);
        $handler = new class () implements RequestHandlerInterface {
            public function handle(ServerRequestInterface $request): \Psr\Http\Message\ResponseInterface
            {
                echo 'extra';
                $response = new Response();
                $stream = (new StreamFactory())->createStream('body');
                return $response->withBody($stream);
            }
        };

        /*
         * Act: handle the request through the middleware.
         */
        $response = $middleware($request, $handler);

        /*
         * Assert: verify Content-Length includes extra output and body.
         */
        $this->assertSame((string) strlen('extrabody'), $response->getHeaderLine('Content-Length'));
    }

    /**
     * Ensures non-gzip encodings set content length without compression.
     */
    public function testAcceptEncodingWithoutGzipSetsContentLength(): void
    {
        /*
         * Arrange: build a request that does not accept gzip.
         */
        $middleware = new HttpCompressionMiddleware();
        $request = $this->request(['Accept-Encoding' => 'br']);
        $handler = $this->handler('plain');

        /*
         * Act: handle the request through the middleware.
         */
        $response = $middleware($request, $handler);

        /*
         * Assert: verify Content-Encoding is empty and length is set.
         */
        $this->assertSame('', $response->getHeaderLine('Content-Encoding'));
        $this->assertSame((string) strlen('plain'), $response->getHeaderLine('Content-Length'));
    }

    private function request(array $headers): ServerRequestInterface
    {
        $request = $this->createMock(ServerRequestInterface::class);
        $request->method('getHeaderLine')->willReturnCallback(function (string $name) use ($headers) {
            return $headers[$name] ?? '';
        });
        return $request;
    }

    private function handler(string $body): RequestHandlerInterface
    {
        return new class ($body) implements RequestHandlerInterface {
            public function __construct(private readonly string $body)
            {
            }

            public function handle(ServerRequestInterface $request): \Psr\Http\Message\ResponseInterface
            {
                $response = new Response();
                $stream = (new StreamFactory())->createStream($this->body);
                return $response->withBody($stream);
            }
        };
    }
}
