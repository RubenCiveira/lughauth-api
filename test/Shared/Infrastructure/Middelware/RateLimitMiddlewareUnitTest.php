<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use Psr\Container\ContainerInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Symfony\Component\RateLimiter\Storage\InMemoryStorage;
use Slim\Psr7\Response;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Infrastructure\Middelware\RateLimitMiddleware;
use Civi\Lughauth\Shared\Infrastructure\Middelware\Rate\RateConfig;
use Civi\Lughauth\Shared\Infrastructure\Middelware\Rate\BucketResolverInterface;
use Civi\Lughauth\Shared\Infrastructure\Middelware\Rate\ConnectionResolverInterface;

/**
 * Unit tests for RateLimitMiddleware.
 */
final class RateLimitMiddlewareUnitTest extends TestCase
{
    /**
     * Ensures requests are allowed then rejected when limits are exceeded.
     */
    public function testAllowsAndRejects(): void
    {
        /*
         * Arrange: configure a rate limiter with a single allowed request.
         */
        $storage = new InMemoryStorage();
        $config = new class () extends AppConfig {
            public function __construct()
            {
                $this->develop = true;
                $this->name = 'app';
                $this->managementEndpoint = '/management';
            }

            public function get(string $name, mixed $def = null): mixed
            {
                return match ($name) {
                    'app.rate-limit.limit' => 1,
                    'app.rate-limit.interval' => '1 minute',
                    default => $def,
                };
            }
        };
        $rateConfig = new RateConfig($storage, $config);

        $bucket = new class () implements BucketResolverInterface {
            public function resolve(ServerRequestInterface $request): string
            {
                return 'bucket';
            }
        };
        $connection = new class () implements ConnectionResolverInterface {
            public function resolve(ServerRequestInterface $request): string
            {
                return 'conn';
            }
        };

        $container = $this->createMock(ContainerInterface::class);
        $container->method('get')->willReturnMap([
            [$rateConfig->bucketResolverType, $bucket],
            [$rateConfig->connectionResolverType, $connection]
        ]);

        $middleware = new RateLimitMiddleware($container, $rateConfig);
        $request = $this->createMock(ServerRequestInterface::class);
        $handler = new class () implements RequestHandlerInterface {
            public function handle(ServerRequestInterface $request): \Psr\Http\Message\ResponseInterface
            {
                return new Response(200);
            }
        };

        /*
         * Act: send two requests through the middleware.
         */
        $response = $middleware($request, $handler);
        $remaining = $response->getHeaderLine('X-RateLimit-Remaining');

        $response = $middleware($request, $handler);
        $status = $response->getStatusCode();

        /*
         * Assert: verify the first request is allowed and the second is rejected.
         */
        $this->assertSame('0', $remaining);
        $this->assertSame(429, $status);
    }

    /**
     * Ensures no bucket skips rate limiting.
     */
    public function testNoBucketSkipsLimiter(): void
    {
        /*
         * Arrange: configure bucket resolver to return an empty key.
         */
        $storage = new InMemoryStorage();
        $config = new class () extends AppConfig {
            public function __construct()
            {
                $this->develop = true;
                $this->name = 'app';
                $this->managementEndpoint = '/management';
            }

            public function get(string $name, mixed $def = null): mixed
            {
                return $def;
            }
        };
        $rateConfig = new RateConfig($storage, $config);

        $bucket = new class () implements BucketResolverInterface {
            public function resolve(ServerRequestInterface $request): string
            {
                return '';
            }
        };
        $connection = new class () implements ConnectionResolverInterface {
            public function resolve(ServerRequestInterface $request): string
            {
                return 'conn';
            }
        };

        $container = $this->createMock(ContainerInterface::class);
        $container->method('get')->willReturnMap([
            [$rateConfig->bucketResolverType, $bucket],
            [$rateConfig->connectionResolverType, $connection]
        ]);

        $middleware = new RateLimitMiddleware($container, $rateConfig);
        $request = $this->createMock(ServerRequestInterface::class);
        $handler = new class () implements RequestHandlerInterface {
            public function handle(ServerRequestInterface $request): \Psr\Http\Message\ResponseInterface
            {
                return new Response(200);
            }
        };

        /*
         * Act: send a request through the middleware.
         */
        $response = $middleware($request, $handler);

        /*
         * Assert: verify the request is allowed.
         */
        $this->assertSame(200, $response->getStatusCode());
    }
}
