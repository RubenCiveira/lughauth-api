<?php

/* @autogenerated */
declare(strict_types=1);

namespace {
    use PHPUnit\Framework\TestCase;
    use Civi\Lughauth\Shared\Infrastructure\Sql\SqlParam;
    use Civi\Lughauth\Shared\Infrastructure\Sql\SqlTemplate;
    use Civi\Lughauth\Shared\Exception\NotUniqueException;
    use Civi\Lughauth\Shared\Exception\NotEmptyChildsException;

    /**
     * Unit tests for {@see SqlTemplate}.
     */
    final class SqlTemplateTest extends TestCase
    {
        /**
         * Ensures transaction lifecycle methods call PDO correctly.
         */
        public function testTransactionLifecycleMethods(): void
        {
            /*
             * Arrange: build a PDO mock with inTransaction sequencing.
             */
            $pdo = $this->createMock(PDO::class);
            $pdo->expects($this->once())->method('beginTransaction')->willReturn(true);
            $pdo->expects($this->once())->method('commit')->willReturn(true);
            $pdo->expects($this->once())->method('rollBack')->willReturn(true);
            $pdo->expects($this->exactly(3))
                ->method('inTransaction')
                ->willReturnOnConsecutiveCalls(true, true, false);
            $template = new SqlTemplate($pdo);

            /*
             * Act: begin, commit, rollback, and close in sequence.
             */
            $template->begin();
            $template->commit();
            $template->rollback();
            $template->close();

            /*
             * Assert: verify calls are issued for active transactions.
             */
            $this->assertTrue(true);
        }

        /**
         * Ensures close rolls back when a transaction is active.
         */
        public function testCloseRollsBackWhenTransactionActive(): void
        {
            /*
             * Arrange: build a PDO mock reporting an active transaction.
             */
            $pdo = $this->createMock(PDO::class);
            $pdo->expects($this->once())->method('rollBack')->willReturn(true);
            $pdo->expects($this->once())->method('inTransaction')->willReturn(true);
            $template = new SqlTemplate($pdo);

            /*
             * Act: close the template while in a transaction.
             */
            $template->close();

            /*
             * Assert: verify rollback is invoked for the active transaction.
             */
            $this->assertTrue(true);
        }

        /**
         * Ensures integer and boolean values are escaped as numeric strings.
         */
        public function testEscapeValueCastsIntAndBool(): void
        {
            /*
             * Arrange: build a template with a PDO mock.
             */
            $pdo = $this->createMock(PDO::class);
            $pdo->method('quote')->willReturn("'0'");
            $template = new SqlTemplate($pdo);

            /*
             * Act: escape integer and boolean values.
             */
            $intValue = $template->escapeValue(12, SqlParam::INT);
            $boolValue = $template->escapeValue(true, SqlParam::BOOL);

            /*
             * Assert: verify numeric string output.
             */
            $this->assertSame('12', $intValue);
            $this->assertSame('1', $boolValue);
        }

        /**
         * Ensures string values are escaped using PDO::quote.
         */
        public function testEscapeValueQuotesStrings(): void
        {
            /*
             * Arrange: build a template with a PDO mock.
             */
            $pdo = $this->createMock(PDO::class);
            $pdo->method('quote')->willReturn("'alpha'");
            $template = new SqlTemplate($pdo);

            /*
             * Act: escape a string value.
             */
            $value = $template->escapeValue('alpha', SqlParam::STR);

            /*
             * Assert: verify quoted output.
             */
            $this->assertSame("'alpha'", $value);
        }

        /**
         * Ensures execute returns true when rows are affected.
         */
        public function testExecuteReturnsTrueWhenRowCountPositive(): void
        {
            /*
             * Arrange: build a template with a statement that affects rows.
             */
            $stmt = $this->createMock(PDOStatement::class);
            $stmt->method('execute')->willReturn(true);
            $stmt->method('rowCount')->willReturn(2);

            $pdo = $this->createMock(PDO::class);
            $pdo->method('getAttribute')->willReturn('sqlite');
            $pdo->method('prepare')->willReturn($stmt);
            $template = new SqlTemplate($pdo);

            /*
             * Act: execute a statement.
             */
            $result = $template->execute('UPDATE test SET a = :a', ['a' => 1]);

            /*
             * Assert: verify a successful result.
             */
            $this->assertTrue($result);
        }

        /**
         * Ensures execute returns false when no rows are affected.
         */
        public function testExecuteReturnsFalseWhenRowCountZero(): void
        {
            /*
             * Arrange: build a template with a statement that affects no rows.
             */
            $stmt = $this->createMock(PDOStatement::class);
            $stmt->method('execute')->willReturn(true);
            $stmt->method('rowCount')->willReturn(0);

            $pdo = $this->createMock(PDO::class);
            $pdo->method('getAttribute')->willReturn('sqlite');
            $pdo->method('prepare')->willReturn($stmt);
            $template = new SqlTemplate($pdo);

            /*
             * Act: execute a statement.
             */
            $result = $template->execute('UPDATE test SET a = :a', ['a' => 1]);

            /*
             * Assert: verify a false result.
             */
            $this->assertFalse($result);
        }

        /**
         * Ensures execute throws a TypeError when execution fails.
         */
        public function testExecuteThrowsTypeErrorWhenExecuteFails(): void
        {
            /*
             * Arrange: build a template with a statement that fails to execute.
             */
            $stmt = $this->createMock(PDOStatement::class);
            $stmt->method('execute')->willReturn(false);

            $pdo = $this->createMock(PDO::class);
            $pdo->method('getAttribute')->willReturn('sqlite');
            $pdo->method('prepare')->willReturn($stmt);
            $template = new SqlTemplate($pdo);

            /*
             * Act: execute a statement.
             */
            $this->expectException(\TypeError::class);
            $template->execute('UPDATE test SET a = :a', ['a' => 1]);

            /*
             * Assert: verify the TypeError is raised.
             */
            $this->assertTrue(true);
        }

        /**
         * Ensures duplicate key exceptions are mapped for MySQL.
         */
        public function testExecuteThrowsNotUniqueExceptionForMysql(): void
        {
            /*
             * Arrange: build a template with a MySQL driver and duplicate error.
             */
            $stmt = $this->createMock(PDOStatement::class);
            $exception = new PDOException('duplicate');
            $exception->errorInfo = [23000, 1062, 'duplicate'];
            $stmt->method('execute')->willThrowException($exception);

            $pdo = $this->createMock(PDO::class);
            $pdo->method('getAttribute')->willReturn('mysql');
            $pdo->method('prepare')->willReturn($stmt);
            $template = new SqlTemplate($pdo);

            /*
             * Act: execute a statement that throws a duplicate exception.
             */
            $this->expectException(NotUniqueException::class);
            $template->execute('INSERT INTO test(a) VALUES (:a)', ['a' => 1]);

            /*
             * Assert: verify the exception type is mapped.
             */
            $this->assertTrue(true);
        }

        /**
         * Ensures foreign key exceptions are mapped for MySQL.
         */
        public function testExecuteThrowsNotEmptyChildsExceptionForMysql(): void
        {
            /*
             * Arrange: build a template with a MySQL driver and FK error.
             */
            $stmt = $this->createMock(PDOStatement::class);
            $exception = new PDOException('fk');
            $exception->errorInfo = [23000, 1451, 'fk'];
            $stmt->method('execute')->willThrowException($exception);

            $pdo = $this->createMock(PDO::class);
            $pdo->method('getAttribute')->willReturn('mysql');
            $pdo->method('prepare')->willReturn($stmt);
            $template = new SqlTemplate($pdo);

            /*
             * Act: execute a statement that throws a FK exception.
             */
            $this->expectException(NotEmptyChildsException::class);
            $template->execute('DELETE FROM test WHERE id = :id', ['id' => 1]);

            /*
             * Assert: verify the exception type is mapped.
             */
            $this->assertTrue(true);
        }

        /**
         * Ensures non-MySQL errors are rethrown as PDOException.
         */
        public function testExecuteRethrowsForNonMysql(): void
        {
            /*
             * Arrange: build a template with a non-MySQL driver and error.
             */
            $stmt = $this->createMock(PDOStatement::class);
            $exception = new PDOException('generic');
            $exception->errorInfo = [99999, 99999, 'generic'];
            $stmt->method('execute')->willThrowException($exception);

            $pdo = $this->createMock(PDO::class);
            $pdo->method('getAttribute')->willReturn('sqlite');
            $pdo->method('prepare')->willReturn($stmt);
            $template = new SqlTemplate($pdo);

            /*
             * Act: execute a statement that throws a generic exception.
             */
            $this->expectException(PDOException::class);
            $template->execute('UPDATE test SET a = :a', ['a' => 1]);

            /*
             * Assert: verify the exception is rethrown.
             */
            $this->assertTrue(true);
        }

        /**
         * Ensures query returns mapped rows when a closure is provided.
         */
        public function testQueryReturnsMappedRows(): void
        {
            /*
             * Arrange: build a template with rows to fetch.
             */
            $stmt = $this->createMock(PDOStatement::class);
            $stmt->method('execute')->willReturn(true);
            $stmt->method('fetch')->willReturnOnConsecutiveCalls(
                ['id' => 1, 'name' => 'a'],
                ['id' => 2, 'name' => 'b'],
                false
            );

            $pdo = $this->createMock(PDO::class);
            $pdo->method('getAttribute')->willReturn('sqlite');
            $pdo->method('prepare')->willReturn($stmt);
            $template = new SqlTemplate($pdo);

            /*
             * Act: query and map rows to ids.
             */
            $result = $template->query('SELECT id, name FROM test', [], fn ($row) => $row['id']);

            /*
             * Assert: verify mapped values are returned.
             */
            $this->assertSame([1, 2], $result);
        }

        /**
         * Ensures queryForUpdate returns rows without a closure.
         */
        public function testQueryForUpdateReturnsRowsWithoutClosure(): void
        {
            /*
             * Arrange: build a template with rows to fetch.
             */
            $stmt = $this->createMock(PDOStatement::class);
            $stmt->method('execute')->willReturn(true);
            $stmt->method('fetch')->willReturnOnConsecutiveCalls(
                ['id' => 3],
                false
            );

            $pdo = $this->createMock(PDO::class);
            $pdo->method('getAttribute')->willReturn('sqlite');
            $pdo->method('prepare')->willReturn($stmt);
            $template = new SqlTemplate($pdo);

            /*
             * Act: query for update without a closure.
             */
            $result = $template->queryForUpdate('SELECT id FROM test FOR UPDATE', []);

            /*
             * Assert: verify the raw row is returned.
             */
            $this->assertSame([['id' => 3]], $result);
        }

        /**
         * Ensures findOne returns a mapped row.
         */
        public function testFindOneReturnsMappedRow(): void
        {
            /*
             * Arrange: build a template with a single row.
             */
            $stmt = $this->createMock(PDOStatement::class);
            $stmt->method('execute')->willReturn(true);
            $stmt->method('fetch')->willReturnOnConsecutiveCalls(['id' => 7, 'name' => 'x'], false);

            $pdo = $this->createMock(PDO::class);
            $pdo->method('getAttribute')->willReturn('sqlite');
            $pdo->method('prepare')->willReturn($stmt);
            $template = new SqlTemplate($pdo);

            /*
             * Act: find one row with a closure.
             */
            $result = $template->findOne('SELECT id FROM test WHERE id = :id', ['id' => 7], fn ($row) => $row['name']);

            /*
             * Assert: verify mapped value is returned.
             */
            $this->assertSame('x', $result);
        }

        /**
         * Ensures findOne returns null when no row exists.
         */
        public function testFindOneReturnsNullWhenNoRow(): void
        {
            /*
             * Arrange: build a template with no rows.
             */
            $stmt = $this->createMock(PDOStatement::class);
            $stmt->method('execute')->willReturn(true);
            $stmt->method('fetch')->willReturn(false);

            $pdo = $this->createMock(PDO::class);
            $pdo->method('getAttribute')->willReturn('sqlite');
            $pdo->method('prepare')->willReturn($stmt);
            $template = new SqlTemplate($pdo);

            /*
             * Act: attempt to find a row.
             */
            $result = $template->findOne('SELECT id FROM test WHERE id = :id', ['id' => 1]);

            /*
             * Assert: verify null is returned.
             */
            $this->assertNull($result);
        }

        /**
         * Ensures findOneForUpdate returns rows without a closure.
         */
        public function testFindOneForUpdateReturnsRowWithoutClosure(): void
        {
            /*
             * Arrange: build a template with a single row.
             */
            $stmt = $this->createMock(PDOStatement::class);
            $stmt->method('execute')->willReturn(true);
            $stmt->method('fetch')->willReturnOnConsecutiveCalls(['id' => 9], false);

            $pdo = $this->createMock(PDO::class);
            $pdo->method('getAttribute')->willReturn('sqlite');
            $pdo->method('prepare')->willReturn($stmt);
            $template = new SqlTemplate($pdo);

            /*
             * Act: find one row for update without a closure.
             */
            $result = $template->findOneForUpdate('SELECT id FROM test WHERE id = :id FOR UPDATE', ['id' => 9]);

            /*
             * Assert: verify the raw row is returned.
             */
            $this->assertSame(['id' => 9], $result);
        }

        /**
         * Ensures exists returns true when a row is present.
         */
        public function testExistsReturnsTrueWhenRowPresent(): void
        {
            /*
             * Arrange: build a template with a row to fetch.
             */
            $stmt = $this->createMock(PDOStatement::class);
            $stmt->method('execute')->willReturn(true);
            $stmt->method('fetch')->willReturnOnConsecutiveCalls(['id' => 1], false);

            $pdo = $this->createMock(PDO::class);
            $pdo->method('getAttribute')->willReturn('sqlite');
            $pdo->method('prepare')->willReturn($stmt);
            $template = new SqlTemplate($pdo);

            /*
             * Act: check existence.
             */
            $result = $template->exists('SELECT 1 FROM test WHERE id = :id', ['id' => 1]);

            /*
             * Assert: verify true is returned.
             */
            $this->assertTrue($result);
        }

        /**
         * Ensures existsForUpdate returns false when no row is present.
         */
        public function testExistsForUpdateReturnsFalseWhenNoRow(): void
        {
            /*
             * Arrange: build a template with no rows.
             */
            $stmt = $this->createMock(PDOStatement::class);
            $stmt->method('execute')->willReturn(true);
            $stmt->method('fetch')->willReturn(false);

            $pdo = $this->createMock(PDO::class);
            $pdo->method('getAttribute')->willReturn('sqlite');
            $pdo->method('prepare')->willReturn($stmt);
            $template = new SqlTemplate($pdo);

            /*
             * Act: check existence for update.
             */
            $result = $template->existsForUpdate('SELECT 1 FROM test WHERE id = :id FOR UPDATE', ['id' => 2]);

            /*
             * Assert: verify false is returned.
             */
            $this->assertFalse($result);
        }

        /**
         * Ensures array parameters are expanded and values are bound.
         */
        public function testPrepareExpandsArrayParamsAndBindsValues(): void
        {
            /*
             * Arrange: build a template with a MySQL driver and array params.
             */
            $boundValues = [];
            $preparedQuery = '';
            $stmt = $this->createMock(PDOStatement::class);
            $stmt->method('bindValue')->willReturnCallback(
                function ($param, $value, $type = null) use (&$boundValues) {
                    $boundValues[] = [$param, $value, $type];
                    return true;
                }
            );

            $pdo = $this->createMock(PDO::class);
            $pdo->method('getAttribute')->willReturn('mysql');
            $pdo->method('prepare')->willReturnCallback(
                function ($query) use (&$preparedQuery, $stmt) {
                    $preparedQuery = $query;
                    return $stmt;
                }
            );
            $template = new SqlTemplate($pdo);
            $method = new \ReflectionMethod($template, 'prepare');
            $method->setAccessible(true);

            $query = 'SELECT "id" FROM "items" WHERE id IN (:ids) AND status NOT IN (:statuses) AND flag = :flag AND content = :blob AND name = :name';
            $params = [
                'ids' => [1, 2],
                'statuses' => new SqlParam('statuses', [10, 11], SqlParam::INT),
                'date' => new SqlParam('date', new DateTimeImmutable('2020-01-01 10:00:00'), SqlParam::DATETIME),
                'flag' => new SqlParam('flag', true, SqlParam::BOOL),
                'blob' => new SqlParam('blob', 'data', SqlParam::TEXT),
                'name' => 'alpha',
            ];

            /*
             * Act: prepare the query with array and scalar params.
             */
            $prepared = $method->invoke($template, $query, $params);

            /*
             * Assert: verify query expansion and bound values.
             */
            $this->assertSame($stmt, $prepared);
            $this->assertSame('SELECT `id` FROM `items` WHERE id IN (:ids_1, :ids_2) AND status NOT IN (:statuses_1, :statuses_2) AND flag = :flag AND content = :blob AND name = :name', $preparedQuery);
            $this->assertSame([
                ['ids_1', 1, PDO::PARAM_STR],
                ['ids_2', 2, PDO::PARAM_STR],
                ['statuses_1', 10, PDO::PARAM_INT],
                ['statuses_2', 11, PDO::PARAM_INT],
                ['date', '2020-01-01 10:00:00', PDO::PARAM_STR],
                ['flag', true, PDO::PARAM_BOOL],
                ['blob', 'data', PDO::PARAM_LOB],
                ['name', 'alpha', PDO::PARAM_STR],
            ], $boundValues);
        }

        /**
         * Ensures empty array parameters expand to constant expressions.
         */
        public function testPrepareExpandsEmptyArrayParams(): void
        {
            /*
             * Arrange: build a template with empty array params.
             */
            $preparedQuery = '';
            $stmt = $this->createMock(PDOStatement::class);
            $stmt->method('bindValue')->willReturn(true);

            $pdo = $this->createMock(PDO::class);
            $pdo->method('getAttribute')->willReturn('sqlite');
            $pdo->method('prepare')->willReturnCallback(
                function ($query) use (&$preparedQuery, $stmt) {
                    $preparedQuery = $query;
                    return $stmt;
                }
            );
            $template = new SqlTemplate($pdo);
            $method = new \ReflectionMethod($template, 'prepare');
            $method->setAccessible(true);

            $query = 'SELECT * FROM items WHERE id IN (:ids) AND status NOT IN (:statuses)';
            $params = [
                'ids' => [],
                'statuses' => [],
            ];

            /*
             * Act: prepare the query with empty arrays.
             */
            $method->invoke($template, $query, $params);

            /*
             * Assert: verify constant expressions are used.
             */
            $this->assertSame('SELECT * FROM items WHERE 0 = 1 AND 1 = 1', $preparedQuery);
        }
    }
}
