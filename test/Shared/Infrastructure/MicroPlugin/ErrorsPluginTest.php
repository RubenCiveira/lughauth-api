<?php

/* @autogenerated */
declare(strict_types=1);

namespace {
    use PHPUnit\Framework\TestCase;
    use Psr\Http\Message\ResponseInterface;
    use Psr\Http\Message\ServerRequestInterface;
    use Slim\Middleware\ErrorMiddleware;
    use Slim\Exception\HttpMethodNotAllowedException;
    use Civi\Lughauth\Shared\Infrastructure\MicroPlugin\ErrorsPlugin;
    use Civi\Lughauth\Shared\Exception\ConstraintException;
    use Civi\Lughauth\Shared\Exception\UnauthorizedException;

    /**
     * Unit tests for {@see ErrorsPlugin}.
     */
    final class ErrorsPluginTest extends TestCase
    {
        /**
         * Ensures error handlers map domain exceptions to responses.
         */
        public function testRegisterErrorHandlerMapsExceptions(): void
        {
            /*
             * Arrange: build an error middleware mock to capture handlers.
             */
            $handlers = [];
            $errorMiddleware = $this->createMock(ErrorMiddleware::class);
            $errorMiddleware->method('setErrorHandler')
                ->willReturnCallback(function (string $type, callable $handler) use (&$handlers, $errorMiddleware) {
                    $handlers[$type] = $handler;
                    return $errorMiddleware;
                });
            $plugin = new ErrorsPlugin();
            $request = $this->createMock(ServerRequestInterface::class);

            /*
             * Act: register handlers and invoke each handler.
             */
            $plugin->registerErrorHandler($errorMiddleware);

            $constraint = ConstraintException::ofError('required', ['email'], ['bad']);
            $constraintResponse = $handlers[ConstraintException::class]($request, $constraint);

            $unauthorized = new UnauthorizedException('nope');
            $unauthorizedResponse = $handlers[UnauthorizedException::class]($request, $unauthorized);

            $methodNotAllowed = new HttpMethodNotAllowedException($request);
            $methodNotAllowedResponse = $handlers[HttpMethodNotAllowedException::class]($request, $methodNotAllowed);

            /*
             * Assert: verify responses and payloads match expectations.
             */
            $this->assertConstraintResponse($constraintResponse);
            $this->assertJsonMessageResponse($unauthorizedResponse, 401, 'nope');
            $this->assertJsonMessageResponse($methodNotAllowedResponse, 404, $methodNotAllowed->getMessage());
        }

        private function assertConstraintResponse(ResponseInterface $response): void
        {
            $payload = json_decode((string) $response->getBody(), true, 512, JSON_THROW_ON_ERROR);

            $this->assertSame(422, $response->getStatusCode());
            $this->assertSame('application/problem+json', $response->getHeaderLine('Content-Type'));
            $this->assertSame('/validation-error', $payload['type']);
            $this->assertSame('Validation failed', $payload['title']);
            $this->assertSame(422, $payload['status']);
            $this->assertSame(['email' => ['bad fail for required']], $payload['errors']);
        }

        private function assertJsonMessageResponse(ResponseInterface $response, int $status, string $message): void
        {
            $payload = json_decode((string) $response->getBody(), true, 512, JSON_THROW_ON_ERROR);

            $this->assertSame($status, $response->getStatusCode());
            $this->assertSame(['message' => $message], $payload);
        }
    }
}
