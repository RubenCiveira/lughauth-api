<?php

/* @autogenerated */
declare(strict_types=1);

namespace {
    use Cron\CronExpression;
    use PHPUnit\Framework\TestCase;
    use Psr\Container\ContainerInterface;
    use Psr\Log\LoggerInterface;
    use Civi\Lughauth\Shared\Infrastructure\MicroPlugin\ManagementPlugin;
    use Civi\Lughauth\Shared\Infrastructure\Scheduler\SchedulerManager;
    use Civi\Lughauth\Shared\Infrastructure\StartupProcessor;
    use Civi\Lughauth\Shared\Infrastructure\MicroConfig;
    use Civi\Lughauth\Shared\Infrastructure\Management\Health\HealthManagement;
    use Civi\Lughauth\Shared\Infrastructure\Management\Config\ConfigManagement;
    use Civi\Lughauth\Shared\Infrastructure\Management\Routes\RoutesManagement;
    use Civi\Lughauth\Shared\Infrastructure\Management\Dependencies\DependenciesManagement;
    use Civi\Lughauth\Shared\Infrastructure\Management\Metrics\MetricsManagement;
    use Civi\Lughauth\Shared\Infrastructure\Management\Migration\MigrationManagement;
    use Civi\Lughauth\Shared\Infrastructure\Management\Apidoc\ApidocManagement;
    use Civi\Lughauth\Shared\Infrastructure\Management\Log\LogManagement;
    use Civi\Lughauth\Shared\Infrastructure\Management\Trace\TraceManagement;
    use Civi\Lughauth\Shared\Infrastructure\Management\Collector\TraceCollector;
    use Civi\Lughauth\Shared\Infrastructure\Management\Collector\LogCollector;
    use Civi\Lughauth\Shared\Infrastructure\Management\History\HistoryManagement;
    use Civi\Lughauth\Shared\Infrastructure\Management\Audit\AuditManagement;
    use Civi\Lughauth\Shared\Infrastructure\Management\Histogram\HistogramManagement;
    use Civi\Lughauth\Shared\Infrastructure\Management\EntityChangelog\LoadChangesManagement;
    use Civi\Lughauth\Shared\Infrastructure\Management\EntityChangelog\MarkAckManagement;
    use Civi\Lughauth\Shared\Infrastructure\Management\EntityChangelog\UpdateChangelogManagement;
    use Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\PrometheusRegistryExporter;

    final class ManagementFakeContainer implements ContainerInterface
    {
        public function __construct(private array $services)
        {
        }

        public function get(string $id): mixed
        {
            return $this->services[$id] ?? null;
        }

        public function has(string $id): bool
        {
            return array_key_exists($id, $this->services);
        }
    }

    final class ManagementFakeConfig
    {
        public function __construct(
            public bool $withMetrics,
            public bool $withTelemetry,
            public bool $withAudit
        ) {
        }
    }

    final class ManagementFakeStartupProcessor extends StartupProcessor
    {
        public $callback = null;
        public int $order = -1;

        public function __construct(LoggerInterface $logger)
        {
            parent::__construct($logger);
        }

        public function register(\Closure|\Civi\Lughauth\Shared\Infrastructure\StartupProcess $command, int $order = 0)
        {
            $this->callback = $command;
            $this->order = $order;
        }
    }

    final class ManagementFakeMigration
    {
        public bool $setCalled = false;
        public bool $callbackCalled = false;

        public function set(): callable
        {
            $this->setCalled = true;
            return function (): void {
                $this->callbackCalled = true;
            };
        }
    }

    /**
     * Unit tests for {@see ManagementPlugin}.
     */
    final class ManagementPluginTest extends TestCase
    {
        /**
         * Ensures scheduler registration uses the expected cron entry.
         */
        public function testRegisterSchedulersRegistersCronJob(): void
        {
            /*
             * Arrange: build a scheduler mock and plugin.
             */
            $scheduler = $this->createMock(SchedulerManager::class);
            $scheduler->expects($this->once())
                ->method('register')
                ->with(
                    $this->callback(fn (CronExpression $cron) => $cron->getExpression() === '*/15 * * * *'),
                    PrometheusRegistryExporter::class,
                    'forceDump'
                );
            $plugin = new ManagementPlugin();

            /*
             * Act: register schedulers.
             */
            $plugin->registerSchedulers($scheduler);

            /*
             * Assert: verify the scheduler registration occurred.
             */
            $this->assertTrue(true);
        }

        /**
         * Ensures management interfaces honor disabled features.
         */
        public function testGetManagementsInterfacesWithoutOptionalFeatures(): void
        {
            /*
             * Arrange: build a container with optional features disabled.
             */
            $services = $this->buildServiceMap();
            $services[MicroConfig::class] = new ManagementFakeConfig(false, false, false);
            $container = new ManagementFakeContainer($services);
            $plugin = new ManagementPlugin();

            /*
             * Act: resolve management interfaces.
             */
            $result = $plugin->getManagementsInterfaces($container);

            /*
             * Assert: verify only the baseline interfaces are returned.
             */
            $this->assertSame([
                $services[HealthManagement::class],
                $services[ConfigManagement::class],
                $services[RoutesManagement::class],
                $services[DependenciesManagement::class],
                $services[MigrationManagement::class],
                $services[ApidocManagement::class],
                $services[HistogramManagement::class],
                $services[LoadChangesManagement::class],
                $services[MarkAckManagement::class],
                $services[UpdateChangelogManagement::class],
            ], $result);
        }

        /**
         * Ensures management interfaces include optional features.
         */
        public function testGetManagementsInterfacesWithAllFeatures(): void
        {
            /*
             * Arrange: build a container with all features enabled.
             */
            $services = $this->buildServiceMap();
            $services[MicroConfig::class] = new ManagementFakeConfig(true, true, true);
            $container = new ManagementFakeContainer($services);
            $plugin = new ManagementPlugin();

            /*
             * Act: resolve management interfaces.
             */
            $result = $plugin->getManagementsInterfaces($container);

            /*
             * Assert: verify all optional interfaces are returned.
             */
            $this->assertSame([
                $services[HealthManagement::class],
                $services[ConfigManagement::class],
                $services[RoutesManagement::class],
                $services[DependenciesManagement::class],
                $services[MetricsManagement::class],
                $services[MigrationManagement::class],
                $services[ApidocManagement::class],
                $services[LogManagement::class],
                $services[TraceManagement::class],
                $services[TraceCollector::class],
                $services[LogCollector::class],
                $services[HistoryManagement::class],
                $services[AuditManagement::class],
                $services[HistogramManagement::class],
                $services[LoadChangesManagement::class],
                $services[MarkAckManagement::class],
                $services[UpdateChangelogManagement::class],
            ], $result);
        }

        /**
         * Ensures startup registration triggers migrations.
         */
        public function testRegisterStartupExecutesMigrationCallback(): void
        {
            /*
             * Arrange: build a startup processor and migration handler.
             */
            $logger = $this->createMock(LoggerInterface::class);
            $startup = new ManagementFakeStartupProcessor($logger);
            $migration = new ManagementFakeMigration();
            $container = new ManagementFakeContainer([
                MigrationManagement::class => $migration,
            ]);
            $plugin = new ManagementPlugin();

            /*
             * Act: register startup and invoke the captured callback.
             */
            $plugin->registerStartup($startup);
            ($startup->callback)($container);

            /*
             * Assert: verify migrations were set and executed.
             */
            $this->assertSame(0, $startup->order);
            $this->assertTrue($migration->setCalled);
            $this->assertTrue($migration->callbackCalled);
        }

        private function buildServiceMap(): array
        {
            return [
                HealthManagement::class => new \stdClass(),
                ConfigManagement::class => new \stdClass(),
                RoutesManagement::class => new \stdClass(),
                DependenciesManagement::class => new \stdClass(),
                MetricsManagement::class => new \stdClass(),
                MigrationManagement::class => new \stdClass(),
                ApidocManagement::class => new \stdClass(),
                LogManagement::class => new \stdClass(),
                TraceManagement::class => new \stdClass(),
                TraceCollector::class => new \stdClass(),
                LogCollector::class => new \stdClass(),
                HistoryManagement::class => new \stdClass(),
                AuditManagement::class => new \stdClass(),
                HistogramManagement::class => new \stdClass(),
                LoadChangesManagement::class => new \stdClass(),
                MarkAckManagement::class => new \stdClass(),
                UpdateChangelogManagement::class => new \stdClass(),
            ];
        }
    }
}
