<?php

/* @autogenerated */
declare(strict_types=1);

namespace {
    use PHPUnit\Framework\TestCase;
    use Psr\Container\ContainerInterface;
    use Psr\Log\LoggerInterface;
    use Civi\Lughauth\Shared\Infrastructure\MicroPlugin\GenericSecurityPlugin;
    use Civi\Lughauth\Shared\Event\EventListenersRegistrarInterface;
    use Civi\Lughauth\Shared\Infrastructure\StartupProcessor;
    use Civi\Lughauth\Shared\Security\AllowDecision;
    use Civi\Lughauth\Shared\Security\FieldsAccess;
    use Civi\Lughauth\Shared\Security\Rbac\AllowListener;
    use Civi\Lughauth\Shared\Security\Rbac\FieldsListener;
    use Civi\Lughauth\Shared\Security\Rbac\Handler;

    final class GenericSecurityFakeBus implements EventListenersRegistrarInterface
    {
        public array $listeners = [];

        public function registerListener(string $eventType, string $listenerClass): void
        {
            $this->listeners[] = [$eventType, $listenerClass];
        }
    }

    final class GenericSecurityFakeContainer implements ContainerInterface
    {
        public function __construct(private array $services)
        {
        }

        public function get(string $id): mixed
        {
            return $this->services[$id] ?? null;
        }

        public function has(string $id): bool
        {
            return array_key_exists($id, $this->services);
        }
    }

    final class GenericSecurityFakeStartupProcessor extends StartupProcessor
    {
        public $callback = null;
        public int $order = -1;

        public function __construct(LoggerInterface $logger)
        {
            parent::__construct($logger);
        }

        public function register(\Closure|\Civi\Lughauth\Shared\Infrastructure\StartupProcess $command, int $order = 0)
        {
            $this->callback = $command;
            $this->order = $order;
        }
    }

    /**
     * Unit tests for {@see GenericSecurityPlugin}.
     */
    final class GenericSecurityPluginTest extends TestCase
    {
        /**
         * Ensures RBAC listeners are registered.
         */
        public function testRegisterEventsRegistersListeners(): void
        {
            /*
             * Arrange: build a fake bus and plugin.
             */
            $bus = new GenericSecurityFakeBus();
            $plugin = new GenericSecurityPlugin();

            /*
             * Act: register event listeners.
             */
            $plugin->registerEvents($bus);

            /*
             * Assert: verify listener registrations are captured.
             */
            $this->assertSame([
                [AllowDecision::class, AllowListener::class],
                [FieldsAccess::class, FieldsListener::class],
            ], $bus->listeners);
        }

        /**
         * Ensures startup registration flushes RBAC cache.
         */
        public function testRegisterStartupFlushesHandler(): void
        {
            /*
             * Arrange: build a startup processor and handler.
             */
            $logger = $this->createMock(LoggerInterface::class);
            $startup = new GenericSecurityFakeStartupProcessor($logger);
            $handler = $this->createMock(Handler::class);
            $handler->expects($this->once())->method('flush');
            $container = new GenericSecurityFakeContainer([
                Handler::class => $handler,
            ]);
            $plugin = new GenericSecurityPlugin();

            /*
             * Act: register startup and invoke the captured callback.
             */
            $plugin->registerStartup($startup);
            ($startup->callback)($container);

            /*
             * Assert: verify the startup order and flush call.
             */
            $this->assertSame(GenericSecurityPlugin::STARTUP_ORDER, $startup->order);
            $this->assertTrue(true);
        }
    }
}
