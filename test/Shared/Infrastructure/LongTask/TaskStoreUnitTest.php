<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use Civi\Lughauth\Shared\Context;
use Civi\Lughauth\Shared\Security\Identity;
use Civi\Lughauth\Shared\Infrastructure\LongTask\TaskKey;
use Civi\Lughauth\Shared\Infrastructure\LongTask\TaskStore;
use Civi\Lughauth\Shared\Infrastructure\LongTask\TaskProgress;
use Civi\Lughauth\Shared\Infrastructure\Sql\SqlParam;
use Civi\Lughauth\Shared\Infrastructure\Sql\SqlTemplate;

/**
 * Unit tests for {@see TaskStore}.
 */
final class TaskStoreUnitTest extends TestCase
{
    /**
     * Ensures a task progress payload is saved.
     */
    public function testSavePersistsTaskProgress(): void
    {
        /* Arrange: build mocks and task progress to save. */
        $template = $this->createMock(SqlTemplate::class);
        $template
            ->expects($this->exactly(2))
            ->method('execute')
            ->willReturnCallback(function (string $query, array $params) use (&$call): bool {
                $call ??= 0;
                if ($call === 0) {
                    $this->assertStringContainsString('delete from _long_tasks', $query);
                    $this->assertIsArray($params);
                } else {
                    $this->assertStringContainsString('insert into _long_tasks', $query);
                    $this->assertTrue($this->assertSqlParams($params, ['id', 'content', 'user', 'expiration']));
                }
                $call++;
                return true;
            });
        $template->expects($this->once())->method('commit');

        $context = $this->mockContext('user-1');
        $store = new TaskStore($template, $context);
        $progress = new TaskProgress(new TaskKey('task-1'), 'PENDING', null, null, []);
        $expiration = new DateTimeImmutable('2024-01-05 00:00:00');

        /* Act: save the task progress. */
        $store->save($progress, $expiration);

        /* Assert: verify the SQL template was invoked. */
        $this->assertTrue(true);
    }

    /**
     * Ensures task progress updates are stored.
     */
    public function testUpdatePersistsTaskProgress(): void
    {
        /* Arrange: build mocks and task progress to update. */
        $template = $this->createMock(SqlTemplate::class);
        $template
            ->expects($this->exactly(2))
            ->method('execute')
            ->willReturnCallback(function (string $query, array $params) use (&$call): bool {
                $call ??= 0;
                if ($call === 0) {
                    $this->assertStringContainsString('delete from _long_tasks', $query);
                    $this->assertIsArray($params);
                } else {
                    $this->assertStringContainsString('update _long_tasks', $query);
                    $this->assertTrue($this->assertSqlParams($params, ['id', 'user', 'content']));
                }
                $call++;
                return true;
            });
        $template->expects($this->once())->method('commit');

        $context = $this->mockContext('user-2');
        $store = new TaskStore($template, $context);
        $progress = new TaskProgress(new TaskKey('task-2'), 'PROCESSING', null, null, []);

        /* Act: update the task progress. */
        $store->update($progress);

        /* Assert: verify the SQL template was invoked. */
        $this->assertTrue(true);
    }

    /**
     * Ensures stored progress is reconstructed from JSON.
     */
    public function testRetrieveReturnsTaskProgress(): void
    {
        /* Arrange: build a stored task payload with step data. */
        $payload = json_encode([
            'status' => 'FINISHED',
            'steps' => [
                [
                    'status' => 'FINISHED',
                    'processedItems' => 0,
                    'totalItem' => 1,
                    'error' => null,
                    'oks' => ['ok-1']
                ]
            ]
        ], JSON_THROW_ON_ERROR);

        $template = $this->createMock(SqlTemplate::class);
        $template->expects($this->once())->method('execute');
        $template
            ->expects($this->once())
            ->method('query')
            ->with($this->stringContains('select content from _long_tasks'), $this->isArray())
            ->willReturn([['content' => $payload]]);

        $context = $this->mockContext('user-3');
        $store = new TaskStore($template, $context);

        /* Act: retrieve the task progress from storage. */
        $progress = $store->retrieve(new TaskKey('task-3'));

        /* Assert: verify the progress and step values are restored. */
        $this->assertInstanceOf(TaskProgress::class, $progress);
        $this->assertSame('FINISHED', $progress->status);
        $this->assertCount(1, $progress->steps);
        $this->assertSame('FINISHED', $progress->steps[0]->status);
        $this->assertSame(1, $progress->steps[0]->processedItems);
    }

    /**
     * Ensures missing rows return null.
     */
    public function testRetrieveReturnsNullWhenMissing(): void
    {
        /* Arrange: configure storage to return no rows. */
        $template = $this->createMock(SqlTemplate::class);
        $template->expects($this->once())->method('execute');
        $template->expects($this->once())->method('query')->willReturn([]);

        $context = $this->mockContext('user-4');
        $store = new TaskStore($template, $context);

        /* Act: retrieve a missing task. */
        $progress = $store->retrieve(new TaskKey('task-4'));

        /* Assert: verify no progress is found. */
        $this->assertNull($progress);
    }

    /**
     * Ensures warning and error payloads exercise the parsing branches.
     */
    public function testRetrieveWarnsAndErrorsTriggerBranches(): void
    {
        /* Arrange: configure payload with warning and error details. */
        $payload = json_encode([
            'status' => 'FAILED',
            'steps' => [
                [
                    'status' => 'FAILED',
                    'warns' => ['W01' => ['Warning']],
                    'errors' => ['E01' => ['Error']],
                ]
            ]
        ], JSON_THROW_ON_ERROR);

        $template = $this->createMock(SqlTemplate::class);
        $template->expects($this->once())->method('execute');
        $template->expects($this->once())->method('query')->willReturn([['content' => $payload]]);

        $context = $this->mockContext('user-5');
        $store = new TaskStore($template, $context);

        /* Act: retrieve the progress and capture parsing errors. */
        set_error_handler(static function (): bool {
            return true;
        });

        try {
            $this->expectException(TypeError::class);
            $store->retrieve(new TaskKey('task-5'));
        } finally {
            restore_error_handler();
        }

        /* Assert: verify the parsing branch resulted in a type error. */
        $this->assertTrue(true);
    }

    /**
     * Ensures date parsing handles arrays and nulls.
     */
    public function testDateParsesArrayAndNull(): void
    {
        /* Arrange: build a task store and reflective access to date(). */
        $template = $this->createMock(SqlTemplate::class);
        $template->expects($this->once())->method('execute');
        $context = $this->mockContext('user-6');
        $store = new TaskStore($template, $context);

        $method = new ReflectionMethod($store, 'date');
        $method->setAccessible(true);

        $input = ['date' => '2024-01-01 00:00:00', 'timezone' => 'UTC'];

        /* Act: parse a structured date and a null input. */
        $date = $method->invoke($store, $input);
        $nullDate = $method->invoke($store, null);

        /* Assert: verify the expected DateTimeImmutable output. */
        $this->assertInstanceOf(DateTimeImmutable::class, $date);
        $this->assertNull($nullDate);
    }

    private function mockContext(string $id): Context
    {
        $context = $this->createMock(Context::class);
        $context->method('getIdentity')->willReturn(new Identity(anonimous: true, id: $id));
        return $context;
    }

    private function assertSqlParams(array $params, array $names): bool
    {
        if (count($params) !== count($names)) {
            return false;
        }

        foreach ($names as $index => $name) {
            if (!$params[$index] instanceof SqlParam) {
                return false;
            }
            if ($params[$index]->name !== $name) {
                return false;
            }
        }

        return true;
    }
}
