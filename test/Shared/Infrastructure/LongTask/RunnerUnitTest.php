<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\LongTask {
    final class RunnerTestRegistry
    {
        public static array $callbacks = [];

        public static function reset(): void
        {
            self::$callbacks = [];
        }
    }

    function register_shutdown_function(callable $callback, ...$args): void
    {
        RunnerTestRegistry::$callbacks[] = [$callback, $args];
    }

    function set_time_limit(int $seconds): void
    {
    }
}

namespace {
    use PHPUnit\Framework\TestCase;
    use Psr\Container\ContainerInterface;
    use Civi\Lughauth\Shared\Context;
    use Civi\Lughauth\Shared\Infrastructure\LongTask\Runner;
    use Civi\Lughauth\Shared\Infrastructure\LongTask\TaskKey;
    use Civi\Lughauth\Shared\Infrastructure\LongTask\TaskStore;
    use Civi\Lughauth\Shared\Infrastructure\LongTask\TaskContext;
    use Civi\Lughauth\Shared\Infrastructure\LongTask\TaskReaderInterface;
    use Civi\Lughauth\Shared\Infrastructure\LongTask\TaskWriterInterface;
    use Civi\Lughauth\Shared\Infrastructure\LongTask\TaskCounterInterface;
    use Civi\Lughauth\Shared\Infrastructure\LongTask\TaskDescriptorInterface;
    use Civi\Lughauth\Shared\Infrastructure\LongTask\TaskProgress;
    use Civi\Lughauth\Shared\Infrastructure\LongTask\RunnerTestRegistry;

    /**
     * Unit tests for {@see Runner}.
     */
    final class RunnerUnitTest extends TestCase
    {
        protected function setUp(): void
        {
            RunnerTestRegistry::reset();
        }

        /**
         * Ensures tasks run to completion and update progress.
         */
        public function testRunProcessesItemsAndFinishes(): void
        {
            /* Arrange: create a runner with a descriptor that processes items. */
            $reader = new RunnerTestReader([["a", "b"], []]);
            $writer = new RunnerTestWriter();
            $descriptor = new RunnerTestDescriptor($reader, $writer);
            $container = new RunnerTestContainer([RunnerTestDescriptor::class => $descriptor]);

            $store = $this->createMock(TaskStore::class);
            $updates = [];
            $store->expects($this->once())->method('save');
            $store->method('update')->willReturnCallback(function (TaskProgress $progress) use (&$updates): void {
                $updates[] = $progress;
            });

            $context = $this->createMock(Context::class);
            $context->method('detachedContainer')->willReturn($container);

            $runner = new Runner($store, $context);

            /* Act: run the task and execute the shutdown callback. */
            $key = $runner->run(RunnerTestDescriptor::class, ['tenant' => 'core']);
            [$callback, $args] = RunnerTestRegistry::$callbacks[0];
            $callback(...$args);

            /* Assert: verify the task finished and wrote processed items. */
            $this->assertInstanceOf(TaskKey::class, $key);
            $this->assertNotEmpty($key->uid);
            $this->assertNotEmpty($updates);
            $last = $updates[array_key_last($updates)];
            $this->assertSame('FINISHED', $last->status);
            $this->assertSame('FINISHED', $last->steps[0]->status);
            $this->assertSame(2, $last->steps[0]->processedItems);
            $this->assertSame(["A", "B"], $writer->written);
            $this->assertTrue($descriptor->finished);
        }

        /**
         * Ensures task failures mark progress as failed.
         */
        public function testRunMarksFailedOnReaderException(): void
        {
            /* Arrange: create a runner with a reader that fails. */
            $reader = new RunnerFailingReader();
            $descriptor = new RunnerTestDescriptor($reader, null);
            $container = new RunnerTestContainer([RunnerTestDescriptor::class => $descriptor]);

            $store = $this->createMock(TaskStore::class);
            $updates = [];
            $store->expects($this->once())->method('save');
            $store->method('update')->willReturnCallback(function (TaskProgress $progress) use (&$updates): void {
                $updates[] = $progress;
            });

            $context = $this->createMock(Context::class);
            $context->method('detachedContainer')->willReturn($container);

            $runner = new Runner($store, $context);

            /* Act: run the task and execute the shutdown callback. */
            $runner->run(RunnerTestDescriptor::class, []);
            [$callback, $args] = RunnerTestRegistry::$callbacks[0];
            $callback(...$args);

            /* Assert: verify the failure is reflected in progress. */
            $last = $updates[array_key_last($updates)];
            $this->assertSame('FAILED', $last->status);
            $this->assertSame('FAILED', $last->steps[0]->status);
            $this->assertSame('Reader failure', $last->steps[0]->error);
        }

        /**
         * Ensures descriptor failures bubble up after recording the span.
         */
        public function testRunRethrowsDescriptorFailure(): void
        {
            /* Arrange: create a descriptor that throws on init. */
            $descriptor = new RunnerFailingDescriptor();
            $container = new RunnerTestContainer([RunnerFailingDescriptor::class => $descriptor]);

            $store = $this->createMock(TaskStore::class);
            $store->expects($this->once())->method('save');
            $store->expects($this->never())->method('update');

            $context = $this->createMock(Context::class);
            $context->method('detachedContainer')->willReturn($container);

            $runner = new Runner($store, $context);

            /* Act: execute the shutdown callback and capture the exception. */
            $runner->run(RunnerFailingDescriptor::class, []);
            [$callback, $args] = RunnerTestRegistry::$callbacks[0];

            /* Assert: verify the failure is rethrown. */
            $this->expectException(RuntimeException::class);
            $callback(...$args);
        }

        /**
         * Ensures task details are retrieved from the store.
         */
        public function testDetailReturnsStoreResult(): void
        {
            /* Arrange: create a runner with a store that returns progress. */
            $progress = new TaskProgress(new TaskKey('task-10'), 'FINISHED', null, null, []);
            $store = $this->createMock(TaskStore::class);
            $store->method('retrieve')->willReturn($progress);

            $context = $this->createMock(Context::class);
            $runner = new Runner($store, $context);

            /* Act: request the task detail. */
            $result = $runner->detail(new TaskKey('task-10'));

            /* Assert: verify the store response is returned. */
            $this->assertSame($progress, $result);
        }

        /**
         * Ensures process exceptions are recorded as step errors.
         */
        public function testRunRecordsProcessErrors(): void
        {
            /* Arrange: create a descriptor that throws for a specific item. */
            $reader = new RunnerTestReader([["ok", "bad"], []]);
            $descriptor = new RunnerErrorDescriptor($reader);
            $container = new RunnerTestContainer([RunnerErrorDescriptor::class => $descriptor]);

            $store = $this->createMock(TaskStore::class);
            $updates = [];
            $store->expects($this->once())->method('save');
            $store->method('update')->willReturnCallback(function (TaskProgress $progress) use (&$updates): void {
                $updates[] = $progress;
            });

            $context = $this->createMock(Context::class);
            $context->method('detachedContainer')->willReturn($container);

            $runner = new Runner($store, $context);

            /* Act: run the task and execute the shutdown callback. */
            $runner->run(RunnerErrorDescriptor::class, []);
            [$callback, $args] = RunnerTestRegistry::$callbacks[0];

            set_error_handler(static function (): bool {
                return true;
            });

            try {
                $callback(...$args);
            } finally {
                restore_error_handler();
            }

            /* Assert: verify the error entry is recorded on the step. */
            $last = $updates[array_key_last($updates)];
            $this->assertArrayHasKey('item-bad', $last->steps[0]->errors);
            $this->assertSame(2, $last->steps[0]->processedItems);
        }
    }

    final class RunnerTestContainer implements ContainerInterface
    {
        public function __construct(private array $services)
        {
        }

        public function get(string $id)
        {
            return $this->services[$id];
        }

        public function has(string $id): bool
        {
            return array_key_exists($id, $this->services);
        }
    }

    final class RunnerTestDescriptor implements TaskDescriptorInterface
    {
        public bool $finished = false;

        public function __construct(private TaskReaderInterface $reader, private ?TaskWriterInterface $writer)
        {
        }

        public function init(TaskContext $initial): TaskContext
        {
            return $initial;
        }

        public function finish(TaskContext $state)
        {
            $this->finished = true;
        }

        public function describe(mixed $item): string
        {
            return 'item-' . $item;
        }

        public function reader(): TaskReaderInterface
        {
            return $this->reader;
        }

        public function writer(): ?TaskWriterInterface
        {
            return $this->writer;
        }

        public function process(TaskContext $context, mixed $item): mixed
        {
            return strtoupper((string) $item);
        }
    }

    final class RunnerTestReader implements TaskReaderInterface, TaskCounterInterface
    {
        private array $batches;

        public function __construct(array $batches)
        {
            $this->batches = $batches;
        }

        public function expectedTotal(TaskContext $context): int
        {
            return count($this->batches[0] ?? []);
        }

        public function read(TaskContext $context): array
        {
            return array_shift($this->batches) ?? [];
        }
    }

    final class RunnerFailingReader implements TaskReaderInterface
    {
        public function read(TaskContext $context): array
        {
            throw new RuntimeException('Reader failure');
        }
    }

    final class RunnerTestWriter implements TaskWriterInterface
    {
        public array $written = [];

        public function write(TaskContext $context, array $item): void
        {
            $this->written = $item;
        }
    }

    final class RunnerFailingDescriptor implements TaskDescriptorInterface
    {
        public function init(TaskContext $initial): TaskContext
        {
            throw new RuntimeException('Init failed');
        }

        public function finish(TaskContext $state)
        {
        }

        public function describe(mixed $item): string
        {
            return 'item';
        }

        public function reader(): TaskReaderInterface
        {
            return new RunnerFailingReader();
        }

        public function writer(): ?TaskWriterInterface
        {
            return null;
        }

        public function process(TaskContext $context, mixed $item): mixed
        {
            return $item;
        }
    }

    final class RunnerErrorDescriptor implements TaskDescriptorInterface
    {
        public function __construct(private TaskReaderInterface $reader)
        {
        }

        public function init(TaskContext $initial): TaskContext
        {
            return $initial;
        }

        public function finish(TaskContext $state)
        {
        }

        public function describe(mixed $item): string
        {
            return 'item-' . $item;
        }

        public function reader(): TaskReaderInterface
        {
            return $this->reader;
        }

        public function writer(): ?TaskWriterInterface
        {
            return null;
        }

        public function process(TaskContext $context, mixed $item): mixed
        {
            if ($item === 'bad') {
                throw new RuntimeException('Bad item');
            }

            return strtoupper((string) $item);
        }
    }
}
