<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use OpenTelemetry\SDK\Trace\SpanDataInterface;
use OpenTelemetry\SDK\Trace\StatusDataInterface;
use OpenTelemetry\SDK\Common\Attribute\AttributesInterface;
use Civi\Lughauth\Shared\Infrastructure\Log\SpanJsonGzipRotatingFileExporter;

/**
 * Unit tests for {@see SpanJsonGzipRotatingFileExporter}.
 */
final class SpanJsonGzipRotatingFileExporterUnitTest extends TestCase
{
    /**
     * Ensures span batches are exported and rotated files are gzipped.
     */
    public function testExportWritesAndRotatesFiles(): void
    {
        /* Arrange: prepare span exporter state and existing log files. */
        $dir = $this->createTempDir();
        $dateFormat = 'Y-m-d';
        $today = (new DateTimeImmutable('now'))->format($dateFormat);
        $yesterday = (new DateTimeImmutable('-1 day'))->format($dateFormat);
        $older = (new DateTimeImmutable('-2 days'))->format($dateFormat);

        $todayFile = $dir . '/spans-' . $today . '.jsonl';
        $yesterdayFile = $dir . '/spans-' . $yesterday . '.jsonl';
        $olderFile = $dir . '/spans-' . $older . '.jsonl';

        file_put_contents($todayFile, "existing\n");
        file_put_contents($yesterdayFile, "old\n");
        file_put_contents($olderFile, "older\n");

        $exporter = new SpanJsonGzipRotatingFileExporter(
            $dir . '/spans.jsonl',
            2,
            $dateFormat,
            '{filename}-{date}.jsonl',
            true
        );

        $span = $this->createSpanData('trace-1', 'span-1');

        /* Act: export a batch of spans to the rotating JSONL files. */
        $result = $exporter->export([$span]);

        /* Assert: verify the export succeeded and rotation was applied. */
        $this->assertTrue($result->await());
        $this->assertFileExists($todayFile);
        $this->assertFileDoesNotExist($yesterdayFile);
        $this->assertFileExists($yesterdayFile . '.gz');
        $this->assertFileDoesNotExist($olderFile);
    }

    /**
     * Ensures export returns false when file handles cannot be opened.
     */
    public function testExportReturnsFalseWhenCannotOpenFile(): void
    {
        /* Arrange: configure a read-only directory for the exporter. */
        $dir = $this->createTempDir();
        chmod($dir, 0555);
        $exporter = new SpanJsonGzipRotatingFileExporter($dir . '/spans.jsonl');
        $span = $this->createSpanData('trace-2', 'span-2');

        /* Act: attempt to export a span into the read-only directory. */
        set_error_handler(static function (): bool {
            return true;
        });
        try {
            $result = $exporter->export([$span]);
        } finally {
            restore_error_handler();
        }

        /* Assert: verify the exporter signals failure. */
        $this->assertFalse($result->await());
        chmod($dir, 0777);
    }

    /**
     * Ensures export fails when span normalization throws errors.
     */
    public function testExportReturnsFalseWhenSpanThrows(): void
    {
        /* Arrange: create an exporter and a span that throws on access. */
        $dir = $this->createTempDir();
        $exporter = new SpanJsonGzipRotatingFileExporter($dir . '/spans.jsonl');
        $span = $this->createMock(SpanDataInterface::class);
        $span->method('getTraceId')->willThrowException(new RuntimeException('boom'));

        /* Act: attempt to export the failing span. */
        $result = $exporter->export([$span]);

        /* Assert: verify the exporter reports failure for the batch. */
        $this->assertFalse($result->await());
    }

    /**
     * Ensures rotation is skipped when unlimited files are configured.
     */
    public function testExportSkipsRotationWhenUnlimited(): void
    {
        /* Arrange: create an exporter with unlimited retention. */
        $dir = $this->createTempDir();
        $exporter = new SpanJsonGzipRotatingFileExporter($dir . '/spans.jsonl', 0);
        $span = $this->createSpanData('trace-3', 'span-3');

        /* Act: export a batch without rotation cleanup. */
        $result = $exporter->export([$span]);

        /* Assert: verify the export succeeds and writes the current file. */
        $this->assertTrue($result->await());
        $this->assertFileExists($dir . '/spans-' . date('Y-m-d') . '.jsonl');
    }

    /**
     * Ensures exporter lifecycle hooks return the expected flags.
     */
    public function testShutdownAndForceFlushReturnTrue(): void
    {
        /* Arrange: build a span exporter for lifecycle checks. */
        $dir = $this->createTempDir();
        $exporter = new SpanJsonGzipRotatingFileExporter($dir . '/spans.jsonl');

        /* Act: call the shutdown and force flush lifecycle methods. */
        $shutdown = $exporter->shutdown();
        $flush = $exporter->forceFlush();

        /* Assert: verify lifecycle operations signal success. */
        $this->assertTrue($shutdown);
        $this->assertTrue($flush);
    }

    /**
     * Ensures gzip handling fails safely for invalid paths.
     */
    public function testGzipFileHandlesInvalidPaths(): void
    {
        /* Arrange: build an exporter and sample files for gzip operations. */
        $dir = $this->createTempDir();
        $exporter = new SpanJsonGzipRotatingFileExporter($dir . '/spans.jsonl');
        $method = new ReflectionMethod($exporter, 'gzipFile');
        $method->setAccessible(true);

        $source = $dir . '/sample.jsonl';
        $invalidTarget = $dir . '/missing/sample.jsonl.gz';
        $validTarget = $dir . '/sample.jsonl.gz';
        file_put_contents($source, str_repeat('b', 10));

        /* Act: invoke gzip with missing sources, invalid targets, and valid targets. */
        $method->invoke($exporter, $dir . '/missing.jsonl', $validTarget, 9);
        $method->invoke($exporter, $source, $invalidTarget, 9);
        $method->invoke($exporter, $source, $validTarget, 9);

        /* Assert: verify only the valid target is created. */
        $this->assertFileExists($validTarget);
        $this->assertFileDoesNotExist($invalidTarget);
    }

    /**
     * Ensures gzip writing stops when reading fails.
     */
    public function testGzipFileStopsOnReadFailure(): void
    {
        /* Arrange: register a stream wrapper that fails on read. */
        if (!in_array('failread', stream_get_wrappers(), true)) {
            stream_wrapper_register('failread', ExporterFailingReadStream::class);
        }

        $dir = $this->createTempDir();
        $exporter = new SpanJsonGzipRotatingFileExporter($dir . '/spans.jsonl');
        $method = new ReflectionMethod($exporter, 'gzipFile');
        $method->setAccessible(true);
        $target = $dir . '/failread.jsonl.gz';

        /* Act: gzip a stream that returns false on read. */
        $method->invoke($exporter, 'failread://source', $target, 9);

        /* Assert: verify the gzip file was created without errors. */
        $this->assertFileExists($target);
    }

    private function createSpanData(string $traceId, string $spanId): SpanDataInterface
    {
        $attributes = $this->createAttributes(['component' => 'logger']);
        $status = $this->createStatus('ok');

        $span = $this->createMock(SpanDataInterface::class);
        $span->method('getTraceId')->willReturn($traceId);
        $span->method('getSpanId')->willReturn($spanId);
        $span->method('getParentSpanId')->willReturn('parent');
        $span->method('getName')->willReturn('operation');
        $span->method('getKind')->willReturn(1);
        $span->method('getStartEpochNanos')->willReturn(100);
        $span->method('getEndEpochNanos')->willReturn(200);
        $span->method('getAttributes')->willReturn($attributes);
        $span->method('getStatus')->willReturn($status);

        return $span;
    }

    private function createAttributes(array $data): AttributesInterface
    {
        return new class ($data) implements AttributesInterface, IteratorAggregate {
            public function __construct(private array $data)
            {
            }

            public function getIterator(): Traversable
            {
                return new ArrayIterator($this->data);
            }

            public function count(): int
            {
                return count($this->data);
            }

            public function has(string $name): bool
            {
                return array_key_exists($name, $this->data);
            }

            public function get(string $name)
            {
                return $this->data[$name] ?? null;
            }

            public function getDroppedAttributesCount(): int
            {
                return 0;
            }

            public function toArray(): array
            {
                return $this->data;
            }
        };
    }

    private function createStatus(string $code): StatusDataInterface
    {
        return new class ($code) implements StatusDataInterface {
            public function __construct(private string $code)
            {
            }

            public static function ok(): StatusDataInterface
            {
                return new self('ok');
            }

            public static function error(): StatusDataInterface
            {
                return new self('error');
            }

            public static function unset(): StatusDataInterface
            {
                return new self('unset');
            }

            public function getCode(): string
            {
                return $this->code;
            }

            public function getDescription(): string
            {
                return '';
            }
        };
    }

    private function createTempDir(): string
    {
        $dir = sys_get_temp_dir() . '/span_exporter_' . uniqid();
        mkdir($dir, 0777, true);
        return $dir;
    }
}

/**
 * Stream wrapper that returns false on read.
 */
final class ExporterFailingReadStream
{
    public function stream_open(string $path, string $mode, int $options, ?string &$openedPath): bool
    {
        return true;
    }

    public function stream_read(int $count): string|false
    {
        return false;
    }

    public function stream_eof(): bool
    {
        return false;
    }

    public function stream_stat(): array
    {
        return [];
    }
}
