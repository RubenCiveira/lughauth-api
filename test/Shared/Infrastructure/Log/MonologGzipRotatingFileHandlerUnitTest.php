<?php

/* @autogenerated */
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use Monolog\Level;
use Civi\Lughauth\Shared\Infrastructure\Log\MonologGzipRotatingFileHandler;

/**
 * Unit tests for {@see MonologGzipRotatingFileHandler}.
 */
final class MonologGzipRotatingFileHandlerUnitTest extends TestCase
{
    /**
     * Ensures rotated files are gzipped and stale files removed.
     */
    public function testZipRotatedCompressesAndDeletesOldFiles(): void
    {
        /* Arrange: build a handler with dated log files in a temp directory. */
        $dir = $this->createTempDir();
        $dateFormat = 'Y-m-d';
        $handler = new MonologGzipRotatingFileHandler(
            $dir . '/app.log',
            4,
            Level::Debug,
            true,
            null,
            false,
            $dateFormat,
            '{filename}-{date}'
        );

        $today = (new DateTimeImmutable('now'))->format($dateFormat);
        $yesterday = (new DateTimeImmutable('-1 day'))->format($dateFormat);
        $older = (new DateTimeImmutable('-2 days'))->format($dateFormat);

        $todayFile = $dir . '/app-' . $today . '.log';
        $yesterdayFile = $dir . '/app-' . $yesterday . '.log';
        $olderFile = $dir . '/app-' . $older . '.log';
        $olderGzFile = $dir . '/app-' . $older . '.log.gz';
        $todayBackupFile = $dir . '/app-' . $today . '.log.bak';

        file_put_contents($todayFile, "today\n");
        file_put_contents($yesterdayFile, "yesterday\n");
        file_put_contents($olderFile, "older\n");
        file_put_contents($olderGzFile, 'gz');
        file_put_contents($todayBackupFile, 'backup');

        $method = new ReflectionMethod($handler, 'zipRotated');
        $method->setAccessible(true);

        /* Act: execute the rotation compression logic directly. */
        $method->invoke($handler);

        /* Assert: verify current logs remain and older logs are gzipped or deleted. */
        $this->assertFileExists($todayFile);
        $this->assertFileDoesNotExist($yesterdayFile);
        $this->assertFileExists($yesterdayFile . '.gz');
        $this->assertFileDoesNotExist($olderFile);
        $this->assertFileExists($olderGzFile);
        $this->assertFileExists($todayBackupFile);
    }

    /**
     * Ensures gzip creation handles invalid paths safely.
     */
    public function testGzipFileHandlesInvalidPaths(): void
    {
        /* Arrange: prepare a handler and sample source file for gzip attempts. */
        $dir = $this->createTempDir();
        $handler = new MonologGzipRotatingFileHandler($dir . '/app.log');
        $method = new ReflectionMethod($handler, 'gzipFile');
        $method->setAccessible(true);

        $source = $dir . '/sample.log';
        $invalidTarget = $dir . '/missing/sample.log.gz';
        $validTarget = $dir . '/sample.log.gz';
        file_put_contents($source, str_repeat('a', 10));

        /* Act: attempt gzip operations with invalid and valid paths. */
        $method->invoke($handler, $dir . '/missing.log', $validTarget, 9);
        $method->invoke($handler, $source, $invalidTarget, 9);
        $method->invoke($handler, $source, $validTarget, 9);

        /* Assert: verify gzip output is created only for the valid path. */
        $this->assertFileExists($validTarget);
        $this->assertFileDoesNotExist($invalidTarget);
    }

    /**
     * Ensures gzip writing stops when reading fails.
     */
    public function testGzipFileStopsOnReadFailure(): void
    {
        /* Arrange: register a stream wrapper that fails on read. */
        if (!in_array('failread', stream_get_wrappers(), true)) {
            stream_wrapper_register('failread', MonologFailingReadStream::class);
        }

        $dir = $this->createTempDir();
        $handler = new MonologGzipRotatingFileHandler($dir . '/app.log');
        $method = new ReflectionMethod($handler, 'gzipFile');
        $method->setAccessible(true);
        $target = $dir . '/failread.log.gz';

        /* Act: gzip a stream that returns false on read. */
        $method->invoke($handler, 'failread://source', $target, 9);

        /* Assert: verify the gzip file was created without errors. */
        $this->assertFileExists($target);
    }

    private function createTempDir(): string
    {
        $dir = sys_get_temp_dir() . '/log_handler_' . uniqid();
        mkdir($dir, 0777, true);
        return $dir;
    }
}

/**
 * Stream wrapper that returns false on read.
 */
final class MonologFailingReadStream
{
    public function stream_open(string $path, string $mode, int $options, ?string &$openedPath): bool
    {
        return true;
    }

    public function stream_read(int $count): string|false
    {
        return false;
    }

    public function stream_eof(): bool
    {
        return false;
    }

    public function stream_stat(): array
    {
        return [];
    }
}
