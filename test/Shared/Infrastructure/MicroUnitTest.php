<?php

/* @autogenerated */
declare(strict_types=1);

namespace {
    use DI\Container;
    use DI\ContainerBuilder;
    use PHPUnit\Framework\TestCase;
    use Psr\Container\ContainerInterface;
    use Psr\EventDispatcher\EventDispatcherInterface;
    use Psr\Http\Client\ClientInterface;
    use Psr\Http\Message\RequestFactoryInterface;
    use Psr\Http\Message\ResponseInterface;
    use Psr\Http\Message\ServerRequestInterface;
    use Psr\Http\Message\StreamFactoryInterface;
    use Psr\Log\LoggerInterface;
    use Psr\SimpleCache\CacheInterface;
    use Slim\App;
    use Slim\Middleware\ErrorMiddleware;
    use Slim\Psr7\Factory\ServerRequestFactory;
    use Slim\Psr7\Response;
    use Slim\Interfaces\RouteInterface;
    use Symfony\Component\Lock\LockFactory;
    use Symfony\Component\RateLimiter\Storage\StorageInterface;
    use Prometheus\CollectorRegistry;
    use OpenTelemetry\API\Trace\TracerInterface;
    use OpenTelemetry\Context\ContextInterface;
    use OpenTelemetry\SDK\Trace\ReadWriteSpanInterface;
    use OpenTelemetry\SDK\Trace\SpanExporterInterface;
    use OpenTelemetry\Contrib\Otlp\SpanExporter;
    use Civi\Lughauth\Shared\AppConfig;
    use Civi\Lughauth\Shared\Context;
    use Civi\Lughauth\Shared\Infrastructure\Micro;
    use Civi\Lughauth\Shared\Infrastructure\MicroConfig;
    use Civi\Lughauth\Shared\Infrastructure\MicroPlugin;
    use Civi\Lughauth\Shared\Infrastructure\Event\EventBus;
    use Civi\Lughauth\Shared\Infrastructure\Log\TraceContextProcessor;
    use Civi\Lughauth\Shared\Infrastructure\Log\SpanJsonGzipRotatingFileExporter;
    use Civi\Lughauth\Shared\Infrastructure\Management\ManagementInterface;
    use Civi\Lughauth\Shared\Infrastructure\Scheduler\SchedulerManager;
    use Civi\Lughauth\Shared\Infrastructure\StartupProcessor;
    use Civi\Lughauth\Shared\Infrastructure\Audit\AuditContext;
    use Civi\Lughauth\Shared\Infrastructure\InjectResourceAttrsProcessor;
    use Civi\Lughauth\Shared\Observability\TraceContext;
    use Civi\Lughauth\Shared\Infrastructure\Event\EnqueuePublisher;

    if (!class_exists('Redis')) {
        class Redis
        {
        }
    }

    if (!function_exists('fastcgi_finish_request')) {
        $GLOBALS['fastcgi_defined_for_test'] = true;
        function fastcgi_finish_request(): bool
        {
            $GLOBALS['fastcgi_called'] = true;
            return true;
        }
    }

    final class ArrayContainer implements ContainerInterface
    {
        public function __construct(private array $entries)
        {
        }

        public function get(string $id)
        {
            return $this->entries[$id];
        }

        public function has(string $id): bool
        {
            return array_key_exists($id, $this->entries);
        }
    }

    final class TestManagement implements ManagementInterface
    {
        public function __construct(
            private readonly string $name,
            private readonly ?Closure $get,
            private readonly ?Closure $set
        ) {
        }

        public function name(): string
        {
            return $this->name;
        }

        public function get(): ?Closure
        {
            return $this->get;
        }

        public function set(): ?Closure
        {
            return $this->set;
        }
    }

    final class SchedulerManagerStub extends SchedulerManager
    {
        public bool $ran = false;
        public array $registered = [];

        public function register($expression, string $type, string $method): void
        {
            $this->registered[] = [$expression, $type, $method];
        }

        public function run(LockFactory $locker, CacheInterface $cache, ContainerInterface $container): void
        {
            $this->ran = true;
        }
    }

    final class MicroPluginProbe extends MicroPlugin
    {
        public bool $bindCalled = false;
        public bool $startupRan = false;

        /** @param ManagementInterface[] $interfaces */
        public function __construct(private readonly array $interfaces)
        {
        }

        public function bindServices(Container $container): void
        {
            $this->bindCalled = true;
        }

        public function registerStartup(StartupProcessor $processor): void
        {
            $processor->register(function (ContainerInterface $container): void {
                $this->startupRan = true;
            });
        }

        public function getManagementsInterfaces(ContainerInterface $container): array
        {
            return $this->interfaces;
        }

        public function registerServiceDefinition(array $def): array
        {
            $def['probe.service'] = 'probe';
            return $def;
        }
    }

    final class ScriptNameMicro extends Micro
    {
        public function __construct(ContainerBuilder $depenencies)
        {
            parent::__construct($depenencies);
        }

        public function exposeResolveScriptName(): string
        {
            return $this->resolveScriptName();
        }
    }

    final class StoreDirMicro extends Micro
    {
        public function __construct(ContainerBuilder $depenencies, private readonly string $baseDir)
        {
            parent::__construct($depenencies);
        }

        protected function storeDir(string $path): string
        {
            $base = rtrim($this->baseDir, '/') . '/var';
            $path = ltrim($path, '/');
            return $path === '' ? $base : $base . '/' . $path;
        }
    }

    /**
     * Unit tests for {@see Micro}.
     */
    final class MicroUnitTest extends TestCase
    {
        private array $envBackup = [];
        private array $serverBackup = [];
        private int $outputBufferLevel = 0;

        protected function setUp(): void
        {
            $this->outputBufferLevel = ob_get_level();
            $this->envBackup = $_ENV;
            $this->serverBackup = $_SERVER;

            $_SERVER['SCRIPT_NAME'] = '/index.php';
            $_SERVER['SERVER_NAME'] = 'localhost';
            $_SERVER['SERVER_PORT'] = '80';
            $_SERVER['REQUEST_METHOD'] = 'GET';
            $_SERVER['REQUEST_URI'] = '/';

            $_ENV['APP_NAME'] = 'micro-test';
            $_ENV['DATABASE_URL'] = 'sqlite::memory:';
            $_ENV['DATABASE_USERNAME'] = '';
            $_ENV['DATABASE_PASSWORD'] = '';
            $_ENV['APP_STATE_VAULT_ENGINE'] = 'file';

            $this->ensureSchedulerPidFile();
            $this->removeStartupFlag();
            $this->removeCacheDefinitions();
        }

        protected function tearDown(): void
        {
            while (ob_get_level() > $this->outputBufferLevel) {
                ob_end_clean();
            }
            $_ENV = $this->envBackup;
            $_SERVER = $this->serverBackup;
            if (!isset($_SERVER['SCRIPT_NAME'])) {
                $_SERVER['SCRIPT_NAME'] = '/index.php';
            }
            if (!isset($_SERVER['SERVER_NAME'])) {
                $_SERVER['SERVER_NAME'] = 'localhost';
            }
            if (!isset($_SERVER['SERVER_PORT'])) {
                $_SERVER['SERVER_PORT'] = '80';
            }
        }

        /**
         * Ensures build wires plugin hooks and management interfaces.
         */
        public function testBuildRegistersPluginsAndInterfaces(): void
        {
            /*
             * Arrange: create a container builder with core services and register a probe plugin.
             */
            $builder = new ContainerBuilder();
            $eventBus = $this->createEventBusStub();
            $builder->addDefinitions([
                EventBus::class => $eventBus,
                SchedulerManager::class => new SchedulerManagerStub(),
            ]);

            $management = new TestManagement('probe', fn (): array => ['ok' => true], null);
            $plugin = new MicroPluginProbe([$management]);
            $micro = new Micro($builder);
            $micro->register($plugin);

            /*
             * Act: build the Micro container and wiring.
             */
            $this->invokePrivate($micro, 'build');

            /*
             * Assert: verify core services are initialized and plugin hooks ran.
             */
            $this->assertInstanceOf(App::class, $micro->app);
            $this->assertInstanceOf(AppConfig::class, $micro->config);
            $this->assertInstanceOf(MicroConfig::class, $micro->definition);
            $this->assertInstanceOf(ErrorMiddleware::class, $micro->errorHandler);
            $this->assertTrue($plugin->bindCalled);
            $this->assertSame('probe', $micro->container->get('probe.service'));

            $interfaces = $this->getPrivateProperty($micro, 'interfaces');
            $this->assertContains($management, $interfaces);
        }

        /**
         * Confirms cached DI definitions are loaded when present.
         */
        public function testBuildUsesCachedDefinitionsFile(): void
        {
            /*
             * Arrange: create a cache file with a known service definition.
             */
            $cacheFile = $this->cacheDefinitionsPath();
            $cacheDir = dirname($cacheFile);
            if (!is_dir($cacheDir)) {
                mkdir($cacheDir, 0777, true);
            }
            file_put_contents($cacheFile, "<?php return ['cached.service' => 'cached'];");

            $builder = new ContainerBuilder();
            $builder->addDefinitions([
                EventBus::class => $this->createEventBusStub(),
                SchedulerManager::class => new SchedulerManagerStub(),
            ]);
            $micro = new Micro($builder);

            /*
             * Act: build the container which should read the cached definitions file.
             */
            $this->invokePrivate($micro, 'build');

            /*
             * Assert: verify cached service definition is available.
             */
            $this->assertSame('cached', $micro->container->get('cached.service'));
        }

        /**
         * Verifies management routing handles different return payload types.
         */
        public function testRegisterManagersRoutesHandleResponses(): void
        {
            /*
             * Arrange: create test management interfaces and a mocked Slim app.
             */
            $interfaces = [];
            $interfaces[] = new TestManagement(
                'direct',
                function (ServerRequestInterface $request, ResponseInterface $response): ResponseInterface {
                    $response = new Response();
                    $response->getBody()->write('direct');
                    return $response;
                },
                null
            );
            $interfaces[] = new TestManagement(
                'html',
                function (ServerRequestInterface $request, ResponseInterface $response): string {
                    return '<html>ok</html>';
                },
                null
            );
            $interfaces[] = new TestManagement(
                'text',
                function (ServerRequestInterface $request, ResponseInterface $response): string {
                    return 'ok';
                },
                null
            );
            $interfaces[] = new TestManagement(
                'json',
                function (ServerRequestInterface $request, ResponseInterface $response): array {
                    return ['ok' => true];
                },
                null
            );
            $interfaces[] = new TestManagement(
                'set-text',
                null,
                function (ServerRequestInterface $request, array $data): string {
                    return 'saved';
                }
            );
            $interfaces[] = new TestManagement(
                'set-json',
                null,
                function (ServerRequestInterface $request, array $data): array {
                    return ['saved' => true];
                }
            );

            $app = $this->createMock(App::class);
            $routes = ['get' => [], 'post' => []];
            $app->method('get')->willReturnCallback(function (string $pattern, callable $callable) use (&$routes) {
                $routes['get'][$pattern] = $callable;
                return $this->createMock(RouteInterface::class);
            });
            $app->method('post')->willReturnCallback(function (string $pattern, callable $callable) use (&$routes) {
                $routes['post'][$pattern] = $callable;
                return $this->createMock(RouteInterface::class);
            });

            $container = new ArrayContainer([
                AppConfig::class => new AppConfig($this->rootDir()),
            ]);
            $micro = new Micro(new ContainerBuilder());
            $this->setPrivateProperty($micro, 'interfaces', $interfaces);

            /*
             * Act: register management routes and invoke handlers.
             */
            $this->invokePrivate($micro, 'registerManagers', [$app, $container]);

            $requestFactory = new ServerRequestFactory();
            $listResponse = $routes['get']['/management'](
                $requestFactory->createServerRequest('GET', '/management'),
                new Response()
            );
            $listPayload = json_decode((string) $listResponse->getBody(), true);
            $urls = array_map(fn (array $item): string => $item['url'], $listPayload);
            /*
             * Assert: list endpoint returns expected URLs.
             */
            $this->assertContains('./direct', $urls);
            $this->assertContains('./set-text', $urls);

            /*
             * Assert: handlers set content types for different return types.
             */
            $direct = $routes['get']['/management/direct'](
                $requestFactory->createServerRequest('GET', '/management/direct'),
                new Response()
            );
            $this->assertSame('direct', (string) $direct->getBody());

            $html = $routes['get']['/management/html'](
                $requestFactory->createServerRequest('GET', '/management/html'),
                new Response()
            );
            $this->assertSame('text/html', $html->getHeaderLine('Content-Type'));

            $text = $routes['get']['/management/text'](
                $requestFactory->createServerRequest('GET', '/management/text'),
                new Response()
            );
            $this->assertSame('text/plain', $text->getHeaderLine('Content-Type'));

            $json = $routes['get']['/management/json'](
                $requestFactory->createServerRequest('GET', '/management/json'),
                new Response()
            );
            $this->assertSame('application/json', $json->getHeaderLine('Content-Type'));

            $postRequest = $requestFactory->createServerRequest('POST', '/management/set-text')
                ->withParsedBody(['ok' => true]);
            $setText = $routes['post']['/management/set-text']($postRequest, new Response());
            $this->assertSame('text/plain', $setText->getHeaderLine('Content-Type'));

            $postRequest = $requestFactory->createServerRequest('POST', '/management/set-json')
                ->withParsedBody(['ok' => true]);
            $setJson = $routes['post']['/management/set-json']($postRequest, new Response());
            $this->assertSame('application/json', $setJson->getHeaderLine('Content-Type'));
        }

        /**
         * Ensures CRON mode executes startup tasks and scheduler.
         */
        public function testRunCronPathExecutesStartupAndScheduler(): void
        {
            /*
             * Arrange: enable CRON mode and register a plugin.
             */
            $_ENV['CRON'] = '1';

            $scheduler = new SchedulerManagerStub();
            $builder = new ContainerBuilder();
            $builder->addDefinitions([
                EventBus::class => $this->createEventBusStub(),
                SchedulerManager::class => $scheduler,
            ]);

            $plugin = new MicroPluginProbe([]);
            $micro = new Micro($builder);
            $micro->register($plugin);

            /*
             * Act: run Micro in CRON mode.
             */
            ob_start();
            $micro->run();
            ob_end_clean();

            /*
             * Assert: startup tasks and scheduler have executed.
             */
            $this->assertTrue($plugin->startupRan);
            $this->assertTrue($scheduler->ran);
            $this->assertTrue(file_exists($this->startupFlagPath()));
        }

        /**
         * Ensures HTTP mode runs the Slim app and finishes response.
         */
        public function testRunHttpPathInvokesAppRunAndFastcgi(): void
        {
            /*
             * Arrange: ensure CRON mode is disabled and setup dependencies.
             */
            unset($_ENV['CRON']);
            $GLOBALS['fastcgi_called'] = false;

            $builder = new ContainerBuilder();
            $builder->addDefinitions([
                EventBus::class => $this->createEventBusStub(),
                SchedulerManager::class => new SchedulerManagerStub(),
            ]);
            $micro = new Micro($builder);

            /*
             * Act: run Micro in HTTP mode.
             */
            ob_start();
            $micro->run();
            ob_end_clean();

            /*
             * Assert: fastcgi_finish_request is invoked when available.
             */
            if (!empty($GLOBALS['fastcgi_defined_for_test'])) {
                $this->assertTrue($GLOBALS['fastcgi_called']);
            }
        }

        /**
         * Confirms error handler outputs trace and returns a response.
         */
        public function testErrorHandlerOutputsTraceAndReturnsResponse(): void
        {
            /*
             * Arrange: build the Micro instance.
             */
            $_ENV['DISABLE_SUPERVISOR'] = '1';
            $builder = new ContainerBuilder();
            $builder->addDefinitions([
                EventBus::class => $this->createEventBusStub(),
                SchedulerManager::class => new SchedulerManagerStub(),
            ]);
            $micro = new Micro($builder);
            $this->invokePrivate($micro, 'build');

            $errorHandler = $micro->errorHandler;

            /*
             * Act: trigger the handler and capture output.
             */
            ob_start();
            $requestFactory = new ServerRequestFactory();
            $request = $requestFactory->createServerRequest('GET', '/error');
            $response = $errorHandler->handleException($request, new Exception('boom'));
            $output = ob_get_clean();

            /*
             * Assert: handler echoed trace and returned response.
             */
            $this->assertInstanceOf(ResponseInterface::class, $response);
            $this->assertNotSame('', $output);
            unset($_ENV['DISABLE_SUPERVISOR']);
        }

        /**
         * Ensures vardir is created when missing during run.
         */
        public function testRunCreatesVarDirectoryWhenMissing(): void
        {
            /*
             * Arrange: move existing var directory aside and enable CRON mode.
             */
            $vardir = $this->rootDir() . '/var';
            $backupDir = $vardir . '-backup-' . uniqid('', true);
            if (is_dir($vardir)) {
                rename($vardir, $backupDir);
            }
            $_ENV['CRON'] = '1';

            $builder = new ContainerBuilder();
            $builder->addDefinitions([
                EventBus::class => $this->createEventBusStub(),
                SchedulerManager::class => new SchedulerManagerStub(),
            ]);
            $micro = new Micro($builder);

            try {
                /*
                 * Act: run Micro to trigger vardir creation.
                 */
                ob_start();
                $micro->run();
                ob_end_clean();

                /*
                 * Assert: vardir exists after run.
                 */
                $this->assertTrue(is_dir($vardir));
            } finally {
                unset($_ENV['CRON']);
                if (is_dir($vardir)) {
                    $this->removeDirectory($vardir);
                }
                if (is_dir($backupDir)) {
                    rename($backupDir, $vardir);
                }
            }
        }

        /**
         * Ensures empty SCRIPT_NAME resolves to index.php.
         */
        public function testResolveScriptNameAddsIndexPhpWhenEmpty(): void
        {
            /*
             * Arrange: set an empty script name.
             */
            $_SERVER['SCRIPT_NAME'] = '';
            $micro = new ScriptNameMicro(new ContainerBuilder());

            /*
             * Act: resolve the script name.
             */
            $resolved = $micro->exposeResolveScriptName();

            /*
             * Assert: empty value is replaced with /index.php.
             */
            $this->assertSame('/index.php', $resolved);
        }

        /**
         * Ensures cache directory is created when missing.
         */
        public function testWithCacheCreatesDirectoryWhenMissing(): void
        {
            /*
             * Arrange: move existing cache directory aside.
             */
            $cacheDir = $this->rootDir() . '/var/cache';
            $backupDir = $cacheDir . '-backup-' . uniqid('', true);
            if (is_dir($cacheDir)) {
                rename($cacheDir, $backupDir);
            }
            $_ENV['APP_STATE_VAULT_ENGINE'] = 'file';

            $builder = new ContainerBuilder();
            $micro = new Micro($builder);
            $defs = [];
            $this->invokePrivate($micro, 'withCache', [&$defs]);
            $config = new AppConfig($this->rootDir());

            try {
                /*
                 * Act: build the cache implementation.
                 */
                $cache = $defs[CacheInterface::class]($config);

                /*
                 * Assert: cache directory exists after building.
                 */
                $this->assertInstanceOf(CacheInterface::class, $cache);
                $this->assertTrue(is_dir($cacheDir));
            } finally {
                if (is_dir($cacheDir)) {
                    $this->removeDirectory($cacheDir);
                }
                if (is_dir($backupDir)) {
                    rename($backupDir, $cacheDir);
                }
            }
        }

        /**
         * Ensures run creates the vardir when missing.
         */
        public function testRunCreatesVarDirectoryWhenMissingViaStoreDir(): void
        {
            /*
             * Arrange: create a Micro subclass with a temporary store directory.
             */
            $_ENV['CRON'] = '1';
            $_ENV['DISABLE_SUPERVISOR'] = '1';
            $baseDir = $this->rootDir() . '/var-test-' . uniqid('', true);
            $vardir = $baseDir . '/var';
            if (is_dir($baseDir)) {
                $this->removeDirectory($baseDir);
            }
            $this->assertFalse(is_dir($vardir));

            $builder = new ContainerBuilder();
            $builder->addDefinitions([
                EventBus::class => $this->createEventBusStub(),
                SchedulerManager::class => new SchedulerManagerStub(),
            ]);
            $micro = new StoreDirMicro($builder, $baseDir);

            try {
                /*
                 * Act: run Micro and let it create vardir.
                 */
                ob_start();
                $micro->run();
                ob_end_clean();

                /*
                 * Assert: vardir exists after run.
                 */
                $this->assertTrue(is_dir($vardir));
            } finally {
                unset($_ENV['CRON'], $_ENV['DISABLE_SUPERVISOR']);
                $this->removeDirectory($baseDir);
            }
        }

        /**
         * Ensures run creates a random store directory when missing.
         */
        public function testRunCreatesRandomStoreDirWhenMissing(): void
        {
            /*
             * Arrange: use a random, non-existing store directory.
             */
            $_ENV['CRON'] = '1';
            $_ENV['DISABLE_SUPERVISOR'] = '1';
            $baseDir = rtrim(sys_get_temp_dir(), '/') . '/micro-store-' . uniqid('', true);
            $vardir = $baseDir . '/var';
            if (is_dir($baseDir)) {
                $this->removeDirectory($baseDir);
            }
            $this->assertFalse(is_dir($vardir));

            $builder = new ContainerBuilder();
            $builder->addDefinitions([
                EventBus::class => $this->createEventBusStub(),
                SchedulerManager::class => new SchedulerManagerStub(),
            ]);
            $micro = new StoreDirMicro($builder, $baseDir);

            try {
                /*
                 * Act: run Micro and let it create vardir.
                 */
                $micro->run();

                /*
                 * Assert: vardir exists after run.
                 */
                $this->assertTrue(is_dir($vardir));
            } finally {
                unset($_ENV['CRON'], $_ENV['DISABLE_SUPERVISOR']);
                $this->removeDirectory($baseDir);
            }
        }


        /**
         * Verifies background supervisor URL generation does not crash.
         */
        public function testEnsureBackgroundSupervisorBuildsUrl(): void
        {
            /*
             * Arrange: configure server globals to build a URL.
             */
            $_SERVER['HTTPS'] = 'on';
            $_SERVER['SERVER_NAME'] = 'example.com';
            $_SERVER['SERVER_PORT'] = '443';
            $_SERVER['SCRIPT_NAME'] = '/app/index.php';

            $micro = new Micro(new ContainerBuilder());
            /*
             * Act: call the supervisor bootstrap method.
             */
            $this->invokePrivate($micro, 'ensureBackgroundSupervisor');

            /*
             * Assert: no exception thrown during URL generation.
             */
            $this->assertTrue(true);
        }

        /**
         * Ensures DISABLE_SUPERVISOR returns early without touching lock file.
         */
        public function testEnsureBackgroundSupervisorReturnsEarlyWhenDisabled(): void
        {
            /*
             * Arrange: enable DISABLE_SUPERVISOR and clear lock file.
             */
            $_ENV['DISABLE_SUPERVISOR'] = '1';
            $lockFile = $this->rootDir() . '/var/scheduler.lock';
            if (file_exists($lockFile)) {
                unlink($lockFile);
            }
            $this->assertFalse(file_exists($lockFile));

            $micro = new Micro(new ContainerBuilder());

            try {
                /*
                 * Act: call supervisor bootstrap.
                 */
                $this->invokePrivate($micro, 'ensureBackgroundSupervisor');

                /*
                 * Assert: lock file was not created.
                 */
                $this->assertFalse(file_exists($lockFile));
            } finally {
                unset($_ENV['DISABLE_SUPERVISOR']);
                if (file_exists($lockFile)) {
                    unlink($lockFile);
                }
            }
        }

        /**
         * Ensures telemetry exporter uses a remote endpoint when configured.
         */
        public function testWithTelemetryBuildsRemoteExporter(): void
        {
            /*
             * Arrange: configure a remote telemetry collector endpoint.
             */
            $_ENV['APP_TELEMETRY_COLLECTOR_URL'] = 'http://example.test/v1/traces';

            $builder = new ContainerBuilder();
            $micro = new Micro($builder);
            $defs = [];
            $this->setPrivateProperty($micro, 'definition', new MicroConfig());
            $this->invokePrivate($micro, 'withTelementry', [&$defs]);

            $config = new AppConfig($this->rootDir());

            /*
             * Act: build the telemetry exporter.
             */
            $exporter = $defs[SpanExporterInterface::class]($config);

            /*
             * Assert: exporter is the remote OTLP span exporter.
             */
            $this->assertInstanceOf(SpanExporter::class, $exporter);
        }

        /**
         * Ensures telemetry exporter uses local files and creates directory.
         */
        public function testWithTelemetryBuildsFileExporterAndCreatesDirectory(): void
        {
            /*
             * Arrange: configure local telemetry output path.
             */
            unset($_ENV['APP_TELEMETRY_COLLECTOR_URL']);
            $base = $this->rootDir() . '/var/trace-test-' . uniqid('', true);
            $_ENV['APP_TELEMETRY_EXPORTER_PATH'] = $base;
            if (is_dir($base)) {
                rmdir($base);
            }

            $builder = new ContainerBuilder();
            $micro = new Micro($builder);
            $defs = [];
            $this->setPrivateProperty($micro, 'definition', new MicroConfig());
            $this->invokePrivate($micro, 'withTelementry', [&$defs]);

            $config = new AppConfig($this->rootDir());

            /*
             * Act: build the telemetry exporter.
             */
            $exporter = $defs[SpanExporterInterface::class]($config);

            /*
             * Assert: exporter is file-based and directory was created.
             */
            $this->assertInstanceOf(SpanJsonGzipRotatingFileExporter::class, $exporter);
            $this->assertTrue(is_dir($base));

            rmdir($base);
        }

        /**
         * Validates internal wiring factories for dependencies.
         */
        public function testPrivateWiringFactories(): void
        {
            /*
             * Arrange: create a Micro instance and initialize definitions.
             */
            $builder = new ContainerBuilder();
            $micro = new Micro($builder);
            $defs = [];

            $this->setPrivateProperty($micro, 'definition', new MicroConfig());

            $this->invokePrivate($micro, 'withContainer', [&$defs, $builder]);
            $this->invokePrivate($micro, 'withCache', [&$defs]);
            $this->invokePrivate($micro, 'withLock', [&$defs]);
            $this->invokePrivate($micro, 'withLogging', [&$defs]);
            $this->invokePrivate($micro, 'withHttpClient', [&$defs]);
            $this->invokePrivate($micro, 'withEventBus', [&$defs]);
            $this->invokePrivate($micro, 'withRate', [&$defs]);
            $this->invokePrivate($micro, 'withMetrics', [&$defs]);
            $this->invokePrivate($micro, 'withTelementry', [&$defs]);
            $this->invokePrivate($micro, 'withAudit', [&$defs]);
            $this->invokePrivate($micro, 'withDatabase', [&$defs]);

            /*
             * Act: build and resolve service factories from definitions.
             */
            $config = new AppConfig($this->rootDir());
            $traceContext = new TraceContext([]);
            $context = new Context(new ContainerBuilder(), $config);
            $processor = new TraceContextProcessor($traceContext, $context);

            /*
             * Assert: core services and factories are created correctly.
             */
            $logger = $defs[LoggerInterface::class]($config, $processor);
            $this->assertInstanceOf(LoggerInterface::class, $logger);

            $requestFactory = $defs[RequestFactoryInterface::class]();
            $streamFactory = $defs[StreamFactoryInterface::class]();
            $httpClient = $defs[ClientInterface::class]();
            $this->assertInstanceOf(RequestFactoryInterface::class, $requestFactory);
            $this->assertInstanceOf(StreamFactoryInterface::class, $streamFactory);
            $this->assertInstanceOf(ClientInterface::class, $httpClient);

            $_ENV['APP_STATE_VAULT_ENGINE'] = 'file';
            $filesystemCache = $defs[CacheInterface::class]($config);
            $filesystemLock = $defs[LockFactory::class]($config);
            $filesystemStorage = $defs[StorageInterface::class](new ArrayContainer([
                \PDO::class => new \PDO('sqlite::memory:'),
            ]), $config);
            $this->assertInstanceOf(CacheInterface::class, $filesystemCache);
            $this->assertInstanceOf(LockFactory::class, $filesystemLock);
            $this->assertInstanceOf(StorageInterface::class, $filesystemStorage);

            $metricsFs = $defs[\Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\MetricsFS::class]();
            $metricsPolicy = $defs[\Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\TimeWindowPolicy::class]();
            $registryFile = $defs[CollectorRegistry::class](new ArrayContainer([
                \PDO::class => new \PDO('sqlite::memory:'),
            ]), $config);
            $this->assertInstanceOf(\Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\MetricsFS::class, $metricsFs);
            $this->assertInstanceOf(\Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\TimeWindowPolicy::class, $metricsPolicy);
            $this->assertInstanceOf(CollectorRegistry::class, $registryFile);

            $_ENV['APP_STATE_VAULT_ENGINE'] = 'redis';
            $redisCache = $defs[CacheInterface::class]($config);
            $redisLock = $defs[LockFactory::class]($config);
            $redisStorage = $defs[StorageInterface::class](new ArrayContainer([
                \PDO::class => new \PDO('sqlite::memory:'),
            ]), $config);
            $this->assertInstanceOf(CacheInterface::class, $redisCache);
            $this->assertInstanceOf(LockFactory::class, $redisLock);
            $this->assertInstanceOf(StorageInterface::class, $redisStorage);

            $registryRedis = $defs[CollectorRegistry::class](new ArrayContainer([
                \PDO::class => new \PDO('sqlite::memory:'),
            ]), $config);
            $this->assertInstanceOf(CollectorRegistry::class, $registryRedis);

            $exporter = $defs[SpanExporterInterface::class]($config);
            $tracer = $defs[TracerInterface::class]($exporter, $config, $context);
            $this->assertInstanceOf(SpanExporterInterface::class, $exporter);
            $this->assertInstanceOf(TracerInterface::class, $tracer);

            $eventBus = $this->createEventBusStub();
            $dispatcher = $defs[EventDispatcherInterface::class]($eventBus);
            $registrar = $defs[\Civi\Lughauth\Shared\Event\EventListenersRegistrarInterface::class]($eventBus);
            $this->assertInstanceOf(EventDispatcherInterface::class, $dispatcher);
            $this->assertSame($eventBus, $registrar);

            $directPdo = $defs['DIRECT_PDO']($config);
            $auditBuilder = new ContainerBuilder();
            $auditBuilder->addDefinitions([
                AuditContext::class => new AuditContext(),
            ]);
            $auditContainer = $auditBuilder->build();
            $auditablePdo = $defs[\PDO::class]($auditContainer, $config);
            $this->assertInstanceOf(\PDO::class, $directPdo);
            $this->assertInstanceOf(\PDO::class, $auditablePdo);

            /*
             * Arrange: prepare a Micro instance with audit disabled.
             */
            $microNoAudit = new Micro(new ContainerBuilder(), $this->createMicroConfig([
                'withAudit' => false,
                'withRate' => false,
                'withMetrics' => false,
                'withTelemetry' => false,
                'withManagement' => false,
            ]));
            $this->setPrivateProperty($microNoAudit, 'definition', $this->createMicroConfig([
                'withAudit' => false,
                'withRate' => false,
                'withMetrics' => false,
                'withTelemetry' => false,
                'withManagement' => false,
            ]));
            $defsNoAudit = [];
            /*
             * Act: resolve PDO factory without audit wrapper.
             */
            $this->invokePrivate($microNoAudit, 'withDatabase', [&$defsNoAudit]);
            $plainPdo = $defsNoAudit[\PDO::class]($config);
            /*
             * Assert: a plain PDO instance is returned.
             */
            $this->assertInstanceOf(\PDO::class, $plainPdo);
        }

        /**
         * Ensures resource attributes are injected into spans.
         */
        public function testInjectResourceAttrsProcessorAddsAttributes(): void
        {
            /*
             * Arrange: create a processor with a mocked span.
             */
            $config = new AppConfig($this->rootDir());
            $context = new Context(new ContainerBuilder(), $config);
            $exporter = $this->createMock(SpanExporterInterface::class);
            $processor = new InjectResourceAttrsProcessor($exporter, $context);

            $span = $this->createMock(ReadWriteSpanInterface::class);
            $span->expects($this->atLeastOnce())->method('setAttribute');

            /*
             * Act: start the processor.
             */
            $processor->onStart($span, $this->createMock(ContextInterface::class));

            /*
             * Assert: setAttribute is invoked on the span.
             */
        }

        private function invokePrivate(object $target, string $method, array $args = [])
        {
            $ref = new \ReflectionMethod($target, $method);
            $ref->setAccessible(true);
            return $ref->invokeArgs($target, $args);
        }

        private function getPrivateProperty(object $target, string $property)
        {
            $ref = new \ReflectionProperty($target, $property);
            $ref->setAccessible(true);
            return $ref->getValue($target);
        }

        private function setPrivateProperty(object $target, string $property, mixed $value): void
        {
            $ref = new \ReflectionProperty($target, $property);
            $ref->setAccessible(true);
            $ref->setValue($target, $value);
        }

        private function createEventBusStub(): EventBus
        {
            $publisher = $this->createMock(EnqueuePublisher::class);
            $container = new ArrayContainer([
                EnqueuePublisher::class => $publisher,
            ]);
            return new EventBus($container);
        }

        private function createMicroConfig(array $flags): MicroConfig
        {
            $class = MicroConfig::class;
            $values = [
                'withRate' => $flags['withRate'] ?? true,
                'withMetrics' => $flags['withMetrics'] ?? true,
                'withTelemetry' => $flags['withTelemetry'] ?? true,
                'withManagement' => $flags['withManagement'] ?? true,
                'withAudit' => $flags['withAudit'] ?? true,
            ];
            $serialized = sprintf(
                'O:%d:"%s":5:{s:8:"withRate";b:%d;s:11:"withMetrics";b:%d;s:13:"withTelemetry";b:%d;s:14:"withManagement";b:%d;s:9:"withAudit";b:%d;}',
                strlen($class),
                $class,
                $values['withRate'] ? 1 : 0,
                $values['withMetrics'] ? 1 : 0,
                $values['withTelemetry'] ? 1 : 0,
                $values['withManagement'] ? 1 : 0,
                $values['withAudit'] ? 1 : 0
            );
            return unserialize($serialized);
        }

        private function rootDir(): string
        {
            return dirname(__DIR__, 3);
        }

        private function startupFlagPath(): string
        {
            return $this->rootDir() . '/var/startup.flag';
        }

        private function ensureSchedulerPidFile(): void
        {
            $pidFile = $this->rootDir() . '/var/scheduler.pid';
            $dir = dirname($pidFile);
            if (!is_dir($dir)) {
                mkdir($dir, 0777, true);
            }
            file_put_contents($pidFile, (string) getmypid());
        }

        private function removeStartupFlag(): void
        {
            $flag = $this->startupFlagPath();
            if (file_exists($flag)) {
                unlink($flag);
            }
        }

        private function cacheDefinitionsPath(): string
        {
            return $this->rootDir() . '/var/cache/di-definitions.php';
        }

        private function removeCacheDefinitions(): void
        {
            $file = $this->cacheDefinitionsPath();
            if (file_exists($file)) {
                unlink($file);
            }
        }

        private function removeDirectory(string $path): void
        {
            if (!is_dir($path)) {
                return;
            }
            $items = scandir($path);
            if ($items === false) {
                return;
            }
            foreach ($items as $item) {
                if ($item === '.' || $item === '..') {
                    continue;
                }
                $itemPath = $path . DIRECTORY_SEPARATOR . $item;
                if (is_dir($itemPath)) {
                    $this->removeDirectory($itemPath);
                } else {
                    unlink($itemPath);
                }
            }
            rmdir($path);
        }
    }
}
