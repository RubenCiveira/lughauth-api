<?php

/* @autogenerated */
declare(strict_types=1);

use Interop\Amqp\Impl\AmqpMessage;
use Interop\Amqp\Impl\AmqpQueue;
use Interop\Amqp\Impl\AmqpTopic;

if (!class_exists('FakeAmqpConnectionFactory')) {
    class FakeAmqpConnectionFactory
    {
        public static $contextFactory = null;

        public function __construct(private readonly array $config = [])
        {
        }

        public function createContext(): FakeAmqpContext
        {
            if (self::$contextFactory) {
                $factory = self::$contextFactory;
                return $factory($this->config);
            }
            return new FakeAmqpContext();
        }
    }

    class FakeAmqpContext
    {
        public array $topics = [];
        public array $queues = [];
        public array $bindings = [];
        public array $messages = [];
        public array $qos = [];

        public function __construct(array $messages = [])
        {
            $this->messages = $messages;
        }

        public function createTopic(string $name, bool $durable = false, bool $autoDelete = false, bool $internal = false, bool $passive = false): AmqpTopic
        {
            $topic = new AmqpTopic($name);
            $this->topics[] = $topic;
            return $topic;
        }

        public function declareTopic(AmqpTopic $topic): void
        {
        }

        public function createQueue(string $name): AmqpQueue
        {
            $queue = new AmqpQueue($name);
            $this->queues[] = $queue;
            return $queue;
        }

        public function declareQueue(AmqpQueue $queue): void
        {
        }

        public function bind(object $binding): void
        {
            $this->bindings[] = $binding;
        }

        public function setQos(int $prefetchSize, int $prefetchCount, bool $global): void
        {
            $this->qos = [$prefetchSize, $prefetchCount, $global];
        }

        public function createConsumer(AmqpQueue $queue): FakeAmqpConsumer
        {
            return new FakeAmqpConsumer($this->messages);
        }

        public function createMessage(string $body): AmqpMessage
        {
            $message = new AmqpMessage($body);
            return $message;
        }

        public function createProducer(): FakeAmqpProducer
        {
            return new FakeAmqpProducer();
        }
    }

    class FakeAmqpConsumer
    {
        public int $acked = 0;
        public int $rejected = 0;

        public function __construct(private array $messages)
        {
        }

        public function receiveNoWait(): ?FakeAmqpIncomingMessage
        {
            if (empty($this->messages)) {
                return null;
            }
            return array_shift($this->messages);
        }

        public function receive(int $timeout): ?FakeAmqpIncomingMessage
        {
            return $this->receiveNoWait();
        }

        public function acknowledge(FakeAmqpIncomingMessage $message): void
        {
            $this->acked++;
        }

        public function reject(FakeAmqpIncomingMessage $message, bool $requeue): void
        {
            $this->rejected++;
        }
    }

    class FakeAmqpProducer
    {
        public array $sent = [];

        public function send(object $exchange, AmqpMessage $message): void
        {
            $this->sent[] = [$exchange, $message];
        }
    }

    class FakeAmqpIncomingMessage
    {
        public function __construct(private readonly string $body)
        {
        }

        public function getBody(): string
        {
            return $this->body;
        }
    }

    if (!class_exists('Enqueue\\AmqpLib\\AmqpConnectionFactory', false)) {
        class_alias(FakeAmqpConnectionFactory::class, 'Enqueue\\AmqpLib\\AmqpConnectionFactory');
    }
}
