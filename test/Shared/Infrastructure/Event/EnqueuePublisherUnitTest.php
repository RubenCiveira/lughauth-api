<?php

/* @autogenerated */
declare(strict_types=1);

require_once __DIR__ . '/EnqueueTestStubs.php';

use PHPUnit\Framework\TestCase;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Event\PublicEvent;
use Civi\Lughauth\Shared\Infrastructure\Event\EnqueuePublisher;
use Civi\Lughauth\Shared\Infrastructure\Sql\SqlParam;
use Civi\Lughauth\Shared\Infrastructure\Sql\SqlTemplate;
use Civi\Lughauth\Shared\Observability\TraceContext;

/**
 * Unit tests for {@see EnqueuePublisher}.
 */
final class EnqueuePublisherUnitTest extends TestCase
{
    /**
     * Ensures events are skipped when the DNS is missing.
     */
    public function testEmitChangeSkipsWhenDnsMissing(): void
    {
        /* Arrange: create a publisher without a queue DNS. */
        $config = $this->createConfig(null);
        $template = $this->createMock(SqlTemplate::class);
        $template->expects($this->never())->method('execute');

        $publisher = new EnqueuePublisher($config, $template, $this->createTraceContext());

        /* Act: emit a change with missing DNS. */
        $publisher->emitChange($this->createEvent(['id' => '1'], ['id' => '1']));

        /* Assert: verify no persistence occurs. */
    }

    /**
     * Ensures diff payloads are stored and queued for publishing.
     */
    public function testEmitChangeStoresDiffAndClears(): void
    {
        /* Arrange: configure a publisher with a fake SQL template. */
        $config = $this->createConfig('amqp://test');
        $template = new FakeSqlTemplate([['event_id' => 'e1', 'retries' => 0, 'event_type' => 'user.created']]);

        FakeAmqpConnectionFactory::$contextFactory = function () {
            return new FakeAmqpContext();
        };

        $publisher = new EnqueuePublisher($config, $template, $this->createTraceContext());

        /* Act: emit a change event. */
        $publisher->emitChange($this->createEvent(['name' => 'new'], ['name' => 'old']));

        /* Assert: verify persistence and diff storage. */
        $this->assertTrue($template->executeCalled);
        $diffParam = $this->findParamInSets($template->executeParams, 'diff');
        $this->assertSame(json_encode(['name' => 'old']), $diffParam->value);
    }

    /**
     * Ensures insert failures raise an exception.
     */
    public function testEmitChangeThrowsWhenInsertFails(): void
    {
        /* Arrange: configure a template that fails to insert. */
        $config = $this->createConfig('amqp://test');
        $template = new FakeSqlTemplate([], false);

        $publisher = new EnqueuePublisher($config, $template, $this->createTraceContext());

        /* Act: emit a change with a failing insert. */
        $this->expectException(Exception::class);
        $publisher->emitChange($this->createEvent([], ['id' => '1']));

        /* Assert: verify the exception is thrown. */
    }

    /**
     * Ensures retries are updated when sending fails.
     */
    public function testSendEventsUpdatesRetriesOnFailure(): void
    {
        /* Arrange: prepare a pending event and failing context factory. */
        $config = $this->createConfig('amqp://test');
        $template = new FakeSqlTemplate([
            ['event_id' => 'e1', 'retries' => 0, 'event_type' => 'user.created']
        ]);

        FakeAmqpConnectionFactory::$contextFactory = function () {
            throw new Exception('boom');
        };

        $publisher = new EnqueuePublisher($config, $template, $this->createTraceContext());

        /* Act: attempt to send pending events. */
        $publisher->sendEvents();

        /* Assert: verify retry metadata is updated. */
        $retryParam = $this->findParamInSets($template->executeParams, 'retries');
        $this->assertSame(1, $retryParam->value);
    }

    private function createConfig(?string $dns): AppConfig
    {
        $config = $this->createMock(AppConfig::class);
        $config->method('get')->willReturnMap([
            ['event.queue.dns', null, $dns],
            ['app.event.queue.topic', null, 'events'],
            ['app.event.queue.retention.send', '1D', '1D'],
            ['app.event.queue.retention.stuck', '3D', '3D'],
        ]);
        return $config;
    }

    private function createTraceContext(): TraceContext
    {
        return new TraceContext(['X-Trace-Id' => 'trace', 'X-Span-Id' => 'span']);
    }

    private function createEvent(array $payload, array $original): PublicEvent
    {
        return new class ($payload, $original) implements PublicEvent {
            public function __construct(private readonly array $payload, private readonly array $original)
            {
            }

            public function eventType(): string
            {
                return 'user.created';
            }

            public function schemaVersion(): string
            {
                return 'v1';
            }

            public function payload(): array
            {
                return $this->payload;
            }

            public function original(): array
            {
                return $this->original;
            }
        };
    }

    private function findParam(array $params, string $name): SqlParam
    {
        foreach ($params as $param) {
            if ($param instanceof SqlParam && $param->name === $name) {
                return $param;
            }
        }
        throw new RuntimeException('Param not found');
    }

    private function findParamInSets(array $paramSets, string $name): SqlParam
    {
        foreach ($paramSets as $params) {
            foreach ($params as $param) {
                if ($param instanceof SqlParam && $param->name === $name) {
                    return $param;
                }
            }
        }
        throw new RuntimeException('Param not found');
    }
}

final class FakeSqlTemplate extends SqlTemplate
{
    public bool $executeCalled = false;
    public array $lastParams = [];
    public array $executeParams = [];

    public function __construct(private array $values, private bool $executeResult = true)
    {
    }

    public function execute($query, array $params): bool
    {
        $this->executeCalled = true;
        $this->lastParams = $params;
        $this->executeParams[] = $params;
        return $this->executeResult;
    }

    public function query($query, array $params, ?Closure $clousure = null): array
    {
        return $this->values;
    }
}
