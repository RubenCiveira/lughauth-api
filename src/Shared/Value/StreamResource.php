<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Value;

use Override;
use RuntimeException;
use Psr\Http\Message\StreamInterface;

/**
 * A PSR-7 compliant stream wrapper around a native PHP resource.
 *
 * This class implements all required methods from the `StreamInterface` and provides
 * safe handling of readable, writable, and seekable streams. It ensures proper error
 * handling for invalid operations, such as writing to non-writable streams or seeking
 * on non-seekable resources.
 */
class StreamResource implements StreamInterface
{
    /**
     * @var resource|null The underlying PHP stream resource.
     */
    private mixed $resource;

    /**
     * Constructs a new stream wrapper from a valid PHP resource.
     *
     * @param resource $resource A valid PHP stream (e.g., from fopen, tmpfile, etc).
     * @throws \InvalidArgumentException If the input is not a valid resource.
     */
    public function __construct($resource)
    {
        /** @psalm-suppress DocblockTypeContradiction */
        if (!is_resource($resource)) {
            throw new \InvalidArgumentException('El argumento debe ser un recurso');
        }
        $this->resource = $resource;
    }

    /**
     * Reads the entire stream content as a string from the beginning.
     *
     * @return string The complete stream contents.
     */
    #[Override]
    public function __toString(): string
    {
        if (!$this->resource) {
            return '';
        }
        rewind($this->resource);
        $content = stream_get_contents($this->resource);
        return false === $content ? '' : $content;
    }

    /**
     * Closes the underlying stream and releases the resource.
     */
    #[Override]
    public function close(): void
    {
        $resource = $this->resource;
        if (null !== $resource) {
            fclose($resource);
            $this->resource = null;
        }
    }

    /**
     * Detaches the underlying stream resource and disables the stream wrapper.
     *
     * @return resource|null The original resource, or null if already detached.
     */
    #[Override]
    public function detach()
    {
        $resource = $this->resource;
        $this->resource = null;
        return $resource;
    }


    /**
     * Retrieves the size of the stream if known.
     *
     * @return int|null The size in bytes, or null if not determinable.
     */
    #[Override]
    public function getSize(): ?int
    {
        if (!$this->resource) {
            return null;
        }

        $stat = fstat($this->resource);
        return $stat['size'] ?? null;
    }

    /**
     * Returns the current position of the file pointer.
     *
     * @return int The current offset.
     */
    #[Override]
    public function tell(): int
    {
        $resource = $this->resource;
        return  null === $resource ? 0 : (int) ftell($resource);
    }

    /**
     * Indicates whether the end of the stream has been reached.
     *
     * @return bool True if at EOF.
     */
    #[Override]
    public function eof(): bool
    {
        $resource = $this->resource;
        return  null === $resource ? true : feof($resource);
    }

    /**
     * Indicates whether the stream is seekable.
     *
     * @return bool True if the stream supports seeking.
     */
    #[Override]
    public function isSeekable(): bool
    {
        return $this->resource && stream_get_meta_data($this->resource)['seekable'];
    }

    /**
     * Moves the pointer to the specified offset.
     *
     * @param int $offset The stream position to seek to.
     * @param int $whence One of SEEK_SET, SEEK_CUR, or SEEK_END.
     * @throws \RuntimeException If the stream is not seekable.
     */
    #[Override]
    public function seek($offset, $whence = SEEK_SET): void
    {
        if (!$this->isSeekable()) {
            throw new RuntimeException('Stream no es seekable');
        }
        $resource = $this->resource;
        if (null !== $resource) {
            fseek($resource, $offset, $whence);
        }
    }

    /**
     * Rewinds the stream to the beginning.
     */
    #[Override]
    public function rewind(): void
    {
        $this->seek(0);
    }

    /**
     * Indicates whether the stream is writable.
     *
     * @return bool True if writable.
     */
    #[Override]
    public function isWritable(): bool
    {
        $resource = $this->resource;
        if (null === $resource) {
            return false;
        } else {
            $meta = stream_get_meta_data($resource);
            return strpbrk($meta['mode'], 'waxc+') !== false;
        }
    }

    /**
     * Writes data to the stream.
     *
     * @param string $string The data to write.
     * @return int The number of bytes written.
     * @throws RuntimeException If the stream is not writable.
     */
    #[Override]
    public function write($string): int
    {
        if (!$this->isWritable()) {
            throw new RuntimeException('Stream no es writable');
        }
        $resource = $this->resource;
        if (null == $resource) {
            return 0;
        } else {
            $writed = fwrite($resource, $string) ;
            return $writed === false ? 0 : $writed;
        }
    }

    /**
     * Indicates whether the stream is readable.
     *
     * @return bool True if readable.
     */
    #[Override]
    public function isReadable(): bool
    {
        $resource = $this->resource;
        if (null == $resource) {
            return false;
        } else {
            $meta = stream_get_meta_data($resource);
            return strpbrk($meta['mode'], 'r+') !== false;
        }
    }

    /**
     * Reads data from the stream.
     *
     * @param int $length Number of bytes to read.
     * @return string The read data.
     * @throws \RuntimeException If the stream is not readable.
     */
    #[Override]
    public function read($length): string
    {
        if (!$this->isReadable()) {
            throw new \RuntimeException('Stream no es readable');
        }
        $resource = $this->resource;
        if (null == $resource) {
            return '';
        } else {
            $read = fread($resource, $length);
            return $read == false ? '' : $read;
        }
    }

    /**
     * Reads the remaining contents from the stream.
     *
     * @return string The remaining data.
     * @throws \RuntimeException If the stream is not readable.
     */
    #[Override]
    public function getContents(): string
    {
        if (!$this->isReadable()) {
            throw new \RuntimeException('Stream no es readable');
        }
        $resource = $this->resource;
        if (null == $resource) {
            return '';
        } else {
            $read = stream_get_contents($resource);
            return false === $read ? '' : $read;
        }
    }

    /**
     * Retrieves metadata for the stream or a specific key.
     *
     * @param string|null $key The metadata key to retrieve, or null for all metadata.
     * @return mixed The metadata value or array of all metadata.
     */
    #[Override]
    public function getMetadata($key = null): mixed
    {
        $resource = $this->resource;
        if (null == $resource) {
            return null;
        } else {
            $meta = stream_get_meta_data($resource);
            return null == $key ? $meta : $meta[$key] ?? null;
        }
    }
}
