<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Value;

use DateTime;
use InvalidArgumentException;
use Psr\Http\Message\ServerRequestInterface;
use Civi\Lughauth\Shared\Connector\FileStorage\BinaryContent;

/**
 * Represents a file uploaded through an HTTP request, and wraps it as a BinaryContent object.
 *
 * This class provides a factory method to create a binary content object directly
 * from a PSR-7-compliant uploaded file, and takes care of persisting it temporarily
 * on disk, opening it as a stream, and cleaning it up when no longer needed.
 */
class UploadBinaryContent extends BinaryContent
{
    /**
     * Creates an UploadBinaryContent instance from an HTTP uploaded file.
     *
     * This method extracts the uploaded file from the provided PSR-7 server request,
     * validates it, stores it in a temporary file, opens a read stream on it,
     * and returns a BinaryContent wrapper.
     *
     * @param ServerRequestInterface $request The incoming HTTP request containing uploaded files.
     * @param string $name The field name of the uploaded file.
     *
     * @return BinaryContent The binary content instance wrapping the uploaded file.
     *
     * @throws \InvalidArgumentException If the file is missing or the upload resulted in an error.
     */
    public static function fromUpload(ServerRequestInterface $request, string $name): BinaryContent
    {
        $uploads = $request->getUploadedFiles();
        if (!isset($uploads[$name])) {
            throw new InvalidArgumentException($name . ' is not attached');
        }
        /** @var \Psr\Http\Message\UploadedFileInterface */
        $upload = $uploads[$name];
        if ($error = $upload->getError()) {
            switch ($error) {
                case UPLOAD_ERR_NO_FILE:
                    throw new InvalidArgumentException('No file sent.');
                case UPLOAD_ERR_INI_SIZE:
                case UPLOAD_ERR_FORM_SIZE:
                    throw new InvalidArgumentException('Exceeded filesize limit.');
                default:
                    throw new InvalidArgumentException('Unknown errors.');
            }
        }
        $path = tempnam(sys_get_temp_dir(), 'Tux');
        if (false === $path) {
            throw new InvalidArgumentException('No temp path.');
        }
        $upload->moveTo($path);
        $resource = fopen($path, 'rb');
        $filename = $upload->getClientFilename();
        if (null === $filename) {
            throw new InvalidArgumentException('No temp path.');
        }
        $mimeType = $upload->getClientMediaType();
        if (null === $mimeType) {
            throw new InvalidArgumentException('No temp path.');
        }
        // TODO: sanitize name and mime.
        return new UploadBinaryContent(
            name: $filename,
            mime: $mimeType,
            lastChange: new DateTime(),
            stream: $resource,
            path: $path
        );
    }

    /**
     * Constructs a new UploadBinaryContent object.
     *
     * @param string $name The original client-provided file name.
     * @param string $mime The MIME type of the uploaded file.
     * @param \DateTime $lastChange The timestamp when the file was uploaded.
     * @param mixed $stream The file stream resource.
     * @param string|null $publicUrl Optional public URL for direct access.
     */
    private function __construct(
        string $name,
        string $mime,
        \DateTime $lastChange,
        mixed $stream,
        /** @var string The full path to the temporary stored file. */
        private readonly string $path,
        ?string $publicUrl = null
    ) {
        parent::__construct($name, $mime, $lastChange, $stream, $publicUrl);
    }

    /**
     * Automatically deletes the temporary file on destruction.
     */
    public function __destruct()
    {
        unlink($this->path);
    }
}
