<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Value\Validation;

use Civi\Lughauth\Shared\Exception\ConstraintException;

/**
 * Holds a collection of validation constraint failures.
 *
 * This class is used to accumulate multiple `ConstraintFail` objects, which represent
 * specific validation errors. It supports adding single failures or merging lists,
 * and offers utilities to query and transform the collected violations.
 *
 * @api
 */
class ConstraintFailList
{
    /**
     * @var ConstraintFail[] List of constraint failures.
     */
    private array $errors = [];

    /**
     * @param string|null $path Optional path prefix to be applied to all added errors' field names.
     */
    public function __construct(
        private readonly ?string $path = null
    ) {
    }
    /**
     * Checks if the list contains any validation failures.
     *
     * @return bool True if one or more errors exist.
     */
    public function hasErrors(): bool
    {
        return count($this->errors) > 0;
    }
    /**
     * Checks if the list is empty (i.e., has no validation failures).
     *
     * @return bool True if there are no errors.
     */
    public function isEmpty(): bool
    {
        return count($this->errors) === 0;
    }
    /**
     * Converts the list of failures into a `ConstraintException`.
     *
     * @return ConstraintException An exception encapsulating all current failures.
     */
    public function asConstraintException(): ConstraintException
    {
        return new ConstraintException($this->errors);
    }
    /**
     * Adds a single `ConstraintFail` or all failures from another `ConstraintFailList`.
     *
     * If a path prefix is defined, it will be prepended to each field name.
     *
     * @param ConstraintFailList|ConstraintFail $error The error or list of errors to add.
     * @return void
     */
    public function add(ConstraintFailList|ConstraintFail $error)
    {
        if ($error instanceof ConstraintFailList) {
            $this->errors = array_merge($this->errors, array_map(fn ($e) => $this->copy($e), $error->errors));
        } else {
            $this->errors[] = $this->copy($error);
        }
    }
    /**
     * Checks if any of the contained errors is an instance of the given class or subclass.
     *
     * @param string $type Fully-qualified class or interface name.
     * @return bool True if at least one error matches the type.
     */
    public function includeViolation(string $type): bool
    {
        foreach ($this->errors as $error) {
            if (is_a($error, $type)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Checks if any of the contained errors has the specified code.
     *
     * @param int $code The code to match.
     * @return bool True if a matching error is found.
     */
    public function includeViolationCode(int $code): bool
    {
        foreach ($this->errors as $error) {
            if ($error->code == $code) {
                return true;
            }
        }
        return false;
    }
    /**
     * Copies a `ConstraintFail` and applies the path prefix (if defined) to all fields.
     *
     * @param ConstraintFail $fail The error to copy.
     * @return ConstraintFail The new (possibly prefixed) error.
     */
    private function copy(ConstraintFail $fail): ConstraintFail
    {
        return $this->path
          ? new ConstraintFail($fail->code, array_map(fn ($v) => $this->path . $v, $fail->fields), $fail->wrongValues, $fail->expectedValues)
          : $fail;
    }
}
