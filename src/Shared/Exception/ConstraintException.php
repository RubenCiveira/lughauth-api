<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Exception;

use Civi\Lughauth\Shared\Value\Validation\ConstraintFail;

/**
 * Exception representing a set of validation constraint violations.
 * Implements Iterator to allow iteration over individual constraint failures.
 */
class ConstraintException extends \RuntimeException implements \Iterator
{
    /**
     * Creates a ConstraintException with one or more ConstraintFail instances.
     *
     * @param ConstraintFail ...$fails The validation failures to include.
     * @return ConstraintException
     */
    public static function ofFail(ConstraintFail ...$fails): ConstraintException
    {
        return new ConstraintException($fails);
    }

    /**
     * Creates a ConstraintException from a single validation failure.
     *
     * @param string $code            The failure code.
     * @param array $fields           The affected fields.
     * @param array $wrongValues      The incorrect values provided.
     * @param array $expectedValues   The expected values, if any.
     * @return ConstraintException
     */
    public static function ofError(string $code, array $fields, array $wrongValues, array $expectedValues = []): ConstraintException
    {
        return new ConstraintException([new ConstraintFail($code, $fields, $wrongValues, $expectedValues)]);
    }

    /**
     * Constructor.
     * TODO: make private
     *
     * @param ConstraintFail[] $fails The array of validation failures.
     */
    public function __construct(private array $fails)
    {
    }

    /**
     * Checks whether the exception contains any violations of the given type.
     *
     * @param string $type Fully qualified class name of the violation type to check.
     * @return bool True if at least one violation is of the given type.
     */
    public function includeViolation(string $type): bool
    {
        foreach ($this->fails as $error) {
            if (is_a($error, $type)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Checks whether the exception contains any violations with the given code.
     *
     * @param string $code The code to search for.
     * @return bool True if at least one violation has the specified code.
     */
    public function includeViolationCode(string $code): bool
    {
        foreach ($this->fails as $error) {
            if ($error->code === $code) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns the current element in the iteration.
     *
     * @return ConstraintFail
     */
    public function current(): ConstraintFail
    {
        return current($this->fails);
    }
    /**
     * Returns the key of the current element.
     *
     * @return int
     */
    public function key(): int
    {
        return key($this->fails);
    }
    /**
     * Moves forward to the next element.
     */
    public function next(): void
    {
        next($this->fails);
    }
    /**
     * Rewinds the iterator to the first element.
     */
    public function rewind(): void
    {
        reset($this->fails);
    }
    /**
     * Checks if the current position is valid.
     *
     * @return bool
     */
    public function valid(): bool
    {
        return key($this->fails) !== null;
    }
}
