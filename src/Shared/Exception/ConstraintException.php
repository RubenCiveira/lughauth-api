<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Exception;

use Iterator;
use Override;
use InvalidArgumentException;
use Civi\Lughauth\Shared\Value\Validation\ConstraintFail;

/**
 * Exception representing a set of validation constraint violations.
 * Implements Iterator to allow iteration over individual constraint failures.
 * @template-implements Iterator<ConstraintFail|false>
 */
class ConstraintException extends \RuntimeException implements Iterator
{
    /**
     * Creates a ConstraintException with one or more ConstraintFail instances.
     *
     * @param ConstraintFail ...$fails The validation failures to include.
     * @return ConstraintException
     */
    public static function ofFail(ConstraintFail ...$fails): ConstraintException
    {
        return new ConstraintException($fails);
    }

    /**
     * Creates a ConstraintException from a single validation failure.
     *
     * @param string $code            The failure code.
     * @param array $fields           The affected fields.
     * @param array $wrongValues      The incorrect values provided.
     * @param array $expectedValues   The expected values, if any.
     * @return ConstraintException
     */
    public static function ofError(string $code, array $fields, array $wrongValues, array $expectedValues = []): ConstraintException
    {
        return new ConstraintException([new ConstraintFail($code, $fields, $wrongValues, $expectedValues)]);
    }

    /**
     * Constructs the exception with a list of constraint failures.
     * TODO: make private
     */
    public function __construct(
        /** @var ConstraintFail[] The array of validation failures. */
        private array $fails
    ) {
    }

    /**
     * Checks whether the exception contains any violations of the given type.
     *
     * @param string $type Fully qualified class name of the violation type to check.
     * @return bool True if at least one violation is of the given type.
     */
    public function includeViolation(string $type): bool
    {
        if (!class_exists($type)) {
            throw new InvalidArgumentException($type . ' is expected to exists');
        }
        foreach ($this->fails as $error) {
            if (is_a($error, $type)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Checks whether the exception contains any violations with the given code.
     *
     * @param string $code The code to search for.
     * @return bool True if at least one violation has the specified code.
     */
    public function includeViolationCode(string $code): bool
    {
        foreach ($this->fails as $error) {
            if ($error->code === $code) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns the current element in the iteration.
     *
     * @return ConstraintFail|false
     */
    #[Override]
    public function current(): ConstraintFail|false
    {
        return current($this->fails);
    }
    /**
     * Returns the key of the current element.
     *
     * @return int|int
     */
    #[Override]
    public function key(): int|null
    {
        return key($this->fails);
    }
    /**
     * Moves forward to the next element.
     */
    #[Override]
    public function next(): void
    {
        next($this->fails);
    }
    /**
     * Rewinds the iterator to the first element.
     */
    #[Override]
    public function rewind(): void
    {
        reset($this->fails);
    }
    /**
     * Checks if the current position is valid.
     *
     * @return bool
     */
    #[Override]
    public function valid(): bool
    {
        return key($this->fails) !== null;
    }
}
