<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Security;

/**
 * AesCypherService provides encryption and decryption utilities using AES-256-GCM algorithm.
 * It supports both application-wide and custom password-based operations, using PBKDF2 key derivation.
 *
 * To verify the use of these class:
 * ```php
 *   if (!in_array('aes-256-gcm', openssl_get_cipher_methods(true), true)) {
 *     throw new \RuntimeException('ERROR: AES-256-GCM not supported by your OpenSSL build.');
 *   }
 * ```
 *
 */
class AesCypherService
{
    /**
     * The cipher algorithm used for encryption and decryption.
     */
    private const ENCRYPT_ALGO = 'aes-256-gcm';
    /**
     * The length (in bytes) of the IV (Initialization Vector) for the cipher.
     */
    private const IV_LENGTH_BYTE = 12;
    /**
     * The length (in bytes) of the salt used for key derivation.
     */
    private const SALT_LENGTH_BYTE = 16;
    /**
     * The length (in bits) of the authentication tag used by GCM.
     */
    private const TAG_LENGTH_BIT = 128;
    /**
     * The number of iterations used in PBKDF2 to derive the AES key from a password.
     */
    private const ITERATIONS = 100000; // PBKDF2 iterations
    /**
     * The default cipher key used for application-wide encryption if no key is provided.
     */
    private readonly string $cipherKey;

    /**
     * Creates a new AES cipher service.
     *
     * @param string|null $clave Optional cipher key override. If null, a default key is used.
     */
    public function __construct(?string $clave = null)
    {
        $this->cipherKey = $clave ?? 'clave-cifrado';
    }

    /**
     * Encrypts a plaintext string using the default application-wide cipher key.
     *
     * @param string $value The plaintext value to encrypt.
     * @return string The encrypted and base64-encoded result.
     */
    public function encryptForAll(string $value): string
    {
        return $this->encrypt($value, $this->cipherKey);
    }

    /**
     * Encrypts a plaintext string using a custom password.
     * Internally generates a salt and IV, derives the AES key using PBKDF2,
     * and encrypts the data using AES-256-GCM.
     *
     * @param string $plainText The plaintext to encrypt.
     * @param string $password The password used to derive the encryption key.
     * @return string Base64-encoded encrypted string, including IV, salt, ciphertext and tag.
     */
    public function encrypt(string $plainText, string $password): string
    {
        // Generar una salt y un IV aleatorios
        $salt = random_bytes(self::SALT_LENGTH_BYTE);
        $iv = random_bytes(self::IV_LENGTH_BYTE);

        // Derivar la clave usando PBKDF2 con la contraseña y la sal
        $aesKey = $this->getAESKeyFromPassword($password, $salt);

        // Cifrar el texto plano con AES-256-GCM
        $tag = '';  // Tag se genera automáticamente
        $cipherText = openssl_encrypt(
            $plainText,
            self::ENCRYPT_ALGO,
            $aesKey,
            OPENSSL_RAW_DATA,
            $iv,
            $tag,
            '',   // AAD (Additional Authenticated Data), vacío en este caso
            self::TAG_LENGTH_BIT / 8  // Longitud del tag en bytes (16 bytes para 128 bits)
        );
        $encryptedData = $iv . $salt . $cipherText . $tag;
        return base64_encode($encryptedData);
    }

    /**
     * Decrypts a previously encrypted string using the default application-wide cipher key.
     *
     * @param string $cipherText The encrypted base64-encoded string.
     * @return string|null The decrypted plaintext or null on failure.
     */
    public function decryptForAll(string $cipherText): ?string
    {
        return $this->decrypt($cipherText, $this->cipherKey);
    }

    /**
     * Decrypts an encrypted base64-encoded string using a custom password.
     * Extracts IV, salt, ciphertext, and tag; derives the AES key; and decrypts the content.
     *
     * @param string $cipherText The encrypted base64-encoded string.
     * @param string $password The password used to derive the decryption key.
     * @return string|null The decrypted plaintext or null on failure.
     */
    public function decrypt(string $cipherText, string $password): ?string
    {
        $decode = base64_decode($cipherText);

        // Extraer IV, salt, y ciphertext
        $iv = substr($decode, 0, self::IV_LENGTH_BYTE);
        $salt = substr($decode, self::IV_LENGTH_BYTE, self::SALT_LENGTH_BYTE);
        $cipherBytesWithTag = substr($decode, self::IV_LENGTH_BYTE + self::SALT_LENGTH_BYTE);

        // Extraer Tag
        $cipherTextLength = strlen($cipherBytesWithTag) - (self::TAG_LENGTH_BIT / 8);
        $cipherBytes = substr($cipherBytesWithTag, 0, $cipherTextLength);
        $tag = substr($cipherBytesWithTag, $cipherTextLength);

        // Obtener la clave AES a partir de la contraseña y la sal
        $aesKeyFromPassword = $this->getAESKeyFromPassword($password, $salt);

        // Desencriptar los datos
        $plainText = openssl_decrypt(
            $cipherBytes,
            self::ENCRYPT_ALGO,
            $aesKeyFromPassword,
            OPENSSL_RAW_DATA,
            $iv,
            $tag
        );

        return $plainText !== false ? $plainText : null;
    }

    /**
     * Derives an AES encryption key from a given password and salt using PBKDF2.
     *
     * @param string $password The password from which to derive the key.
     * @param string $salt A cryptographic salt.
     * @return string The derived key as a raw binary string.
     */
    private static function getAESKeyFromPassword(string $password, string $salt): string
    {
        // Derivar la clave usando PBKDF2 y SHA-256 con 100000 iteraciones
        return hash_pbkdf2('sha256', $password, $salt, self::ITERATIONS, 32, true);
    }
}
