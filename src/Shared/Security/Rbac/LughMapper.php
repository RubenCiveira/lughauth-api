<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Security\Rbac;

use Psr\Http\Client\ClientInterface;
use Psr\Http\Message\RequestFactoryInterface;
use Psr\SimpleCache\CacheInterface;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Context;
use Civi\Lughauth\Shared\Security\Identity;
use Psr\Http\Message\StreamFactoryInterface;
use Psr\Log\LoggerInterface;

/**
 * Maps RBAC actions and fields to a remote Lugh authorization service.
 */
class LughMapper
{
    /**
     * @var string Base URL for Lugh authorization service.
     */
    private string $authUrl;
    /**
     * @var string|null API key used to authenticate with service.
     */
    private ?string $apiKey;
    /**
     * @var array<string, array<string, mixed>> Cached resource registrations.
     */
    private array $registereds;

    /**
     * Creates a new mapper tied to the Lugh authorization service.
     */
    public function __construct(
        /** @var AppConfig Application configuration source. */
        private readonly AppConfig $config,
        /** @var Context Runtime context for identity resolution. */
        private readonly Context $context,
        /** @var CacheInterface Cache for storing grant responses. */
        private readonly CacheInterface $cache,
        /** @var LoggerInterface Logger for error reporting. */
        private readonly LoggerInterface $logger,
        /** @var RequestFactoryInterface Factory for building HTTP requests. */
        private readonly RequestFactoryInterface $requestFactory,
        /** @var StreamFactoryInterface Factory for request body streams. */
        private readonly StreamFactoryInterface $streamFactory,
        /** @var ClientInterface HTTP client for Lugh calls. */
        private readonly ClientInterface $client
    ) {
        $this->registereds = [];
        $this->apiKey = $config->get('security.rbac.lugh.api.key');
        $this->authUrl = (string) $config->get('security.rbac.lugh.location');
    }

    /**
     * Flushes registered resources and attributes to the Lugh service.
     */
    public function flush(): void
    {
        $toScopes = [];
        $toAttributes = [];

        foreach ($this->registereds as $reg) {
            $res = $reg['resource']['name'];
            $toScopes[] = [
                'resource' => ['name' => $res, 'description' => $res],
                'scopes' => $reg['scopes']
            ];
            $toAttributes[] = [
                'resource' => ['name' => $res, 'description' => $res],
                'schemas' => $reg['schemas']
            ];
        }
        $this->registerScopes($toScopes);
        $this->registerSchemas($toAttributes);

    }


    /**
     * Registers an action for a resource scope.
     *
     * @param string $resource Resource name.
     * @param string $action Action name.
     * @param string $kind Action kind.
     */
    public function registerResourceAction(string $resource, string $action, string $kind): void
    {
        if (!isset($this->registereds[$resource])) {
            $this->registereds[$resource] = ['resource' => ['name' => $resource, 'description' => $resource],
                    'schemas' => [], 'scopes' => []];
        }
        $this->registereds[$resource]['scopes'][] = ['name' => $action, 'description' => $action, 'kind' => $kind];
    }

    /**
     * Registers an attribute schema for a resource.
     *
     * @param string $resource Resource name.
     * @param string $attribute Attribute name.
     * @param string $kind Attribute kind.
     */
    public function registerResourceAttribute(string $resource, string $attribute, string $kind): void
    {
        if (!isset($this->registereds[$resource])) {
            $this->registereds[$resource] = ['resource' => ['name' => $resource, 'description' => $resource],
                    'schemas' => [], 'scopes' => []];
        }
        $this->registereds[$resource]['schemas'][] = ['name' => $attribute, 'description' => $attribute, 'kind' => $kind];
    }

    /**
     * Resolves fields that should be hidden for the user on a resource.
     *
     * @param Identity $user Current identity.
     * @param string $resource Resource name.
     * @return array<int, string> Field names that should be hidden.
     */
    public function hiddenFields(Identity $user, string $resource): array
    {
        return $this->fields($this->load($user), $user, $resource, 'view');
    }

    /**
     * Resolves fields that should be read-only for the user on a resource.
     *
     * @param Identity $user Current identity.
     * @param string $resource Resource name.
     * @return array<int, string> Field names that should be read-only.
     */
    public function uneditableFields(Identity $user, string $resource): array
    {
        return $this->fields($this->load($user), $user, $resource, 'modify');
    }

    /**
     * Determines if an identity is allowed to perform an action.
     *
     * @param Identity $user Current identity.
     * @param string $resource Resource name.
     * @param string $action Action name.
     * @return bool True when the action is allowed.
     */
    public function allow(Identity $user, string $resource, string $action): bool
    {
        return $this->isAllowed($this->load($user), $user, $resource, 'scope', $action);
    }

    private function load(Identity $user): mixed
    {
        return json_decode($this->getGrants($user), true);
    }

    private function fields(array $grants, Identity $user, string $resource, string $on): array
    {
        $roles = [...$user->roles ?? [], '@everyone', $user->anonimous ? '@anonymous' : '@authenticated' ];
        $all = [];
        $visibles = [];
        foreach ($roles as $role) {
            if (isset($grants[$role][$resource]) && $grants[$role][$resource]['attributes']) {
                foreach ($grants[$role][$resource]['attributes'] as $field => $info) {
                    $all[] = $field;
                    if ($info[$on]) {
                        $visibles[] = $field;
                    }
                }
            }
        }
        return array_diff($all, $visibles);
    }

    private function isAllowed(array $grants, Identity $user, string $resource, string $on, string $with): bool
    {
        $roles = [...$user->roles ?? [], '@everyone', $user->anonimous ? '@anonymous' : '@authenticated' ];
        foreach ($roles as $role) {
            if (isset($grants[$role][$resource]) && $grants[$role][$resource][$on][$with]) {
                return true;
            }
        }
        return false;
    }

    private function getGrants(Identity $user): string
    {
        $cache_key = 'lught.grants' . (null !== $user->tenant ? '.' . $user->tenant : '');
        if ($this->cache->has($cache_key)) {
            return $this->cache->get($cache_key);
        } else {
            $url = $this->authUrl . '/grant';
            if (null !== $user->tenant) {
                $url .= '?tenant=' . urlencode($user->tenant);
            }
            $request = $this->requestFactory->createRequest('GET', $url);
            if (null != $this->apiKey) {
                $request = $request->withAddedHeader('x-api-key', $this->apiKey);
            }
            $response = $this->client->sendRequest($request);
            $item = $response->getBody()->__toString();
            $this->cache->set($cache_key, $item, new \DateInterval('PT1H'));
            return $item;
        }
    }

    /**
     * Registers resource scopes with the Lugh authorization service.
     *
     * Sends a POST request to the Lugh service with the provided scope definitions.
     * Each scope contains resource information and associated actions that users can perform.
     *
     * @param array<array<string, mixed>> $toScopes Array of scope definitions to register.
     *                                        Each element contains 'resource' and 'scopes' keys.
     * @return void
     */
    private function registerScopes(array $toScopes): void
    {
        $encoded = json_encode($toScopes);
        if (is_string($encoded)) {
            $registerScopesRequest = $this->requestFactory->createRequest('POST', $this->authUrl . '/resource/scope')
            ->withBody($this->streamFactory->createStream($encoded));
            if (null !== $this->apiKey) {
                $registerScopesRequest = $registerScopesRequest
                ->withAddedHeader('x-api-key', $this->apiKey);
            }
            $registerScopesResponse = $this->client->sendRequest($registerScopesRequest);
            if ($registerScopesResponse->getStatusCode() !== 204) {
                $this->logger->error('Error making scope register on '. $this->authUrl . ':' .
                $registerScopesResponse->getBody()->__toString());
            }
        }
    }

    /**
     * Registers resource attribute schemas with Lugh authorization service.
     *
     * Sends a POST request to Lugh service with provided schema definitions.
     * Each schema defines resource attributes that can be controlled by RBAC policies.
     *
     * @param array<array<string, mixed>> $toAttributes Array of schema definitions to register.
     *                                           Each element contains 'resource' and 'schemas' keys.
     * @return void
     */
    private function registerSchemas(array $toAttributes): void
    {
        $encoded = json_encode($toAttributes);
        if (is_string($encoded)) {
            $request = $this->requestFactory->createRequest('POST', $this->authUrl . '/resource/schema')
            ->withBody($this->streamFactory->createStream($encoded));
            if (null !== $this->apiKey) {
                $request = $request->withAddedHeader('x-api-key', $this->apiKey);
            }
            $response = $this->client->sendRequest($request);
            if ($response->getStatusCode() !== 204) {
                $this->logger->error('Error making schema register on '. $this->authUrl . ':' . $response->getBody()->__toString());
            }
        }
    }

}
