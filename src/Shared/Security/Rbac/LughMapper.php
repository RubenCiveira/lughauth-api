<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Security\Rbac;

use Psr\Http\Client\ClientInterface;
use Psr\Http\Message\RequestFactoryInterface;
use Psr\SimpleCache\CacheInterface;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Context;
use Civi\Lughauth\Shared\Security\Identity;
use Psr\Http\Message\StreamFactoryInterface;
use Psr\Log\LoggerInterface;

/**
 * Maps RBAC actions and fields to a remote Lugh authorization service.
 */
class LughMapper
{
    /**
     * @var string|null Base URL for the Lugh authorization service.
     */
    private readonly ?string $authUrl;
    /**
     * @var string|null API key used to authenticate with the service.
     */
    private readonly ?string $apiKey;
    /**
     * @var array<string, array<string, mixed>> Cached resource registrations.
     */
    private array $registereds;

    /**
     * Creates a new mapper tied to the Lugh authorization service.
     */
    public function __construct(
        /** @var AppConfig Application configuration source. */
        private readonly AppConfig $config,
        /** @var Context Runtime context for identity resolution. */
        private readonly Context $context,
        /** @var CacheInterface Cache for storing grant responses. */
        private readonly CacheInterface $cache,
        /** @var LoggerInterface Logger for error reporting. */
        private readonly LoggerInterface $logger,
        /** @var RequestFactoryInterface Factory for building HTTP requests. */
        private readonly RequestFactoryInterface $requestFactory,
        /** @var StreamFactoryInterface Factory for request body streams. */
        private readonly StreamFactoryInterface $streamFactory,
        /** @var ClientInterface HTTP client for Lugh calls. */
        private readonly ClientInterface $client
    ) {
        $this->authUrl = $config->get('security.rbac.lugh.location', '-');
        $this->apiKey = $config->get('security.rbac.lugh.api.key');
    }

    /**
     * Flushes registered resources and attributes to the Lugh service.
     */
    public function flush()
    {
        $toScopes = [];
        $toAttributes = [];

        foreach ($this->registereds as $reg) {
            $res = $reg['resource']['name'];
            $toScopes[] = [
                'resource' => ['name' => $res, 'description' => $res],
                'scopes' => $reg['scopes']
            ];
            $toAttributes[] = [
                'resource' => ['name' => $res, 'description' => $res],
                'schemas' => $reg['schemas']
            ];
        }
        $request = $this->requestFactory->createRequest('POST', $this->authUrl . '/resource/scope')
                ->withAddedHeader('x-api-key', $this->apiKey)
                ->withBody($this->streamFactory->createStream(json_encode($toScopes)));
        $response = $this->client->sendRequest($request);
        if ($response->getStatusCode() !== 204) {
            $this->logger->error('Error making the scope register on '. $this->authUrl . ':' . $response->getBody());
        }

        $request = $this->requestFactory->createRequest('POST', $this->authUrl . '/resource/schema')
                ->withAddedHeader('x-api-key', $this->apiKey)
                ->withBody($this->streamFactory->createStream(json_encode($toAttributes)));
        $response = $this->client->sendRequest($request);
        if ($response->getStatusCode() !== 204) {
            $this->logger->error('Error making the scope register on '. $this->authUrl . ':' . $response->getBody());
        }
    }


    /**
     * Registers an action for a resource scope.
     *
     * @param string $resource Resource name.
     * @param string $action Action name.
     * @param string $kind Action kind.
     */
    public function registerResourceAction(string $resource, string $action, string $kind)
    {
        if (!isset($this->registereds[$resource])) {
            $this->registereds[$resource] = ['resource' => ['name' => $resource, 'description' => $resource],
                    'schemas' => [], 'scopes' => []];
        }
        $this->registereds[$resource]['scopes'][] = ['name' => $action, 'description' => $action, 'kind' => $kind];
    }

    /**
     * Registers an attribute schema for a resource.
     *
     * @param string $resource Resource name.
     * @param string $attribute Attribute name.
     * @param string $kind Attribute kind.
     */
    public function registerResourceAttribute(string $resource, string $attribute, string $kind)
    {
        if (!isset($this->registereds[$resource])) {
            $this->registereds[$resource] = ['resource' => ['name' => $resource, 'description' => $resource],
                    'schemas' => [], 'scopes' => []];
        }
        $this->registereds[$resource]['schemas'][] = ['name' => $attribute, 'description' => $attribute, 'kind' => $kind];
    }

    /**
     * Resolves fields that should be hidden for the user on a resource.
     *
     * @param Identity $user Current identity.
     * @param string $resource Resource name.
     * @return array<int, string> Field names that should be hidden.
     */
    public function hiddenFields(Identity $user, string $resource): array
    {
        return $this->fields($this->load($user), $user, $resource, 'view');
    }

    /**
     * Resolves fields that should be read-only for the user on a resource.
     *
     * @param Identity $user Current identity.
     * @param string $resource Resource name.
     * @return array<int, string> Field names that should be read-only.
     */
    public function uneditableFields(Identity $user, string $resource): array
    {
        return $this->fields($this->load($user), $user, $resource, 'modify');
    }

    /**
     * Determines if an identity is allowed to perform an action.
     *
     * @param Identity $user Current identity.
     * @param string $resource Resource name.
     * @param string $action Action name.
     * @return bool True when the action is allowed.
     */
    public function allow(Identity $user, string $resource, string $action): bool
    {
        return $this->isAllowed($this->load($user), $user, $resource, 'scope', $action);
    }

    private function load(Identity $user)
    {
        return json_decode($this->getGrants($user), true);
    }

    private function fields(array $grants, Identity $user, string $resource, string $on): array
    {
        $roles = [...$user->roles ?? [], '@everyone', $user->anonimous() ? '@anonymous' : '@authenticated' ];
        $all = [];
        $visibles = [];
        foreach ($roles as $role) {
            if (isset($grants[$role][$resource]) && $grants[$role][$resource]['attributes']) {
                foreach ($grants[$role][$resource]['attributes'] as $field => $info) {
                    $all[] = $field;
                    if ($info[$on]) {
                        $visibles[] = $field;
                    }
                }
            }
        }
        return array_diff($all, $visibles);
    }

    private function isAllowed(array $grants, Identity $user, string $resource, string $on, string $with): bool
    {
        $roles = [...$user->roles ?? [], '@everyone', $user->anonimous() ? '@anonymous' : '@authenticated' ];
        foreach ($roles as $role) {
            if (isset($grants[$role][$resource]) && $grants[$role][$resource][$on][$with]) {
                return true;
            }
        }
        return false;
    }

    private function getGrants(Identity $user)
    {
        $cache_key = 'lught.grants' . ($user->tenant ? '.' . $user->tenant : '');
        if ($this->cache->has($cache_key)) {
            return $this->cache->get($cache_key);
        } else {
            $url = $this->authUrl . '/grant';
            if ($user->tenant) {
                $url .= '?tenant=' . urlencode($user->tenant);
            }
            $request = $this->requestFactory->createRequest('GET', $url);
            $request = $request->withAddedHeader('x-api-key', $this->apiKey);
            $response = $this->client->sendRequest($request);
            $item = '' . $response->getBody();
            $this->cache->set($cache_key, $item, new \DateInterval('PT1H'));
            return $item;
        }
    }
}
