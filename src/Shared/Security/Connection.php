<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Security;

use DateTime;
use Civi\Lughauth\Shared\AppConfig;

/**
 * Represents a connection to the system, including metadata such as IP address,
 * language preference, origin, and application context. It is primarily used to
 * capture and analyze HTTP request origin and attributes.
 */
class Connection
{
    /**
     * Creates a Connection instance based on the current HTTP request environment,
     * resolving headers and optionally respecting proxy headers depending on the configuration.
     *
     * @param string $app The application identifier making the request.
     * @param AppConfig|null $config Optional configuration instance to check for proxy handling.
     * @return Connection The constructed Connection instance.
     */
    public static function remoteHttp(string $app = '', ?AppConfig $config = null): Connection
    {
        $acceptLanguage = $_SERVER['HTTP_ACCEPT_LANGUAGE'] ?? '';
        $languages = explode(',', $acceptLanguage);

        $remoteTarget = isset($_SERVER['SERVER_NAME']) ? $_SERVER['SERVER_NAME'] : gethostname();
        if (false === $remoteTarget) {
            $remoteTarget = '';
        }

        $onProxy = $config ? $config->get("app.http.proxy.allow-forwarded", "false") == "true" : false;
        // Verificar si está disponible la IP del cliente en X-Forwarded-For (usualmente en proxies)
        if ($onProxy && isset($_SERVER['HTTP_X_FORWARDED_FOR'])) {
            // X-Forwarded-For puede contener una lista de IPs, tomamos la primera
            $ipList = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']);
            $clientIp = trim($ipList[0]);
        } elseif ($onProxy && isset($_SERVER['HTTP_X_REAL_IP'])) {
            // X-Real-IP también puede ser usado por algunos proxies
            $clientIp = $_SERVER['HTTP_X_REAL_IP'];
        } else {
            // REMOTE_ADDR es la dirección IP del cliente en una conexión directa
            $clientIp = $_SERVER['REMOTE_ADDR'] ?? '0.0.0.0';
        }
        if ($clientIp === '::1') {
            $clientIp = '127.0.0.1';
        }
        return new Connection(
            remote: true,
            startTime: new \DateTime(),
            application: $app,
            callback: $_SERVER['REQUEST_URI'] ?? '',
            source: $clientIp,
            target: $remoteTarget,
            locale: $languages[0] ?? ''
        );
    }

    /**
     * Constructs a Connection instance.
     */
    public function __construct(
        /** @var bool Indicates whether the connection is remote (vs local). */
        public readonly bool $remote,
        /** @var DateTime The timestamp when the connection was created. */
        public readonly DateTime $startTime,
        /** @var string The name or identifier of the calling application. */
        public readonly string $application,
        /** @var string The original request URI. */
        public readonly string $callback,
        /** @var string The IP address of the client. */
        public readonly string $source,
        /** @var string The hostname or server target. */
        public readonly string $target,
        /** @var string|null The locale inferred from the request headers, if available. */
        public readonly ?string $locale
    ) {
    }

    /**
     * Checks whether the source IP address of the connection falls within the given CIDR block.
     *
     * @param string $cidr The CIDR notation (e.g., "192.168.1.0/24") to compare against.
     * @return bool True if the source IP is within the CIDR range, false otherwise.
     */
    public function inRange(string $cidr): bool
    {
        // Separar la IP base de la máscara de red
        list($subnet, $mask) = explode('/', $cidr);

        // Convertir IP y subnet a formato de número entero de 32 bits
        $ipDecimal = ip2long($this->source);
        if (false === $ipDecimal) {
            $ipDecimal = 0;
        }
        $subnetDecimal = ip2long($subnet);
        if (false === $subnetDecimal) {
            $subnetDecimal = 0;
        }

        // Crear la máscara de red en formato decimal
        $maskDecimal = ~((1 << (32 - (int)$mask)) - 1);

        // Comparar la IP y la subnet con la máscara de red aplicada
        return ($ipDecimal & $maskDecimal) === ($subnetDecimal & $maskDecimal);
    }
}
