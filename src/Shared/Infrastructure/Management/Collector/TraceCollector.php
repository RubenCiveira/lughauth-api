<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Management\Collector;

use Closure;
use Override;
use Psr\Http\Message\ServerRequestInterface;
use OpenTelemetry\SDK\Trace\SpanExporterInterface;
use OpenTelemetry\SDK\Common\Attribute\Attributes;
use OpenTelemetry\API\Trace\TraceFlags;
use Civi\Lughauth\Shared\Infrastructure\Management\ManagementInterface;
use OpenTelemetry\API\Trace\SpanContext;
use OpenTelemetry\SDK\Common\Instrumentation\InstrumentationScope;
use OpenTelemetry\SDK\Resource\ResourceInfo;

/**
 * Collects OTLP traces and forwards them to the span exporter.
 */
class TraceCollector implements ManagementInterface
{
    /**
     * Creates a new trace collector management handler.
     */
    public function __construct(
        /** @var SpanExporterInterface Exporter used to emit collected spans. */
        private readonly SpanExporterInterface $exporter
    ) {
    }

    /**
     * Returns the management endpoint name.
     */
    #[Override]
    public function name(): string
    {
        return 'trace-collector';
    }

    /**
     * No read handler is provided for trace collection.
     */
    #[Override]
    public function get(): ?Closure
    {
        return null;
    }

    /**
     * Returns a handler that ingests and exports OTLP spans.
     *
     * @return Closure|null Closure that parses and exports the trace payload.
     */
    #[Override]
    public function set(): ?Closure
    {
        return function (ServerRequestInterface $request): array {
            $body = (string) $request->getBody();
            $payload = json_decode($body, true);
            if (isset($payload['resourceSpans'])) {

                $spanDataList = [];


                foreach ($payload['resourceSpans'] as $resourceSpan) {
                    $attributes = Attributes::create($this->extractAttributes($resourceSpan['resource']['attributes'] ?? []));
                    $resource = ResourceInfo::create($attributes);
                    foreach ($resourceSpan['scopeSpans'] as $scopeSpan) {
                        $scope = new InstrumentationScope(
                            $scopeSpan['scope']['name'] ?? null,
                            $scopeSpan['scope']['version'] ?? null,
                            null,
                            $attributes
                        );
                        foreach ($scopeSpan['spans'] as $span) {
                            $spanContext = SpanContext::create(
                                $span['traceId'],
                                $span['spanId'],
                                TraceFlags::SAMPLED,
                            );
                            $parentContext = null;
                            if (!empty($span['parentSpanId'])) {
                                $parentContext = SpanContext::create(
                                    $span['traceId'],
                                    $span['parentSpanId'],
                                    TraceFlags::SAMPLED,
                                );
                            } else {
                                $parentContext = SpanContext::getInvalid();
                            }
                            $spanDataList[] = new SpanDataEnvelope(
                                name: $span['name'],
                                context: $spanContext,
                                parentContext: $parentContext,
                                resource: $resource,
                                scope: $scope,
                                startEpochNanos: (int) $span['startTimeUnixNano'],
                                endEpochNanos: (int) $span['endTimeUnixNano'],
                                attributes: Attributes::create($this->extractAttributes($span['attributes'] ?? [])),
                                status: StatusDataEnvelope::fromRaw($span['status']),
                                kind: $span['kind'] ?? 1,
                            );
                        }
                    }
                }
                $this->exporter->export($spanDataList)->await();
            }
            return [];
        };
    }

    private function extractAttributes(array $raw): array
    {
        $attributes = [];
        foreach ($raw as $entry) {
            if (!isset($entry['key'], $entry['value'])) {
                continue;
            }

            $val = reset($entry['value']); // get first value regardless of type
            $attributes[$entry['key']] = $val;
        }
        return $attributes;
    }
}
