<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Management\Log;

use Closure;
use Override;
use Psr\Http\Message\ServerRequestInterface;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Infrastructure\Management\ManagementInterface;

/**
 * Exposes application log entries for management queries.
 */
class LogManagement implements ManagementInterface
{
    /**
     * Creates a new log management handler.
     */
    public function __construct(
        /** @var AppConfig Application configuration. */
        private readonly AppConfig $config,
        /** @var string Path to the log directory. */
        private readonly string $path = __DIR__ . '/../../../../../var/log'
    ) {
    }

    /**
     * Returns the management endpoint name.
     */
    #[Override]
    public function name(): string
    {
        return 'log';
    }

    /**
     * Returns a handler that searches log entries.
     */
    #[Override]
    public function get(): ?Closure
    {
        return function (ServerRequestInterface $request): array {
            $params = $request->getQueryParams();
            $search = $params['search'] ?? null;
            $traceId = $params['trace-id'] ?? null;
            $spanId = $params['span-id'] ?? null;
            $level = $params['level'] ?? null;
            $service_name = $params['service-name'] ?? null;
            $service_namespace = $params['service-namespace'] ?? null;
            $service_version = $params['service-version'] ?? null;
            $service_instance = $params['service-instance'] ?? null;
            $environment = $params['deployment-environment'] ?? null;
            $levelName = $params['level-name'] ?? null;
            $to = isset($params['to']) ? strtotime($params['to']) : null;
            $from = isset($params['from']) ? strtotime($params['from']) : null;

            $offset        = max(0, (int)($params['offset'] ?? 0));
            $limit         = max(1, min(500, (int)($params['limit'] ?? 100)));

            $logFiles = glob($this->path . '/'.$this->config->name.'-*.jsonl*'); // incluye app.log, app.log.1, etc.
            rsort($logFiles); // orden descendente

            $matchedSeen = 0;
            $results = [];

            foreach ($logFiles as $file) {
                $handle = fopen($file, 'r');
                if (!$handle) {
                    continue;
                }
                foreach ($this->iterateLines($file) as $line) {
                    if (!trim($line)) {
                        continue;
                    }
                    $record = $this->parseLogLine($line); // convierte línea en array asociativo
                    if (!$record) {
                        continue;
                    }
                    // Filtrado por fecha
                    $timestamp = strtotime($record['datetime'] ?? '');
                    if ($from && $timestamp < $from) {
                        continue;
                    }
                    if ($to && $timestamp > $to) {
                        continue;
                    }
                    if ($service_name && ($record['extra']['service']['service.name']) !== $service_name) {
                        continue;
                    }
                    if ($service_namespace && ($record['extra']['service']['service.namespace']) !== $service_namespace) {
                        continue;
                    }
                    if ($service_version && ($record['extra']['service']['service.version']) !== $service_version) {
                        continue;
                    }
                    if ($service_instance && ($record['extra']['service']['service.instance.id']) !== $service_instance) {
                        continue;
                    }
                    if ($environment && ($record['extra']['service']['deployment.environment']) !== $environment) {
                        continue;
                    }
                    // Filtrado por trace/span
                    if ($traceId && ($record['extra']['traceId'] ?? null) !== $traceId) {
                        continue;
                    }
                    if ($spanId && ($record['extra']['spanId'] ?? null) !== $spanId) {
                        continue;
                    }
                    if ($level && ($record['level'] < $level)) {
                        continue;
                    }
                    if ($levelName && ($record['level_name'] !== $levelName)) {
                        continue;
                    }
                    // Búsqueda textual
                    if ($search && stripos($record['message'], $search) === false) {
                        continue;
                    }
                    if ($matchedSeen++ < $offset) {
                        continue;
                    }
                    $results[] = $record;
                    if (count($results) >= $limit) {
                        break 2; // salimos de ambos bucles
                    }
                }
                fclose($handle);
            }
            return $results;
        };
    }

    /**
     * No write handler is provided for logs.
     */
    #[Override]
    public function set(): ?Closure
    {
        return null;
    }

    private function parseLogLine(string $line): ?array
    {
        $json = json_decode($line, true);
        return is_array($json) ? $json : null;
    }

    private function iterateLines(string $file): \Generator
    {
        $isGz = str_ends_with($file, '.gz');
        if ($isGz) {
            $h = @gzopen($file, 'rb');
            if ($h === false) {
                return;
            }
            try {
                while (!gzeof($h)) {
                    $line = gzgets($h);
                    if ($line === false) {
                        break;
                    }
                    yield rtrim($line, "\r\n");
                }
            } finally {
                @gzclose($h);
            }
        } else {
            $h = @fopen($file, 'rb');
            if ($h === false) {
                return;
            }
            try {
                while (!feof($h)) {
                    $line = fgets($h);
                    if ($line === false) {
                        break;
                    }
                    yield rtrim($line, "\r\n");
                }
            } finally {
                @fclose($h);
            }
        }
    }
}
