<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\LongTask;

use DateTimeZone;
use DateTimeImmutable;
use Civi\Lughauth\Shared\Context;
use Civi\Lughauth\Shared\Infrastructure\Sql\SqlParam;
use Civi\Lughauth\Shared\Infrastructure\Sql\SqlTemplate;

/**
 * Stores and retrieves long-running task progress in SQL.
 */
class TaskStore
{
    public function __construct(
        /** @var SqlTemplate SQL helper for persistence. */
        private readonly SqlTemplate $template,
        /** @var Context Application context for identity. */
        private readonly Context $context
    ) {
        $this->template->execute("delete from _long_tasks where expiration < :expirated", [
            new SqlParam('expirated', new DateTimeImmutable(), SqlParam::DATETIME)
        ]);
    }

    /**
     * Persists an initial task progress payload.
     */
    public function save(TaskProgress $progress, DateTimeImmutable $expiration): void
    {
        $id = $progress->key->uid;
        $txt = json_encode($progress);
        $identity = $this->context->getIdentity();
        $user = $identity->id ?? '-';

        $this->template->execute("insert into _long_tasks (id, content, user, expiration) values (:id, :content, :user, :expiration)", [
                new SqlParam('id', $id, SqlParam::TEXT),
                new SqlParam('content', $txt, SqlParam::TEXT),
                new SqlParam('user', $user, SqlParam::TEXT),
                new SqlParam('expiration', $expiration, SqlParam::DATETIME),
            ]);
        $this->template->commit();
    }

    /**
     * Updates an existing task progress payload.
     */
    public function update(TaskProgress $progress): void
    {
        $identity = $this->context->getIdentity();
        $user = $identity->id ?? '-';

        $id = $progress->key->uid;
        $txt = json_encode($progress);
        $this->template->execute("update _long_tasks set content=:content where id=:id and user=:user or user='-'", [
            new SqlParam('id', $id, SqlParam::TEXT),
            new SqlParam('user', $user, SqlParam::TEXT),
            new SqlParam('content', $txt, SqlParam::TEXT)
        ]);
        $this->template->commit();
    }

    /**
     * Retrieves the stored task progress for a key.
     */
    public function retrieve(TaskKey $key): ?TaskProgress
    {
        $identity = $this->context->getIdentity();
        $user = $identity->id ?? '-';

        $row = $this->template->query("select content from _long_tasks where id=:id and user=:user or user='-'", [
            new SqlParam('id', $key->uid, SqlParam::TEXT),
            new SqlParam('user', $user, SqlParam::TEXT),
        ]);
        if (count($row) > 0) {
            $json = json_decode($row[0]['content'], true);
            $steps = [];
            if (isset($json['steps'])) {
                foreach ($json['steps'] as $jsonStep) {
                    $step = new TaskStepProgress(
                        status: $jsonStep['status'],
                        processedItems: $jsonStep['processedItems'] ?? null,
                        totalItem: $jsonStep['totalItem'] ?? null,
                        error: $jsonStep['error'] ?? null,
                        startTime: $this->date(isset($jsonStep['startTime']) ?: null),
                        endTime: $this->date(isset($jsonStep['endTime']) ?: null),
                        oks: [],
                        errors: [],
                        warns: []
                    );
                    if (isset($jsonStep['oks']) && is_array($jsonStep['oks'])) {
                        foreach ($jsonStep['oks'] as $ok) {
                            $step->addOk($ok);
                        }
                    }
                    if (isset($jsonStep['warns']) && is_array($jsonStep['warns'])) {
                        foreach ($jsonStep['warns'] as $code => $messages) {
                            foreach ($messages as $message) {
                                $step->addWarn($code, $message);
                            }
                        }
                    }
                    if (isset($jsonStep['errors']) && is_array($jsonStep['errors'])) {
                        foreach ($jsonStep['errors'] as $code => $messages) {
                            foreach ($messages as $message) {
                                $step->addError($code, $message);
                            }
                        }
                    }
                    $steps[] = $step;
                }
            }
            return new TaskProgress(
                key: $key,
                status: $json['status'],
                startTime: $this->date(isset($json['startTime']) ?: null),
                endTime: $this->date(isset($json['endTime']) ?: null),
                steps: $steps
            );
        } else {
            return null;
        }
    }

    private function date(mixed $data): ?DateTimeImmutable
    {
        if (is_array($data)) {
            return new DateTimeImmutable($data['date'], new DateTimeZone($data['timezone']));
        } else {
            return null;
        }
    }
}
