<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\LongTask;

use Throwable;
use Exception;
use DateInterval;
use DateTimeImmutable;
use Psr\Container\ContainerInterface;
use Civi\Lughauth\Shared\Context;
use Civi\Lughauth\Shared\Observability\LoggerAwareTrait;
use Civi\Lughauth\Shared\Observability\TracerAwareTrait;
use Civi\Lughauth\Shared\Value\Random;

/**
 * Orchestrates long-running tasks and tracks their progress.
 */
class Runner
{
    use LoggerAwareTrait;
    use TracerAwareTrait;

    public function __construct(
        /** @var TaskStore Storage backend for task progress. */
        private readonly TaskStore $store,
        /** @var Context Application context used to build containers. */
        private readonly Context $context
    ) {
    }

    /**
     * Starts a long-running task by descriptor type.
     */
    public function run(string $descriptorType, array $params): TaskKey
    {
        // Tengo que crear un contexto.
        $key = new TaskKey(Random::uuid());
        $step = new TaskStepProgress(
            status: 'PENDING',
            totalItem: null,
            processedItems: 0,
            error: null,
            startTime: null,
            endTime: null,
            oks: [],
            errors: [],
            warns: []
        );
        $progress = new TaskProgress(
            key: $key,
            status: 'PENDING',
            startTime: null,
            endTime: null,
            steps: [ $step ],
        );
        $this->store->save($progress, new DateTimeImmutable()->add(DateInterval::createFromDateString('2 days')));
        $callback = function (TaskProgress $progress, TaskStepProgress $step, ContainerInterface $container, string $descriptorType, array $params) {
            set_time_limit(0);
            $this->logInfo("Running offiline for {$descriptorType}");
            $span = $this->startSpan("Running offline for {$descriptorType}");
            try {
                $descriptor = $container->get($descriptorType);
                $context = $descriptor->init(new TaskContext($params, null));
                $reader = $descriptor->reader();
                $writer = $descriptor->writer();
                try {
                    do {
                        $progress->startTime = $step->startTime = new \DateTimeImmutable();
                        $step->status = 'PROCESSING';
                        $progress->status = 'PROCESSING';
                        if ($reader instanceof TaskCounterInterface) {
                            $step->totalItem = $reader->expectedTotal($context);
                        }
                        $this->store->update($progress);
                        $items = $reader->read($context);
                        if ($items) {
                            $processed = [];
                            foreach ($items as $item) {
                                try {
                                    $processed[] = $descriptor->process($context, $item);
                                } catch (Exception $ex) {
                                    $step->addError($descriptor->describe($item), $ex);
                                }
                            }
                            if ($writer) {
                                $writer->write($context, $processed);
                            }
                            foreach ($processed as $pross) {
                                $step->addOk($descriptor->describe($pross));
                            }
                            $this->store->update($progress);
                        }
                    } while ($items);
                    $progress->endTime = $step->endTime = new \DateTimeImmutable();
                    $step->status = 'FINISHED';
                    $progress->status = 'FINISHED';
                    $this->store->update($progress);
                } catch (Exception $ex) {
                    $progress->endTime = $step->endTime = new \DateTimeImmutable();
                    $step->status = 'FAILED';
                    $progress->status = 'FAILED';
                    $step->error = $ex->getMessage();
                    $this->store->update($progress);
                }
                $descriptor->finish($context);
            } catch (Throwable $ex) {
                $span->recordException($ex);
                throw $ex;
            } finally {
                $span->end();
            }
        };
        register_shutdown_function($callback, $progress, $step, $this->context->detachedContainer(), $descriptorType, $params);
        return $key;
    }

    /**
     * Retrieves task progress for a given key.
     */
    public function detail(TaskKey $key): ?TaskProgress
    {
        return $this->store->retrieve($key);
    }
}
