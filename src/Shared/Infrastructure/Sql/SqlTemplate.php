<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Sql;

use PDO;
use PDOStatement;
use Closure;
use PDOException;
use Civi\Lughauth\Shared\Exception\NotEmptyChildsException;
use Civi\Lughauth\Shared\Exception\NotUniqueException;

/**
 * Provides common SQL helpers for PDO-based repositories.
 */
class SqlTemplate
{
    /**
     * Creates a SQL template bound to a PDO connection.
     */
    public function __construct(
        /** @var PDO PDO connection used for queries. */
        private readonly PDO $pdo
    ) {
    }

    /**
     * Starts a database transaction.
     */
    public function begin(): void
    {
        $this->pdo->beginTransaction();
    }

    /**
     * Rolls back the current transaction when active.
     */
    public function rollback(): void
    {
        if ($this->pdo->inTransaction()) {
            $this->pdo->rollBack();
        }
    }

    /**
     * Commits the current transaction when active.
     */
    public function commit(): void
    {
        if ($this->pdo->inTransaction()) {
            $this->pdo->commit();
        }
    }

    /**
     * Closes the template by rolling back any active transaction.
     */
    public function close(): void
    {
        if ($this->pdo->inTransaction()) {
            $this->pdo->rollBack();
        }
    }

    /**
     * Escapes a value based on a SQL parameter type.
     */
    public function escapeValue(mixed $value, int $type): string
    {
        if ($type == SqlParam::INT || $type == SqlParam::BOOL) {
            return "" . ((int)$value);
        } else {
            return $this->pdo->quote("".$value, $this->podType($type));
        }
    }

    /**
     * Executes a statement and returns whether rows were affected.
     */
    public function execute($query, array $params): bool
    {
        try {
            $stmt = $this->prepare($query, $params);
            $result = $stmt->execute();
            return $result ? $stmt->rowCount() > 0 : 0;
        } catch (PDOException $ex) {
            throw $this->exception($ex);
        }
    }

    /**
     * Executes a query and returns all rows as an array.
     */
    public function query($query, array $params, ?Closure $clousure = null): array
    {
        $stmt = $this->prepare($query, $params);
        $stmt->execute();
        $keys = [];
        while ($fila = $stmt->fetch(PDO::FETCH_ASSOC)) {
            $keys[] = $clousure ? $clousure($fila) : $fila;
        }
        return $keys;
    }

    /**
     * Executes a query for update and returns all rows as an array.
     */
    public function queryForUpdate($query, array $params, ?Closure $clousure = null): array
    {
        $stmt = $this->prepare($query, $params);
        $stmt->execute();
        $keys = [];
        while ($fila = $stmt->fetch(PDO::FETCH_ASSOC)) {
            $keys[] = $clousure ? $clousure($fila) : $fila;
        }
        return $keys;
    }

    /**
     * Finds a single row or returns null when no match exists.
     */
    public function findOne($query, array $params, ?Closure $clousure = null)
    {
        $stmt = $this->prepare($query, $params);
        $stmt->execute();
        $fila = $stmt->fetch(PDO::FETCH_ASSOC);
        return $fila ? ($clousure ? $clousure($fila) : $fila) : null;
    }

    /**
     * Finds a single row for update or returns null when no match exists.
     */
    public function findOneForUpdate($query, array $params, ?Closure $clousure = null)
    {
        $stmt = $this->prepare($query, $params);
        $stmt->execute();
        $fila = $stmt->fetch(PDO::FETCH_ASSOC);
        return $fila ? ($clousure ? $clousure($fila) : $fila) : null;
    }

    /**
     * Returns true when the query yields at least one row.
     */
    public function exists($query, array $params): bool
    {
        $stmt = $this->prepare($query, $params);
        $stmt->execute();
        return !!$stmt->fetch();
    }

    /**
     * Returns true when the query yields at least one row for update.
     */
    public function existsForUpdate($query, array $params): bool
    {
        $stmt = $this->prepare($query, $params);
        $stmt->execute();
        return !!$stmt->fetch();
    }

    private function prepare($query, array $params): PDOStatement | false
    {
        $driver = $this->pdo->getAttribute(PDO::ATTR_DRIVER_NAME);
        if ('mysql' == $driver) {
            $query = str_replace('"', "`", $query);
        }
        foreach ($params as $key => $param) {
            $value = is_a($param, SqlParam::class) ? $param->value : $param;
            $name = is_a($param, SqlParam::class) ? $param->name : $key;
            if (is_array($value)) {
                // $pattern = '/\s+(IN|in)\s*\(\s*:' . preg_quote($name, '/') . '\s*\)/i';
                // $query = preg_replace($pattern, $this->paramExpand($name, $value), $query);
                $pattern = '/(?<field>`?\w+`?|"\w+"|\w+)\s+(?<op>NOT\s+IN|IN)\s*\(\s*:' . preg_quote($name, '/') . '\s*\)/i';
                $query = preg_replace_callback($pattern, function ($matches) use ($name, $value) {
                    $field = $matches['field'];
                    $op = strtoupper(trim($matches['op']));
                    return $this->paramExpand($field, $name, $value, $op === 'NOT IN');
                }, $query);
            }
        }
        $stmt = $this->pdo->prepare($query);
        foreach ($params as $key => $param) {
            $value = is_a($param, SqlParam::class) ? $param->value : $param;
            $name = is_a($param, SqlParam::class) ? $param->name : $key;
            if (is_array($value)) {
                for ($i = 0; $i < count($value); $i++) {
                    if (is_a($param, SqlParam::class)) {
                        $stmt->bindValue($name . '_' . ($i + 1), $this->podValue($value[$i], $param->type), $this->podType($param->type));
                    } else {
                        $stmt->bindValue($name . '_' . ($i + 1), $this->podValue($value[$i], null));
                    }
                }
            } else {
                if (is_a($param, SqlParam::class)) {
                    $stmt->bindValue($name, $this->podValue($value, $param->type), $this->podType($param->type));
                } else {
                    $stmt->bindValue($name, $this->podValue($value, null));
                }
            }
        }
        return $stmt;
    }

    private function paramExpand($field, $name, $elements, bool $not = false): string
    {
        if (count($elements) === 0) {
            return $not ? '1 = 1' : '0 = 1'; // NOT IN [] â†’ siempre verdadero
        }
        $params = [];
        for ($i = 1; $i <= count($elements); $i++) {
            $params[] = ':' . $name . '_' . $i;
        }
        $op = $not ? 'NOT IN' : 'IN';
        return "$field $op (" . implode(', ', $params) . ")";
    }

    private function podValue($value, $type): mixed
    {
        if ($value instanceof \DateTime || $value instanceof \DateTimeInterface) {
            return $value->format('Y-m-d H:i:s');
        }
        return $value;
    }
    private function podType(int $type): int
    {
        if ($type == SqlParam::BOOL) {
            return PDO::PARAM_BOOL;
        } elseif ($type == SqlParam::INT) {
            return PDO::PARAM_INT;
        } elseif ($type == SqlParam::TEXT) {
            return PDO::PARAM_LOB;
        } else {
            return PDO::PARAM_STR;
        }
    }

    private function exception(PDOException $ex): \Exception
    {
        $driver = $this->pdo->getAttribute(PDO::ATTR_DRIVER_NAME);
        if ($this->isDuplicated($ex, $driver)) {
            throw new NotUniqueException($ex);
        } elseif ($this->isReferenced($ex, $driver)) {
            throw new NotEmptyChildsException($ex);
        }
        throw $ex;
    }
    private function isDuplicated(PDOException $ex, string $driver): bool
    {
        if ('mysql' === $driver) {
            return $this->isDuplicatedInMysql($ex);
        }
        return false;
    }
    private function isDuplicatedInMysql(PDOException $ex): bool
    {
        return $ex->errorInfo[0] == 23000 && $ex->errorInfo[1] == 1062;
    }
    private function isReferenced(PDOException $ex, string $driver): bool
    {
        if ('mysql' === $driver) {
            return $this->isReferencedInMysql($ex);
        }
        return false;
    }
    private function isReferencedInMysql(PDOException $ex): bool
    {
        return is_array($ex->errorInfo) && count($ex->errorInfo) > 1
                && $ex->errorInfo[0] == 23000 && $ex->errorInfo[1] == 1451;
    }
}
