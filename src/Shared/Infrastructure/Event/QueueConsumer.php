<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Event;

use Enqueue\AmqpLib\AmqpConnectionFactory;
use Interop\Amqp\AmqpTopic;
use Interop\Amqp\AmqpQueue;
use Interop\Amqp\Impl\AmqpBind;

/**
 * Consumes AMQP messages and dispatches decoded payloads to a handler.
 */
final class QueueConsumer
{
    /**
     * Consumes messages matching the routing key mask and processes JSON payloads.
     */
    public function consume(QueueSource $source, callable $handler): ?array
    {
        $ctx = (new AmqpConnectionFactory(['dsn' => $source->dsn]))->createContext();
        $queueName   = $this->defaultQueueName($source->routingKeyMask);
        $declare     = $source->declareQueue;
        $maxMessages = $source->maxMessages;
        $maxSeconds  = $source->maxSeconds;
        $prefetch    = $source->prefetch;

        $t0 = microtime(true);

        // Exchange topic durable (idempotente)
        $ex = $ctx->createTopic($source->exchangeName);
        $ex->setType(AmqpTopic::TYPE_TOPIC);
        $ex->addFlag(AmqpTopic::FLAG_DURABLE);
        $ctx->declareTopic($ex);

        // Cola durable
        $queue = $ctx->createQueue($queueName);
        $queue->addFlag(AmqpQueue::FLAG_DURABLE);

        if ($declare) {
            $ctx->declareQueue($queue);
            $ctx->bind(new AmqpBind($ex, $queue, $source->routingKeyMask));
        }

        // QoS/preetch si el driver lo soporta
        if (method_exists($ctx, 'setQos')) {
            $ctx->setQos(0, max(1, $prefetch), false);
        }

        $consumer  = $ctx->createConsumer($queue);
        $processed = 0;
        $failed    = 0;
        $deadline  = $t0 + (float)$maxSeconds;

        while ($processed < $maxMessages && microtime(true) < $deadline) {
            // No bloqueante si existe; si no, timeout muy corto
            $msg = method_exists($consumer, 'receiveNoWait')
                ? $consumer->receiveNoWait()
                : $consumer->receive(100); // 100 ms

            if (!$msg) {
                // No hay más mensajes inmediatamente disponibles → fin del batch
                break;
            }

            try {
                $json = json_decode($msg->getBody(), true, 512, JSON_THROW_ON_ERROR);
                $handler($json, $msg);      // tu lógica
                $consumer->acknowledge($msg);
                $processed++;
            } catch (\Throwable $e) {
                error_log("[AmqpQueueConsumer] ".$e->getMessage());
                $consumer->reject($msg, true); // requeue para reintentar en el futuro
                $failed++;
            }
        }

        return [
            'processed'   => $processed,
            'failed'      => $failed,
            'duration_ms' => (int) round((microtime(true) - $t0) * (float)1000),
        ];
    }

    /**
     * Builds the default queue name for a routing key mask.
     */
    private function defaultQueueName(string $routingKeyMask): string
    {
        // Sanitiza la máscara para formar un nombre de cola reproducible
        $q = preg_replace('/[^A-Za-z0-9._-]/', '_', $routingKeyMask) ?? 'queue';
        return "app.consumer.{$q}";
    }
}
