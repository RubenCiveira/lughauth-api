<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Event;

use Exception;
use Enqueue\AmqpLib\AmqpConnectionFactory;
use Interop\Amqp\Impl\AmqpBind;
use Interop\Amqp\Impl\AmqpMessage;
use Interop\Amqp\Impl\AmqpQueue;
use Interop\Amqp\Impl\AmqpTopic;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Event\PublicEvent;
use Civi\Lughauth\Shared\Infrastructure\Sql\SqlParam;
use Civi\Lughauth\Shared\Infrastructure\Sql\SqlTemplate;
use Civi\Lughauth\Shared\Observability\LoggerAwareTrait;
use Civi\Lughauth\Shared\Observability\TraceContext;
use DateInterval;
use DateTimeImmutable;
use PDO;

class EnqueuePublisher
{
    use LoggerAwareTrait;

    private readonly ?string $dns;
    private readonly ?string $topic;

    public function __construct(
        AppConfig $conf,
        private readonly SqlTemplate $template,
        private readonly TraceContext $context
    ) {
        $this->dns = $conf->get('event.queue.dns');
        $this->topic = $conf->get('app.event.queue.topic');
    }

    public function emitChange(PublicEvent $event)
    {
        if (!$this->dns || !str_starts_with($this->dns, 'amqp://')) {
            return;
        }

        // Vamos a guardarlo en la bbdd de eventos, y luego emitimos todos los que podamos.
        $payload = $event->payload();
        $original = $event->original();
        if( count($payload) > 0 ) {
            $diff = [];
            foreach ($payload as $key => $newValue) {
                $oldValue = $original[$key] ?? null;
                if ($oldValue !== $newValue) {
                    $diff[$key] = $oldValue;
                }
            }
        } else {
            $diff = [...$original];
        }
        $result = $this->template->execute(<<<SQL
                    insert into _outbox_events 
                        (status, next_retry, retries, event_id, event_type, schema_version, occurred_at, payload, diff, correlation_id, causation_id)
                        VALUES ('pending', :next, 0, :event_id, :et, :sv, :occ, :payload, :diff, :cid, :caid)
                SQL, [
                    new SqlParam('next', new DateTimeImmutable(), SqlParam::DATETIME),
                    new SqlParam('event_id', bin2hex(random_bytes(16)), SqlParam::TEXT),
                    new SqlParam('et', $event->eventType(), SqlParam::TEXT),
                    new SqlParam('sv', $event->schemaVersion(), SqlParam::TEXT),
                    new SqlParam('occ', new DateTimeImmutable(), SqlParam::DATETIME),
                    new SqlParam('payload', json_encode($payload), SqlParam::TEXT),
                    new SqlParam('diff', json_encode($diff), SqlParam::TEXT),
                    new SqlParam('cid', $this->context->getTraceId(), SqlParam::TEXT),
                    new SqlParam('caid', $this->context->getSpanId(), SqlParam::TEXT),
                ]);
        if (!$result) {
            throw new Exception('Unable to store event');
        }

        register_shutdown_function([$this, 'sendEvent']);
    }

    public function sendEvents()
    {
        $values = $this->template->query(<<<SQL
                select * from _outbox_events where status='pending' and next < :now
            SQL, [
                new SqlParam('now', new DateTimeImmutable(), SqlParam::DATETIME)
            ]);
        foreach ($values as $value) {
            try {
                $this->send($value);
                $this->template->execute(<<<SQL
                    update _outbox_events set status='published' where event_id = :event_id
                SQL, [
                    new SqlParam('event_id', $value['event_id'], SqlParam::TEXT)
                ]);
            } catch (Exception $ex) {
                $retries = intval($value['retries']) + 1;
                $minutes = pow($retries, 2);
                $next = new DateTimeImmutable()->add(new DateInterval('PT'.$minutes.'M'));
                $this->template->execute(<<<SQL
                    update _outbox_events set retries = :retries, next_retry = :next where event_id = :event_id
                SQL, [
                    new SqlParam('retries', $retries, SqlParam::INT),
                    new SqlParam('next_retry', $next, SqlParam::DATETIME),
                    new SqlParam('event_id', $value['event_id'], SqlParam::TEXT)
                ]);
            }
        }
    }

    private function send(array $data)
    {
        if ($this->dns && str_starts_with($this->dns, 'amqp://')) {
            $entityType = $data['event_type'];
            $factory = new AmqpConnectionFactory([
                'dsn' => $this->dns, // %2f = "/" vhost por defecto
            ]);
            $context = $factory->createContext();
            $exchange = $context->createTopic($this->topic, false, true, false, false);
            $exchange->setType(AmqpTopic::TYPE_TOPIC);
            $exchange->addFlag(AmqpTopic::FLAG_DURABLE);
            $context->declareTopic($exchange);

            // 2a) Cola por entidad: events.<entityType>
            $entityQueue = $context->createQueue($this->topic. '.' . $entityType);
            $entityQueue->addFlag(AmqpQueue::FLAG_DURABLE);
            $context->declareQueue($entityQueue);
            // patr√≥n: <entityType>.*
            $context->bind(new AmqpBind($exchange, $entityQueue, $entityType . '.*'));

            // 2b) (Opcional) Cola catch-all: events.all -> '#'
            $allQueue = $context->createQueue($this->topic. '.all');
            $allQueue->addFlag(AmqpQueue::FLAG_DURABLE);
            $context->declareQueue($allQueue);
            $context->bind(new AmqpBind($exchange, $allQueue, '#'));

            // $queue = $context->createQueue('events.' . $entityType);
            // $queue->addFlag(AmqpQueue::FLAG_DURABLE);
            // $context->declareQueue($queue);

            // $context->bind(new AmqpBind($exchange, $queue, $routingKey));

            $routingKey =  $entityType . ($data ? '.modify' : '.delete');
            $message = $context->createMessage(json_encode($data));
            $message->setContentType('application/json');
            $message->setRoutingKey($routingKey);
            $message->setDeliveryMode(AmqpMessage::DELIVERY_MODE_PERSISTENT); // <- clave

            // 5) Enviar
            $producer = $context->createProducer();
            $producer->send($exchange, $message);
        }
    }

}
