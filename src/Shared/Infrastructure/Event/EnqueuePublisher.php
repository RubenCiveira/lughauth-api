<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Event;

use Exception;
use DateInterval;
use DateTimeImmutable;
use Enqueue\AmqpLib\AmqpConnectionFactory;
use Interop\Amqp\Impl\AmqpBind;
use Interop\Amqp\Impl\AmqpMessage;
use Interop\Amqp\Impl\AmqpQueue;
use Interop\Amqp\Impl\AmqpTopic;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Event\PublicEvent;
use Civi\Lughauth\Shared\Infrastructure\Sql\SqlParam;
use Civi\Lughauth\Shared\Infrastructure\Sql\SqlTemplate;
use Civi\Lughauth\Shared\Observability\LoggerAwareTrait;
use Civi\Lughauth\Shared\Observability\TraceContext;

/**
 * Persists and publishes public domain events to an AMQP exchange.
 */
class EnqueuePublisher
{
    use LoggerAwareTrait;

    /** @var string Retention period for published events. */
    private readonly string $sendRetention;
    /** @var string Retention period for stuck events. */
    private readonly string $stuckRetention;
    /** @var ?string AMQP DNS string. */
    private readonly ?string $dns;
    /** @var ?string AMQP topic name. */
    private readonly ?string $topic;

    /**
     * Creates a new enqueue publisher with persistence settings.
     */
    public function __construct(
        /** @var AppConfig Application configuration. */
        AppConfig $conf,
        /** @var SqlTemplate SQL helper for persistence. */
        private readonly SqlTemplate $template,
        /** @var TraceContext Trace context for correlation IDs. */
        private readonly TraceContext $context
    ) {
        $this->dns = $conf->get('event.queue.dns');
        $this->topic = $conf->get('app.event.queue.topic');
        $this->sendRetention = $conf->get('app.event.queue.retention.send', '1D');
        $this->stuckRetention = $conf->get('app.event.queue.retention.stuck', '3D');
    }

    /**
     * Stores a public event and triggers publishing.
     */
    public function emitChange(PublicEvent $event): void
    {
        if (null === $this->dns || !str_starts_with($this->dns, 'amqp://')) {
            return;
        }

        // Vamos a guardarlo en la bbdd de eventos, y luego emitimos todos los que podamos.
        $payload = $event->payload();
        $original = $event->original();
        if (count($payload) > 0) {
            $diff = [];
            foreach ($payload as $key => $newValue) {
                $oldValue = $original[$key] ?? null;
                if ($oldValue !== $newValue) {
                    $diff[$key] = $oldValue;
                }
            }
        } else {
            $diff = [...$original];
        }
        $result = $this->template->execute(<<<SQL
                    insert into _output_queue_pending_events 
                        (status, next_retry, retries, created_at, published_at, event_id, event_type, schema_version, occurred_at, payload, diff, correlation_id, causation_id)
                        VALUES ('pending', :next, 0, :at, null, :event_id, :et, :sv, :occ, :payload, :diff, :cid, :caid)
                SQL, [
                    new SqlParam('next', new DateTimeImmutable()->sub(new DateInterval('PT1M')), SqlParam::DATETIME),
                    new SqlParam('event_id', bin2hex(random_bytes(16)), SqlParam::TEXT),
                    new SqlParam('et', $event->eventType(), SqlParam::TEXT),
                    new SqlParam('sv', $event->schemaVersion(), SqlParam::TEXT),
                    new SqlParam('at', new DateTimeImmutable(), SqlParam::DATETIME),
                    new SqlParam('occ', new DateTimeImmutable(), SqlParam::DATETIME),
                    new SqlParam('payload', json_encode($payload), SqlParam::TEXT),
                    new SqlParam('diff', json_encode($diff), SqlParam::TEXT),
                    new SqlParam('cid', $this->context->getTraceId(), SqlParam::TEXT),
                    new SqlParam('caid', $this->context->getSpanId(), SqlParam::TEXT),
                ]);
        if (!$result) {
            throw new Exception('Unable to store event');
        }
        $this->sendEvents();
        // register_shutdown_function([$this, 'sendEvents']);
    }

    /**
     * Sends pending events and updates retry metadata.
     */
    public function sendEvents(): void
    {
        $values = $this->template->query(<<<SQL
                select * from _output_queue_pending_events where status='pending' and next_retry < :now
            SQL, [
                new SqlParam('now', new DateTimeImmutable(), SqlParam::DATETIME)
            ]);
        foreach ($values as $value) {
            try {
                $this->send($value);
                $this->template->execute(<<<SQL
                    update _output_queue_pending_events set status='published', published_at = :published where event_id = :event_id
                SQL, [
                    new SqlParam('event_id', $value['event_id'], SqlParam::TEXT),
                    new SqlParam('published', new DateTimeImmutable(), SqlParam::DATETIME),
                ]);
            } catch (Exception $ex) {
                $retries = intval($value['retries']) + 1;
                $minutes = pow($retries, 2);
                $next = new DateTimeImmutable()->add(new DateInterval('PT'.$minutes.'M'));
                $this->template->execute(<<<SQL
                    update _output_queue_pending_events set retries = :retries, next_retry = :next_retry where event_id = :event_id
                SQL, [
                    new SqlParam('retries', $retries, SqlParam::INT),
                    new SqlParam('next_retry', $next, SqlParam::DATETIME),
                    new SqlParam('event_id', $value['event_id'], SqlParam::TEXT)
                ]);
            }
        }
        $this->clearEvents();
    }

    private function send(array $data): void
    {
        if ( !$this->isQueueConnectionConfigured() ) {
            return;
        }
        $json = json_encode($data);
        if( false === $json ) {
            return;
        }
        $entityType = $data['event_type'];
        $factory = new AmqpConnectionFactory([
            'dsn' => $this->dns, // %2f = "/" vhost por defecto
        ]);
        $context = $factory->createContext();
        /** @psalm-suppress PossiblyNullArgument */
        $exchange = $context->createTopic($this->topic);
        $exchange->setType(AmqpTopic::TYPE_TOPIC);
        $exchange->addFlag(AmqpTopic::FLAG_DURABLE);
        $context->declareTopic($exchange);

        // // 2a) Cola por entidad: events.<entityType>
        $join = '';
        $parts = explode('.', $entityType);
        foreach ($parts as $part) {
            $join .= $part;
            // 2a) Cola por entidad: events.<entityType>
            $joinQueue = $context->createQueue($this->topic. '.' . $join);
            $joinQueue->addFlag(AmqpQueue::FLAG_DURABLE);
            $context->declareQueue($joinQueue);
            // patr√≥n: <entityType>.*
            if ($join === $entityType) {
                $context->bind(new AmqpBind($exchange, $joinQueue, $join));
            } else {
                $context->bind(new AmqpBind($exchange, $joinQueue, $join . '.*'));
            }
            $join .= '.';
        }

        // 2b) (Opcional) Cola catch-all: events.all -> '#'
        $allQueue = $context->createQueue($this->topic. '.all');
        $allQueue->addFlag(AmqpQueue::FLAG_DURABLE);
        $context->declareQueue($allQueue);
        $context->bind(new AmqpBind($exchange, $allQueue, '#'));

        $message = $context->createMessage( $json );
        $message->setContentType('application/json');
        $message->setRoutingKey($entityType);
        $message->setDeliveryMode(AmqpMessage::DELIVERY_MODE_PERSISTENT); // <- clave

        // 5) Enviar
        $producer = $context->createProducer();
        $producer->send($exchange, $message);
    }

    private function clearEvents(): void
    {
        $send = new DateTimeImmutable()->sub(new DateInterval('P'.$this->sendRetention));
        $stuck = new DateTimeImmutable()->sub(new DateInterval('P'.$this->stuckRetention));
        $this->template->execute(<<<SQL
            DELETE FROM _output_queue_pending_events where (status='published' and occurred_at < :send) or (status!='published' and occurred_at < :stuck )
            SQL, [
                new SqlParam('send', $send, SqlParam::DATETIME),
                new SqlParam('stuck', $stuck, SqlParam::DATETIME),
            ]);
    }

    private function isQueueConnectionConfigured(): bool
    {
        return null !== $this->dns && null !== $this->topic && str_starts_with($this->dns, 'amqp://');
    }
}
