<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\EntityChangelog;

use Exception;
use Enqueue\AmqpLib\AmqpConnectionFactory;
use Interop\Amqp\Impl\AmqpBind;
use Interop\Amqp\Impl\AmqpMessage;
use Interop\Amqp\Impl\AmqpQueue;
use Interop\Amqp\Impl\AmqpTopic;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Observability\LoggerAwareTrait;

class EnqueuePublisher
{
    use LoggerAwareTrait;

    private readonly ?string $dns;
    private readonly ?string $topic;

    public function __construct(AppConfig $conf)
    {
        $this->dns = $conf->get('event.queue.dns');
        $this->topic = $conf->get('app.event.queue.topic');
    }

    public function emitChange(string $entityType, string $entityId, array $payload, array $original): void
    {
        try {
            $this->logError("Try to to emit on " . $this->dns);
            $this->send($entityType, $entityId, $payload, $original);
        } catch (Exception $ex) {
            $this->logError("Unable to emit change " . $ex->getMessage());
        }
    }

    public function emitDelete(string $entityType, string $entityId, array $original): void
    {
        try {
            $this->logError("Try to to emit on " . $this->dns);
            $this->send($entityType, $entityId, null, $original);
        } catch (Exception $ex) {
            $this->logError("Unable to emit change " . $ex->getMessage());
        }
    }

    private function send(string $entityType, string $entityId, ?array $data, ?array $original)
    {
        if ($this->dns && str_starts_with($this->dns, 'amqp://')) {
            $factory = new AmqpConnectionFactory([
                'dsn' => $this->dns, // %2f = "/" vhost por defecto
            ]);
            $context = $factory->createContext();
            $exchange = $context->createTopic($this->topic, false, true, false, false);
            $exchange->setType(AmqpTopic::TYPE_TOPIC);
            $exchange->addFlag(AmqpTopic::FLAG_DURABLE);
            $context->declareTopic($exchange);

            // 2a) Cola por entidad: events.<entityType>
            $entityQueue = $context->createQueue($this->topic. '.' . $entityType);
            $entityQueue->addFlag(AmqpQueue::FLAG_DURABLE);
            $context->declareQueue($entityQueue);
            // patr√≥n: <entityType>.*
            $context->bind(new AmqpBind($exchange, $entityQueue, $entityType . '.*' ));

            // 2b) (Opcional) Cola catch-all: events.all -> '#'
            $allQueue = $context->createQueue($this->topic. '.all');
            $allQueue->addFlag(AmqpQueue::FLAG_DURABLE);
            $context->declareQueue($allQueue);
            $context->bind(new AmqpBind($exchange, $allQueue, '#'));

            // $queue = $context->createQueue('events.' . $entityType);
            // $queue->addFlag(AmqpQueue::FLAG_DURABLE);
            // $context->declareQueue($queue);

            // $context->bind(new AmqpBind($exchange, $queue, $routingKey));
            
            $routingKey =  $entityType . ($data ? '.modify' : '.delete');
            $payload = [
                'schema' => 'v1',
                'event'  => $routingKey,
                'id'     => bin2hex(random_bytes(16)),
                'entity' => $entityId,
                'ts'     => time(),
            ];
            if ($data) {
                $payload['payload'] = $data;
            }
            if ($original) {
                $payload['original'] = $original;
            }
            $message = $context->createMessage(json_encode($payload));
            $message->setContentType('application/json');
            $message->setRoutingKey($routingKey);
            $message->setDeliveryMode(AmqpMessage::DELIVERY_MODE_PERSISTENT); // <- clave

            // 5) Enviar
            $producer = $context->createProducer();
            $producer->send($exchange, $message);
        }
    }

}
