<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\EntityChangeLog;

class EntityChangeLogService
{
    public function __construct(private \PDO $pdo)
    {
    }

    public function resyncEntityLog(string $entityType, iterable $entities): void
    {
        foreach ($entities as $entityId => $payload) {
            $stmt = $this->pdo->prepare(
                'SELECT payload FROM sync_change_log
             WHERE entity_type = :entity_type AND entity_id = :entity_id
             ORDER BY changed_at DESC, id DESC LIMIT 1'
            );

            $stmt->execute([
                'entity_type' => $entityType,
                'entity_id' => $entityId,
            ]);

            $row = $stmt->fetch(\PDO::FETCH_ASSOC);
            $previousPayload = $row ? json_decode($row['payload'], true) : null;

            if ($previousPayload !== $payload) {
                $this->recordChange($entityType, $entityId, $payload);
            }
        }
    }

    public function recordChange(string $entityType, string $entityId, array $payload): void
    {
        $changedAt = (new \DateTimeImmutable())->format('Y-m-d H:i:s');
        $jsonPayload = json_encode($payload, JSON_UNESCAPED_UNICODE);

        // Paso 1: UPDATE optimista
        $update = $this->pdo->prepare(
            'UPDATE _audit_changelog
         SET deleted = false,
             changed_at = :changed_at,
             payload = :payload
         WHERE entity_type = :entity_type AND entity_id = :entity_id'
        );

        $update->execute([
            'entity_type' => $entityType,
            'entity_id' => $entityId,
            'changed_at' => $changedAt,
            'payload' => $jsonPayload,
        ]);

        // Paso 2: si no se actualizó nada, hacemos un INSERT
        if ($update->rowCount() === 0) {
            $insert = $this->pdo->prepare(
                'INSERT INTO _audit_changelog
             (entity_type, entity_id, deleted, changed_at, payload)
             VALUES (:entity_type, :entity_id, false, :changed_at, :payload)'
            );

            $insert->execute([
                'entity_type' => $entityType,
                'entity_id' => $entityId,
                'changed_at' => $changedAt,
                'payload' => $jsonPayload,
            ]);
        }
    }

    public function recordDeletion(string $entityType, string $entityId): void
    {
        $changedAt = (new \DateTimeImmutable())->format('Y-m-d H:i:s');
        $jsonPayload = json_encode([], JSON_UNESCAPED_UNICODE);

        $update = $this->pdo->prepare(
            'UPDATE _audit_changelog
         SET deleted = true,
             changed_at = :changed_at,
             payload = :payload
         WHERE entity_type = :entity_type AND entity_id = :entity_id'
        );

        $update->execute([
            'entity_type' => $entityType,
            'entity_id' => $entityId,
            'changed_at' => $changedAt,
            'payload' => $jsonPayload,
        ]);

        if ($update->rowCount() === 0) {
            $insert = $this->pdo->prepare(
                'INSERT INTO _audit_changelog
             (entity_type, entity_id, deleted, changed_at, payload)
             VALUES (:entity_type, :entity_id, true, :changed_at, :payload)'
            );

            $insert->execute([
                'entity_type' => $entityType,
                'entity_id' => $entityId,
                'changed_at' => $changedAt,
                'payload' => $jsonPayload,
            ]);
        }
    }

    public function getChangesSince(string $entityType, \DateTimeImmutable $since): array
    {
        $stmt = $this->pdo->prepare(
            'SELECT entity_type, entity_id, deleted, changed_at, payload
             FROM _audit_changelog
             WHERE entity_type = :entity_type AND changed_at > :since
             ORDER BY changed_at ASC'
        );

        $stmt->execute([
            'entity_type' => $entityType,
            'since' => $since->format('Y-m-d H:i:s'),
        ]);

        $rows = $stmt->fetchAll(\PDO::FETCH_ASSOC);

        return array_map(fn (array $row) => new EntityChangeLogEntry(
            $row['entity_type'],
            $row['entity_id'],
            (bool)$row['deleted'],
            new \DateTimeImmutable($row['changed_at']),
            json_decode($row['payload'], true)
        ), $rows);
    }

    public function getPendingChanges(string $entityType, string $clientId, int $limit = 100): array
    {
        $cursor = $this->pdo->prepare(
            'SELECT last_changed_at, last_entity_id
         FROM _audit_sync_cursor
         WHERE client_id = :client_id AND entity_type = :entity_type'
        );

        $cursor->execute([
            'client_id' => $clientId,
            'entity_type' => $entityType
        ]);

        $row = $cursor->fetch(\PDO::FETCH_ASSOC);

        $fromDate = $row ? $row['last_changed_at'] : '1970-01-01 00:00:00';
        $fromId   = $row ? $row['last_entity_id'] : '00000000-0000-0000-0000-000000000000';

        $stmt = $this->pdo->prepare(
            'SELECT * FROM _audit_changelog
         WHERE entity_type = :entity_type
           AND (
             changed_at > :fromDate OR
             (changed_at = :fromDate AND entity_id > :fromId)
           )
         ORDER BY changed_at ASC, entity_id ASC
         LIMIT :limit'
        );

        $stmt->bindValue(':entity_type', $entityType);
        $stmt->bindValue(':fromDate', $fromDate);
        $stmt->bindValue(':fromId', $fromId);
        $stmt->bindValue(':limit', $limit, \PDO::PARAM_INT);
        $stmt->execute();

        $rows = $stmt->fetchAll(\PDO::FETCH_ASSOC);

        return array_map(fn ($row) => new EntityChangeLogEntry(
            $row['entity_type'],
            $row['entity_id'],
            (bool)$row['deleted'],
            new \DateTimeImmutable($row['changed_at']),
            json_decode($row['payload'], true)
        ), $rows);
    }

    public function ackChanges(
        string $entityType,
        string $clientId,
        \DateTimeImmutable $lastChangedAt,
        string $lastEntityId
    ): void {
        $changedAt = $lastChangedAt->format('Y-m-d H:i:s');

        // Paso 1: UPDATE optimista
        $update = $this->pdo->prepare(
            'UPDATE _audit_sync_cursor
         SET last_changed_at = :last_changed_at,
             last_entity_id = :last_entity_id
         WHERE client_id = :client_id AND entity_type = :entity_type'
        );

        $update->execute([
            'client_id' => $clientId,
            'entity_type' => $entityType,
            'last_changed_at' => $changedAt,
            'last_entity_id' => $lastEntityId,
        ]);

        // Paso 2: si no se actualizó nada, hacemos un INSERT
        if ($update->rowCount() === 0) {
            $insert = $this->pdo->prepare(
                'INSERT INTO _audit_sync_cursor 
             (client_id, entity_type, last_changed_at, last_entity_id)
             VALUES (:client_id, :entity_type, :last_changed_at, :last_entity_id)'
            );

            $insert->execute([
                'client_id' => $clientId,
                'entity_type' => $entityType,
                'last_changed_at' => $changedAt,
                'last_entity_id' => $lastEntityId,
            ]);
        }
    }
}
