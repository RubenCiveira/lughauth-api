<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\EntityChangelog;

class EntityChangelogService
{
    public function __construct(private \PDO $pdo)
    {
    }

    public function resyncEntityLog(string $entityType, iterable $entities): void
    {
        foreach ($entities as $entityId => $payload) {
            $stmt = $this->pdo->prepare(
                'SELECT payload FROM _audit_changelog
             WHERE entity_type = :entity_type AND entity_id = :entity_id'
            );

            $stmt->execute([
                'entity_type' => $entityType,
                'entity_id' => $entityId,
            ]);

            $row = $stmt->fetch(\PDO::FETCH_ASSOC);
            $previousPayload = $row ? json_decode($row['payload'], true) : null;

            if ($previousPayload !== $payload) {
                $this->recordChange($entityType, $entityId, $payload);
            }
        }
    }

    public function recordChange(string $entityType, string $entityId, array $payload): void
    {
        $changedAt = (new \DateTimeImmutable())->format('Y-m-d H:i:s');
        $jsonPayload = json_encode($payload, JSON_UNESCAPED_UNICODE);

        // Paso 1: UPDATE optimista
        $update = $this->pdo->prepare(
            'UPDATE _audit_changelog
         SET deleted = false,
             changed_at = :changed_at,
             payload = :payload
         WHERE entity_type = :entity_type AND entity_id = :entity_id'
        );

        $update->execute([
            'entity_type' => $entityType,
            'entity_id' => $entityId,
            'changed_at' => $changedAt,
            'payload' => $jsonPayload,
        ]);

        // Paso 2: si no se actualizó nada, hacemos un INSERT
        if ($update->rowCount() === 0 && !$this->existsInChangelog($entityType, $entityId)) {
            $insert = $this->pdo->prepare(
                'INSERT INTO _audit_changelog
             (entity_type, entity_id, deleted, changed_at, payload)
             VALUES (:entity_type, :entity_id, false, :changed_at, :payload)'
            );

            $insert->execute([
                'entity_type' => $entityType,
                'entity_id' => $entityId,
                'changed_at' => $changedAt,
                'payload' => $jsonPayload,
            ]);
        }
    }

    public function recordDeletion(string $entityType, string $entityId): void
    {
        $changedAt = (new \DateTimeImmutable())->format('Y-m-d H:i:s');
        $jsonPayload = json_encode([], JSON_UNESCAPED_UNICODE);

        $update = $this->pdo->prepare(
            'UPDATE _audit_changelog
         SET deleted = true,
             changed_at = :changed_at,
             payload = :payload
         WHERE entity_type = :entity_type AND entity_id = :entity_id'
        );

        $update->execute([
            'entity_type' => $entityType,
            'entity_id' => $entityId,
            'changed_at' => $changedAt,
            'payload' => $jsonPayload,
        ]);

        if ($update->rowCount() === 0 && !$this->existsInChangelog($entityType, $entityId)) {
            $insert = $this->pdo->prepare(
                'INSERT INTO _audit_changelog
             (entity_type, entity_id, deleted, changed_at, payload)
             VALUES (:entity_type, :entity_id, true, :changed_at, :payload)'
            );

            $insert->execute([
                'entity_type' => $entityType,
                'entity_id' => $entityId,
                'changed_at' => $changedAt,
                'payload' => $jsonPayload,
            ]);
        }
    }

    public function getPendingChanges(
        string $entityType,
        string $clientId,
        int $limit = 100,
        array $filters = []
    ): array {
        // 1) Leer cursor
        $cursor = $this->pdo->prepare(
            'SELECT last_changed_at, last_entity_id
         FROM _audit_sync_cursor
         WHERE client_id = :client_id AND entity_type = :entity_type'
        );
        $cursor->execute([
            'client_id'   => $clientId,
            'entity_type' => $entityType,
        ]);
        $row = $cursor->fetch(\PDO::FETCH_ASSOC);

        $fromDate = $row ? $row['last_changed_at'] : '1970-01-01 00:00:00';
        $fromId   = $row ? $row['last_entity_id'] : '00000000-0000-0000-0000-000000000000';

        // 2) Construir SQL base (orden estable por changed_at, entity_id)
        $sql = '
        SELECT entity_type, entity_id, deleted, changed_at, payload
        FROM _audit_changelog
        WHERE entity_type = :entity_type
          AND (
            changed_at > :fromDate OR
            (changed_at = :fromDate AND entity_id > :fromId)
          )
    ';

        $params = [
            'entity_type' => $entityType,
            'fromDate'    => $fromDate,
            'fromId'      => $fromId,
        ];

        // 3) Añadir filtros portables
        foreach ($filters as $key => $value) {
            // $key = "campo.op" (eq|neq|in)
            $parts = explode('_', $key);
            $op = array_pop($parts);           // último elemento: eq, neq, in...
            $field = implode('_', $parts);     // resto unido con "_"
            $paramBase = 'f_' . preg_replace('/\W+/', '_', $field);

            $jsonExpr = $this->jsonTextExpr($field, $paramBase, $params);
            $driverHasJson = $jsonExpr !== null;

            switch (strtolower($op)) {
                case 'eq':
                    if ($driverHasJson) {
                        $sql .= " AND $jsonExpr = :$paramBase";
                        $params[$paramBase] = (string)$value;
                    } else {
                        $sql .= " AND payload LIKE :like_$paramBase ESCAPE '\\\\'";
                        $params["like_$paramBase"] = $this->buildJsonLike($field, (string)$value);
                    }
                    break;

                case 'neq':
                    if ($driverHasJson) {
                        $sql .= " AND ($jsonExpr IS NULL OR $jsonExpr <> :$paramBase)";
                        $params[$paramBase] = (string)$value;
                    } else {
                        $sql .= " AND payload NOT LIKE :like_$paramBase ESCAPE '\\\\'";
                        $params["like_$paramBase"] = $this->buildJsonLike($field, (string)$value);
                    }
                    break;

                case 'in':
                    if (!is_iterable($value)) {
                        throw new \InvalidArgumentException("El operador 'in' requiere un array de valores");
                    }
                    if ($driverHasJson) {
                        $phs = [];
                        $i = 0;
                        foreach ($value as $v) {
                            $ph = "{$paramBase}_$i";
                            $phs[] = ':' . $ph;
                            $params[$ph] = (string)$v;
                            $i++;
                        }
                        if ($phs) {
                            $sql .= " AND $jsonExpr IN (" . implode(',', $phs) . ")";
                        }
                    } else {
                        $likes = [];
                        $i = 0;
                        foreach ($value as $v) {
                            $ph = "like_{$paramBase}_$i";
                            $likes[] = "payload LIKE :$ph ESCAPE '\\\\'";
                            $params[$ph] = $this->buildJsonLike($field, (string)$v);
                            $i++;
                        }
                        if ($likes) {
                            $sql .= ' AND (' . implode(' OR ', $likes) . ')';
                        }
                    }
                    break;

                default:
                    throw new \InvalidArgumentException("Operador no soportado: $op");
            }
        }

        $sql .= ' ORDER BY changed_at ASC, entity_id ASC LIMIT :limit';

        // 4) Preparar y ejecutar
        $stmt = $this->pdo->prepare($sql);

        // Parámetros escalares
        foreach ($params as $k => $v) {
            $stmt->bindValue(':' . $k, $v);
        }
        // Límite como int
        $stmt->bindValue(':limit', $limit, \PDO::PARAM_INT);

        $stmt->execute();
        $rows = $stmt->fetchAll(\PDO::FETCH_ASSOC);

        // 5) Mapear resultado
        return array_map(fn ($row) => new EntityChangeLogEntry(
            $row['entity_type'],
            $row['entity_id'],
            (bool)$row['deleted'],
            new \DateTimeImmutable($row['changed_at']),
            json_decode($row['payload'], true)
        ), $rows);
    }

    public function ackChanges(
        string $entityType,
        string $clientId,
        \DateTimeImmutable $lastChangedAt,
        string $lastEntityId
    ): void {
        $changedAt = $lastChangedAt->format('Y-m-d H:i:s');

        // Paso 1: UPDATE optimista
        $update = $this->pdo->prepare(
            'UPDATE _audit_sync_cursor
         SET last_changed_at = :last_changed_at,
             last_entity_id = :last_entity_id
         WHERE client_id = :client_id AND entity_type = :entity_type'
        );

        $update->execute([
            'client_id' => $clientId,
            'entity_type' => $entityType,
            'last_changed_at' => $changedAt,
            'last_entity_id' => $lastEntityId,
        ]);

        // Paso 2: si no se actualizó nada, hacemos un INSERT
        if ($update->rowCount() === 0 && !$this->existsInCursor($clientId, $entityType)) {
            $insert = $this->pdo->prepare(
                'INSERT INTO _audit_sync_cursor 
             (client_id, entity_type, last_changed_at, last_entity_id)
             VALUES (:client_id, :entity_type, :last_changed_at, :last_entity_id)'
            );

            $insert->execute([
                'client_id' => $clientId,
                'entity_type' => $entityType,
                'last_changed_at' => $changedAt,
                'last_entity_id' => $lastEntityId,
            ]);
        }
    }

    private function existsInChangelog(string $entityType, string $entityId): bool
    {
        $stmt = $this->pdo->prepare(
            'SELECT 1 FROM _audit_changelog
             WHERE entity_type = :entity_type AND entity_id = :entity_id'
        );

        $stmt->execute([
            'entity_type' => $entityType,
            'entity_id' => $entityId,
        ]);

        return (bool)$stmt->fetchColumn();
    }

    private function existsInCursor(string $clientId, string $entityType): bool
    {
        $stmt = $this->pdo->prepare(
            'SELECT 1 FROM _audit_sync_cursor
             WHERE client_id = :client_id AND entity_type = :entity_type'
        );

        $stmt->execute([
            'client_id' => $clientId,
            'entity_type' => $entityType,
        ]);

        return (bool)$stmt->fetchColumn();
    }

    private function dbDriver(): string
    {
        return $this->pdo->getAttribute(\PDO::ATTR_DRIVER_NAME); // 'mysql' | 'pgsql' | 'sqlite' | ...
    }

    private function jsonTextExpr(string $field, string $paramBase, array &$params): ?string
    {
        $driver = $this->dbDriver();

        switch ($driver) {
            case 'mysql':
                // JSON_UNQUOTE(JSON_EXTRACT(payload, '$.field'))
                $params["path_$paramBase"] = '$.' . $field;
                return "JSON_UNQUOTE(JSON_EXTRACT(payload, :path_$paramBase))";

            case 'pgsql':
                // (payload::json->>'field') con clave parametrizada
                // En PG se puede parametrizar el segundo operando (text)
                $params["key_$paramBase"] = $field;
                return "(payload::json->>:key_$paramBase)";

            case 'sqlite':
                // json_extract(payload, '$.field')
                $params["path_$paramBase"] = '$.' . $field;
                return "json_extract(payload, :path_$paramBase)";

            default:
                // Fallback: no hay expresión portable -> usar LIKE sobre payload (devuelve null aquí)
                return null;
        }
    }

    /** Construye un patrón LIKE para '"campo":"valor"' con escape seguro. */
    private function buildJsonLike(string $field, string $value): string
    {
        // JSON-encode para meter comillas correctas y escapes de caracteres especiales
        $f = json_encode((string)$field, JSON_UNESCAPED_UNICODE);   // => "\"campo\""
        $v = json_encode((string)$value, JSON_UNESCAPED_UNICODE);   // => "\"valor\""

        // Patrón básico: %"campo":"valor"%
        $pattern = '%' . $f . ':' . $v . '%';

        // Escapar comodines de LIKE por si value trae % o _
        $pattern = str_replace(['%',  '_'], ['\%', '\_'], $pattern);

        return $pattern;
    }
}
