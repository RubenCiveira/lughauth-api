<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Scheduler;

/**
 * Supervises the scheduler worker process lifecycle.
 */
final class Supervisor
{
    public function __construct(
        /** @var string Base directory for scheduler paths. */
        private readonly string $baseDir,
        /** @var string Preferred PHP binary path. */
        private readonly string $phpBin = '',
        /** @var string Worker script path. */
        private readonly string $worker = 'binary/scheduler_worker',
        /** @var string PID file relative path. */
        private readonly string $pidRel  = 'var/scheduler.pid',
        /** @var string Lock file relative path. */
        private readonly string $lockRel = 'var/scheduler.lock',
        /** @var string Log file relative path. */
        private readonly string $logRel  = 'var/scheduler.log',
        /** @var string|null Override OS family (tests only). */
        private readonly ?string $osFamily = null,
        /** @var bool|null Override posix_kill availability (tests only). */
        private readonly ?bool $posixKillAvailable = null,
        /** @var string|null Override PHP SAPI (tests only). */
        private readonly ?string $phpSapi = null,
        /** @var string|null Override PHP_BINARY (tests only). */
        private readonly ?string $phpBinary = null,
        /** @var array|null Override PHP candidates (tests only). */
        private readonly ?array $phpCandidates = null
    ) {
    }

    /**
     * Ensures the scheduler worker is running for a given URL.
     */
    public function ensureRunning($url): void
    {
        $pidFile  = $this->path($this->pidRel);
        $lockFile = $this->path($this->lockRel);
        $logFile  = $this->path($this->logRel);
        $worker   = $this->path($this->worker);

        // Evita carreras entre workers/peticiones
        @mkdir(\dirname($lockFile), 0775, true);
        $lock = @fopen($lockFile, 'c+');
        if (!$lock) {
            return;
        }
        if (!@flock($lock, LOCK_EX | LOCK_NB)) {
            fclose($lock);
            return;
        }

        try {
            $pid = $this->readPid($pidFile);

            if ($pid && $this->isRunning($pid)) {
                // Ya está en marcha
                return;
            }

            // PID inexistente o zombie → limpia y relanza
            if ($pid) {
                @unlink($pidFile);
            }

            $ok = $this->spawnBackground($worker, $url, $logFile);
            if ($ok > 0) {
                file_put_contents($pidFile, (string)$ok);
            } else {
                file_put_contents($logFile, "[".date('c')."] spawn failed\n", FILE_APPEND);
            }
        } finally {
            @flock($lock, LOCK_UN);
            @fclose($lock);
        }
    }

    private function path(string $rel): string
    {
        if (str_starts_with($rel, '/')) {
            return $rel;
        }
        return rtrim($this->baseDir, '/').'/'.$rel;
    }

    private function readPid(string $pidFile): ?int
    {
        if (!is_file($pidFile)) {
            return null;
        }
        $raw = trim((string)@file_get_contents($pidFile));
        return (ctype_digit($raw) && (int)$raw > 0) ? (int)$raw : null;
    }

    private function isRunning(int $pid): bool
    {
        if (!$this->hasPosixKill()) {
            // Fallback “best-effort” si no hay ext posix
            return @file_exists("/proc/{$pid}");
        }
        return @posix_kill($pid, 0);
    }

    /**
     * Lanza el worker completamente en background y retorna el PID (>0 si OK, 0/negativo si falla).
     * POSIX (Linux/Unix). Para Windows, ver comentario abajo.
     */
    private function spawnBackground(string $worker, string $arg, string $logFile): int
    {
        @mkdir(dirname($logFile), 0775, true);

        $phpCli = $this->resolvePhpCli($this->phpBin);
        $php = escapeshellarg($phpCli ?: 'php');

        $workerPath = realpath($worker);
        if ($workerPath === false) {
            return 0;
        }

        $exe = $php.' '.escapeshellarg($workerPath).($arg ? ' '.escapeshellarg($arg) : '');
        $log = escapeshellarg($logFile);

        // Construimos el comando según plataforma
        if ($this->isWindows()) {
            // Windows: no hay PID fiable -> best-effort
            $cmd = 'start /B "" '.$exe.' > NUL 2>&1';
            pclose(popen($cmd, 'r'));
            return 0; // sin PID fiable en Windows
        }

        // POSIX: usamos /bin/sh para poder capturar $!
        $hasSetsid = (bool) @shell_exec('command -v setsid 2>/dev/null');

        if ($hasSetsid) {
            // Linux (con setsid): desacopla del grupo de sesión
            $cmd = 'nohup setsid '.$exe.' </dev/null >> '.$log.' 2>&1 & echo $!';
        } else {
            // macOS / BSD: sin setsid. nohup + background + echo $!
            $cmd = 'nohup '.$exe.' </dev/null >> '.$log.' 2>&1 & echo $!';
        }

        // IMPORTANTE: ejecutar via sh -c para que $! se expanda
        $descriptors = [
            0 => ['pipe', 'r'],
            1 => ['pipe', 'w'],
            2 => ['pipe', 'w'],
        ];
        $pipes = [];
        $proc = @proc_open(['/bin/sh', '-c', $cmd], $descriptors, $pipes, $this->baseDir);
        if (!\is_resource($proc)) {
            return 0;
        }

        $pid = (int) trim(stream_get_contents($pipes[1]) ?: '0');
        foreach ($pipes as $p) {
            if (\is_resource($p)) {
                fclose($p);
            }
        }
        @proc_close($proc);

        return $pid > 0 ? $pid : 0;
    }

    // (Opcional) método para detener el daemon
    /**
     * Stops the scheduler worker process if possible.
     */
    public function stop(): void
    {
        $pid = $this->readPid($this->path($this->pidRel));
        if ($pid && $this->isRunning($pid) && function_exists('posix_kill')) {
            @posix_kill($pid, SIGTERM);
        }
    }

    private function resolvePhpCli(): string
    {
        // 1) si nos pasan uno preferido (config), úsalo
        // 2) si estamos en CLI y el binario parece 'php' normal, úsalo
        $sapi = $this->phpSapi ?? \PHP_SAPI;
        $binary = $this->phpBinary ?? PHP_BINARY;
        if ($sapi === 'cli' && !str_contains(basename($binary), 'php-fpm')) {
            return $binary;
        }

        // 3) variables de entorno de cortesía
        $candidates = [];
        foreach (['PHP_CLI','PHP','PHP_BIN'] as $env) {
            $v = getenv($env);
            if ($v) {
                $candidates[] = $v;
            }
        }

        // 4) which php
        $which = @trim((string)@shell_exec('command -v php 2>/dev/null'));
        if ($which) {
            $candidates[] = $which;
        }

        // 5) rutas típicas (macOS Homebrew primero)
        $defaultCandidates = [
            '/opt/homebrew/bin/php',  // macOS arm64 (brew)
            '/usr/local/bin/php',     // macOS intel (brew)
            '/usr/bin/php',           // macOS / Linux
            '/bin/php',
        ];
        $candidates = array_merge($candidates, $this->phpCandidates ?? $defaultCandidates);

        // filtra candidatos que existan y no sean php-fpm
        foreach ($candidates as $path) {
            if ($path && @is_file($path) && @is_executable($path) && !str_contains(basename($path), 'php-fpm')) {
                return $path;
            }
        }

        // último recurso: 'php' y que el shell resuelva PATH
        return 'php';
    }

    protected function isWindows(): bool
    {
        $family = $this->osFamily ?? PHP_OS_FAMILY;
        return stripos($family, 'Windows') === 0;
    }

    protected function hasPosixKill(): bool
    {
        if ($this->posixKillAvailable !== null) {
            return $this->posixKillAvailable;
        }

        return function_exists('posix_kill');
    }
}
