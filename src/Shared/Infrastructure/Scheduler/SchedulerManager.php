<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Scheduler;

use Cron\CronExpression;
use DateTimeImmutable;
use Psr\Container\ContainerInterface;
use Psr\SimpleCache\CacheInterface;
use Symfony\Component\Lock\LockFactory;
use Civi\Lughauth\Shared\Observability\LoggerAwareTrait;

/**
 * Coordinates scheduled task execution based on cron expressions.
 */
class SchedulerManager
{
    use LoggerAwareTrait;
    private const CACHE_KEY_STATE = 'scheduler_manager_state';
    private const LOCK_KEY = 'scheduler_manager_lock';

    /** @var array<array{CronExpression, string, string}> Registered tasks. */
    private array $tasks = [];

    /**
     * Registers a task type and method for a cron schedule.
     */
    public function register(CronExpression $expresion, string $type, string $method): void
    {
        $this->tasks[] = [$expresion, $type, $method];
    }

    /**
     * Runs the scheduler cycle and registers deferred execution.
     */
    public function run(LockFactory $locker, CacheInterface $cache, ContainerInterface $container): void
    {
        $now = new DateTimeImmutable();

        $state = $cache->get(self::CACHE_KEY_STATE, [
            'last_executions' => [], // taskKey => timestamp
            'next_execution' => null,
        ]);
        $nextGlobalExecution = null;
        $runnableTasks = [];

        foreach ($this->tasks as $task) {
            [$cron, $type, $method] = $task;
            $taskKey = $this->getTaskKey($type, $method);

            $lastRun = isset($state['last_executions'][$taskKey])
                ? new \DateTimeImmutable($state['last_executions'][$taskKey])
                : null;

            $nextFromLast = $cron->getNextRunDate($lastRun ?? $now, 0, true); // allowCurrentDate = true

            // ¿Toca ejecutar esta tarea?
            if ($nextFromLast <= $now) {
                $previousRun = $cron->getPreviousRunDate($now);
                if ($lastRun === null || $previousRun > $lastRun) {
                    $runnableTasks[] = [$cron, $type, $method, $taskKey];
                }
            }

            // Calcular la próxima ejecución de cada tarea
            $nextRun = $cron->getNextRunDate($now);
            if ($nextGlobalExecution === null || $nextRun < $nextGlobalExecution) {
                $nextGlobalExecution = $nextRun;
            }
        }

        // ¿Ya pasamos la hora de próxima ejecución global?
        $cachedNext = isset($state['next_execution']) ? new \DateTimeImmutable($state['next_execution']) : null;

        if ($cachedNext !== null && $cachedNext > $now) {
            $this->logInfo('No task is pending to execute.');
        } else {
            $this->logInfo('There are pending tasks.');
            // Deferir ejecución para el shutdown, no afectar la request principal
            register_shutdown_function(function ($manager, $locker, $cache, $runnableTasks, $now, $nextGlobalExecution, $state, $container) {
                $manager->logInfo('Run scheduler manager on background');
                $lock = $locker->createLock(self::LOCK_KEY, 30); // 30s TTL
                if ($lock->acquire()) {
                    try {
                        $manager->logWarning('The lock is adquired, we can execute.');
                        foreach ($runnableTasks as [$cron, $type, $method, $taskKey]) {
                            if ($container->has($type)) {
                                $instance = $container->get($type);
                                if (!method_exists($instance, $method)) {
                                    $manager->logError("The task {$type} dont have method {$method}");
                                    continue;
                                }
                                // Ejecutar la tarea
                                try {
                                    $manager->logInfo("Launching task {$type}::{$method}");
                                    call_user_func([$instance, $method]);
                                    $manager->logInfo("Updating task {$type}::{$method}");
                                    $state['last_executions'][$taskKey] = $now->format(DATE_ATOM);
                                } catch (\Throwable $e) {
                                    // Loguear o ignorar según sea necesario
                                    $manager->logError("The task {$type}::{$method} has an error " . $e->getMessage(), $e->getTraceAsString());
                                }
                            } else {
                                $manager->logError("The task {$type} is not on the container");
                            }
                        }
                        $manager->logInfo("Updating next execution info");
                        // Actualizar próxima ejecución global
                        $state['next_execution'] = $nextGlobalExecution?->format(DATE_ATOM);
                        $cache->set(self::CACHE_KEY_STATE, $state);
                    } finally {
                        $manager->logInfo("Release lock of scheduler");
                        $lock->release();
                    }
                } else {
                    $manager->logWarning('The lock is blocked, we cant execute.');
                }
            }, $this, $locker, $cache, $runnableTasks, $now, $nextGlobalExecution, $state, $container);
        }
    }

    private function getTaskKey(string $type, string $method): string
    {
        return sprintf('%s::%s', $type, $method);
    }
}
