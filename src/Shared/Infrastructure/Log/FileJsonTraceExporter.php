<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Log;

use Override;
use Throwable;
use OpenTelemetry\SDK\Trace\SpanExporterInterface;
use OpenTelemetry\SDK\Trace\SpanDataInterface;
use OpenTelemetry\SDK\Common\Future\CancellationInterface;
use OpenTelemetry\SDK\Common\Future\CompletedFuture;
use OpenTelemetry\SDK\Common\Future\FutureInterface;

class FileJsonTraceExporter implements SpanExporterInterface
{
    private string $basePath;
    private string $filenameFormat;
    private string $dateFormat;
    private int $maxFiles;
    private string $currentFile;
    private string $currentDate;

    public function __construct(
        string $basePath,
        int $maxFiles = 7,
        string $dateFormat = 'Y-m-d',
        string $filenameFormat = '{filename}-{date}.json'
    ) {
        $this->basePath = realpath(dirname($basePath)) . '/' . basename($basePath);
        $this->maxFiles = $maxFiles;
        $this->dateFormat = $dateFormat;
        $this->filenameFormat = $filenameFormat;
        $this->currentDate = date($dateFormat);
        $this->currentFile = $this->resolveFilename();

        $this->rotateIfNeeded();
    }

    #[Override]
    public function export(iterable $batch, ?CancellationInterface $cancellation = null): FutureInterface
    {
        try {
            $this->rotateIfNeeded();

            $handle = fopen($this->currentFile, 'a');
            if (!$handle) {
                return new CompletedFuture(false);
            }
            foreach ($batch as $span) {
                fwrite($handle, json_encode($this->normalize($span), JSON_UNESCAPED_SLASHES) . "\n");
            }
            fclose($handle);
            return new CompletedFuture(true);
        } catch (\Throwable $e) {
            return new CompletedFuture(false);
        }
    }

    #[Override]
    public function shutdown(?CancellationInterface $cancellation = null): bool
    {
        return true;
    }

    #[Override]
    public function forceFlush(?CancellationInterface $cancellation = null): bool
    {
        return true;
    }

    private function normalize(SpanDataInterface $span): array
    {
        return [
            'traceId'    => $span->getTraceId(),
            'spanId'     => $span->getSpanId(),
            'parentSpanId'  => $span->getParentSpanId(),
            'name'       => $span->getName(),
            'kind'       => $span->getKind(),
            'start'      => $span->getStartEpochNanos(),
            'end'        => $span->getEndEpochNanos(),
            'attributes' => $span->getAttributes(),
            'status'     => $span->getStatus()->getCode(),
        ];
    }

    private function resolveFilename(): string
    {
        $info = pathinfo($this->basePath);
        $filename = str_replace(
            ['{filename}', '{date}'],
            [$info['filename'], $this->currentDate],
            $this->filenameFormat
        );

        return ($info['dirname'] ?? '.') . '/' . $filename;
    }

    private function rotateIfNeeded(): void
    {
        $today = date($this->dateFormat);
        if ($this->currentDate !== $today) {
            $this->currentDate = $today;
            $this->currentFile = $this->resolveFilename();
            $this->cleanupOldFiles();
        }
    }

    private function cleanupOldFiles(): void
    {
        if ($this->maxFiles === 0) {
            return;
        }

        $info = pathinfo($this->basePath);
        $pattern = str_replace(
            ['{filename}', '{date}'],
            [$info['filename'], '*'],
            $this->filenameFormat
        );

        $globPattern = ($info['dirname'] ?? '.') . '/' . $pattern;
        $files = glob($globPattern);

        usort($files, fn ($a, $b) => strcmp($b, $a)); // MÃ¡s recientes primero

        foreach (array_slice($files, $this->maxFiles) as $file) {
            @unlink($file);
        }
    }
}
