<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Log;

use Override;
use OpenTelemetry\SDK\Trace\SpanExporterInterface;
use OpenTelemetry\SDK\Trace\SpanDataInterface;
use OpenTelemetry\SDK\Common\Future\CancellationInterface;
use OpenTelemetry\SDK\Common\Future\CompletedFuture;
use OpenTelemetry\SDK\Common\Future\FutureInterface;

/**
 * Exports spans into rotating JSONL files with gzip support.
 */
class SpanJsonGzipRotatingFileExporter implements SpanExporterInterface
{
    /** @var string Base path used to build log filenames. */
    private readonly string $basePath;
    /** @var string Filename pattern for rotated files. */
    private readonly string $filenameFormat;
    /** @var int Maximum number of files to keep. */
    private readonly int $maxFiles;
    /** @var string Resolved current output file path. */
    private readonly string $currentFile;
    /** @var string Current date string used in filenames. */
    private readonly string $currentDate;
    /** @var bool Whether to gzip files during rotation. */
    private readonly bool $zipOnRotate;

    /**
     * Creates a span exporter that writes JSONL files.
     *
     * @param string $basePath Base output file path.
     * @param int $maxFiles Maximum number of rotated files to keep.
     * @param string $dateFormat Date format for filenames.
     * @param string $filenameFormat Filename format template.
     * @param bool $zipOnRotate Whether to gzip rotated files.
     */
    public function __construct(
        string $basePath,
        int $maxFiles = 7,
        string $dateFormat = 'Y-m-d',
        string $filenameFormat = '{filename}-{date}.jsonl',
        bool $zipOnRotate = true
    ) {
        $resolvedDir = realpath(dirname($basePath));
        $this->basePath = ($resolvedDir !== false ? $resolvedDir : dirname($basePath)) . '/' . basename($basePath);
        $this->maxFiles = $maxFiles;
        $this->zipOnRotate = $zipOnRotate;
        $this->filenameFormat = $filenameFormat;
        $this->currentDate = date($dateFormat);
        $this->currentFile = $this->resolveFilename();
        register_shutdown_function([$this, 'rotateIfNeeded']);
        // $this->rotateIfNeeded();
    }

    /**
     * Writes span batches into the current JSONL file.
     */
    #[Override]
    public function export(iterable $batch, ?CancellationInterface $cancellation = null): FutureInterface
    {
        try {
            $this->rotateIfNeeded();

            $handle = fopen($this->currentFile, 'a');
            if (!$handle) {
                return new CompletedFuture(false);
            }
            foreach ($batch as $span) {
                $json = json_encode($this->normalize($span), JSON_UNESCAPED_SLASHES);
                if ($json !== false) {
                    fwrite($handle, $json . "\n");
                }
            }
            fclose($handle);
            return new CompletedFuture(true);
        } catch (\Throwable $e) {
            return new CompletedFuture(false);
        }
    }

    /**
     * Performs exporter shutdown work.
     */
    #[Override]
    public function shutdown(?CancellationInterface $cancellation = null): bool
    {
        return true;
    }

    /**
     * Flushes buffered spans.
     */
    #[Override]
    public function forceFlush(?CancellationInterface $cancellation = null): bool
    {
        return true;
    }

    private function normalize(SpanDataInterface $span): array
    {
        return [
            'traceId'    => $span->getTraceId(),
            'spanId'     => $span->getSpanId(),
            'parentSpanId'  => $span->getParentSpanId(),
            'name'       => $span->getName(),
            'kind'       => $span->getKind(),
            'start'      => $span->getStartEpochNanos(),
            'end'        => $span->getEndEpochNanos(),
            'attributes' => $span->getAttributes(),
            'status'     => $span->getStatus()->getCode(),
        ];
    }

    private function resolveFilename(): string
    {
        $info = pathinfo($this->basePath);
        $filename = str_replace(
            ['{filename}', '{date}'],
            [$info['filename'], $this->currentDate],
            $this->filenameFormat
        );

        return ($info['dirname'] ?? '.') . '/' . $filename;
    }

    private function rotateIfNeeded(): void
    {
        if ($this->maxFiles === 0) {
            return;
        }

        $info = pathinfo($this->basePath);
        $pattern = str_replace(
            ['{filename}', '{date}'],
            [$info['filename'], '*'],
            $this->filenameFormat
        ) . '*';

        $globPattern = ($info['dirname'] ?? '.') . '/' . $pattern;
        $globResult = glob($globPattern);
        $files = $globResult !== false ? $globResult : [];

        usort($files, fn (string $a, string $b): int => strcmp($b, $a));

        foreach (array_slice($files, $this->maxFiles) as $file) {
            @unlink($file);
        }
        if ($this->zipOnRotate) {
            $today = $this->resolveFilename();
            foreach (array_slice($files, 0, $this->maxFiles) as $file) {
                if ($file !== $today && !str_ends_with($file, '.gz')) {
                    $this->gzipFile($file, $file.'.gz');
                    unlink($file);
                }
            }
        }
    }

    private function gzipFile(string $src, string $dst, int $level = 9): void
    {
        $in = @fopen($src, 'rb');
        if (!$in) {
            return;
        }
        $gz = @gzopen($dst, 'wb' . \max(1, \min(9, $level)));
        if (!$gz) {
            @fclose($in);
            return;
        }
        try {
            while (!feof($in)) {
                $chunk = fread($in, 1024 * 1024); // 1 MiB
                if ($chunk === false) {
                    break;
                }
                gzwrite($gz, $chunk);
            }
        } finally {
            @fclose($in);
            @gzclose($gz);
        }
    }
}
