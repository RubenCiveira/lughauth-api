<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Audit;

use Override;
use PDO;
use PDOStatement;

/**
 * PDO statement wrapper that automatically captures database modifications for audit logging.
 *
 * This class extends PDOStatement to intercept INSERT, UPDATE, and DELETE operations,
 * automatically recording the affected rows in the audit context. It supports multiple
 * database drivers (MySQL, PostgreSQL, SQLite, SQL Server) with driver-specific
 * primary key detection.
 *
 * The statement is configured via PDO::ATTR_STATEMENT_CLASS in AuditablePdoWrapper.
 *
 * @see AuditablePdoWrapper Configures PDO to use this statement class.
 * @see AuditContext        Where captured changes are accumulated.
 */
class AuditablePdoStatement extends PDOStatement
{
    /** @var array<int|string, mixed> Parameters bound via bindParam() or bindValue(). */
    private array $boundParams = [];

    /**
     * Internal constructor called by PDO when preparing statements.
     *
     * @param AuditContext $context The request-scoped audit context.
     * @param PDO          $pdo     The parent PDO connection.
     */
    protected function __construct(
        /** @var AuditContext Request-scoped context for collecting changes. */
        private readonly AuditContext $context,
        /** @var PDO Parent database connection for metadata queries. */
        private readonly PDO $pdo
    ) {
    }

    /**
     * {@inheritDoc}
     *
     * Captures the bound parameter for potential use in audit trail resolution.
     */
    #[Override]
    public function bindParam(int|string $param, mixed &$var, int $type = \PDO::PARAM_STR, int $maxLength = 0, mixed $driverOptions = null): bool
    {
        $this->boundParams[$param] = $var;
        return parent::bindParam($param, $var, $type, $maxLength, $driverOptions);
    }

    /**
     * {@inheritDoc}
     *
     * Captures the bound value for potential use in audit trail resolution.
     */
    #[Override]
    public function bindValue(int|string $param, mixed $value, int $type = \PDO::PARAM_STR): bool
    {
        $this->boundParams[$param] = $value;
        return parent::bindValue($param, $value, $type);
    }

    /**
     * {@inheritDoc}
     *
     * Executes the statement and, for write operations (INSERT/UPDATE/DELETE),
     * automatically records the affected row state in the audit context.
     */
    #[Override]
    public function execute(?array $params = null): bool
    {
        $isWrite = preg_match('/^\s*(INSERT|UPDATE|DELETE)\s+(?:INTO\s+)?`?([a-zA-Z0-9_]+)`?/i', $this->queryString, $match);
        if (!$isWrite || !$this->context->hasAction()) {
            return parent::execute($params);
        }

        $operation = strtoupper($match[1]);
        $table = $match[2];

        // Ejecutamos primero
        $result = parent::execute($params);
        if (!$result) {
            return false;
        }

        $driver = $this->pdo->getAttribute(PDO::ATTR_DRIVER_NAME);

        // Determinar clave primaria de la tabla
        $pkColumn = $this->findPrimaryKeyColumn($table, $driver);
        if ($pkColumn === null) {
            return true; // No se puede auditar sin PK
        }

        if ($params !== null) {
            foreach ($params as $k => $v) {
                $this->boundParams[$k] = $v;
            }
        }

        $primaryKeyValue = $this->resolvePrimaryKeyValue($operation, $pkColumn, $driver);

        if ($primaryKeyValue === null) {
            return true; // No auditable
        }

        $stmt = $this->pdo->prepare("SELECT * FROM `$table` WHERE `$pkColumn` = :id");
        $stmt->execute(['id' => $primaryKeyValue]);
        $row = $stmt->fetch(\PDO::FETCH_ASSOC);

        if (!$row) {
            return true;
        }

        $actionId = $this->context->getActionId();
        if ($actionId === null) {
            return true; // No action context available
        }

        $this->context->addChange(new AuditChange(
            actionId: $actionId,
            targetType: ucfirst($table),
            targetId: (string) $primaryKeyValue,
            changeType: strtolower($operation),
            payload: $row
        ));

        return true;
    }

    /**
     * Extracts the table name from a SQL statement.
     *
     * @param string $sql The SQL query string.
     *
     * @return string|null The table name or null if not parseable.
     */
    private function extractTable(string $sql): ?string
    {
        if (preg_match('/^\s*(UPDATE|INSERT INTO|DELETE FROM)\s+`?([a-zA-Z0-9_]+)`?/i', $sql, $m)) {
            return $m[2];
        }
        return null;
    }

    /**
     * Resolves the primary key value for the affected row.
     *
     * For INSERT operations, retrieves the last inserted ID. For UPDATE/DELETE,
     * attempts to find the primary key in the bound parameters.
     *
     * @param string $operation The SQL operation type (INSERT, UPDATE, DELETE).
     * @param string $pkColumn  The primary key column name.
     * @param string $driver    The PDO driver name.
     *
     * @return mixed The primary key value or null if unresolvable.
     */
    private function resolvePrimaryKeyValue(string $operation, string $pkColumn, string $driver): mixed
    {
        if ($operation === 'INSERT') {
            return match ($driver) {
                'pgsql'     => $this->pdo->lastInsertId(), // o usar RETURNING en query real
                'mysql', 'mariadb', 'sqlite' => $this->pdo->lastInsertId(),
                'sqlsrv'    => $this->pdo->query("SELECT SCOPE_IDENTITY()")->fetchColumn(),
                default     => null,
            };
        }

        // Para UPDATE o DELETE, requerimos introspección adicional o bind manual
        // Podrías mejorar esto si capturas $params antes de execute()
        return $this->boundParams[$pkColumn] ?? null;
    }

    /**
     * Discovers the primary key column name for a given table.
     *
     * Uses database-specific introspection queries to determine the primary
     * key column. Supports MySQL/MariaDB, PostgreSQL, SQL Server, and SQLite.
     *
     * @param string $table  The table name to inspect.
     * @param string $driver The PDO driver name.
     *
     * @return string|null The primary key column name or null if not found.
     */
    private function findPrimaryKeyColumn(string $table, string $driver): ?string
    {
        return match ($driver) {
            'mysql', 'mariadb' => $this->queryOne(
                "SELECT COLUMN_NAME
             FROM INFORMATION_SCHEMA.COLUMNS
             WHERE TABLE_SCHEMA = DATABASE()
               AND TABLE_NAME = :table
               AND COLUMN_KEY = 'PRI'
             LIMIT 1",
                ['table' => $table]
            ),
            'pgsql' => $this->queryOne(
                "SELECT a.attname
             FROM pg_index i
             JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey)
             WHERE i.indrelid = :table::regclass AND i.indisprimary
             LIMIT 1",
                ['table' => $table]
            ),
            'sqlsrv' => $this->queryOne(
                "SELECT c.COLUMN_NAME
             FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc
             JOIN INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE ccu ON tc.CONSTRAINT_NAME = ccu.CONSTRAINT_NAME
             JOIN INFORMATION_SCHEMA.COLUMNS c ON c.TABLE_NAME = tc.TABLE_NAME AND c.COLUMN_NAME = ccu.COLUMN_NAME
             WHERE tc.TABLE_NAME = :table AND tc.CONSTRAINT_TYPE = 'PRIMARY KEY'",
                ['table' => $table]
            ),
            'sqlite' => $this->findPrimaryKeyColumnSqlite($table),
            default => null
        };
    }

    /**
     * Finds the primary key column for a SQLite table using PRAGMA.
     *
     * @param string $table The table name to inspect.
     *
     * @return string|null The primary key column name or null if not found.
     */
    private function findPrimaryKeyColumnSqlite(string $table): ?string
    {
        $stmt = $this->pdo->prepare("PRAGMA table_info($table)");
        $stmt->execute();
        $rows = $stmt->fetchAll(\PDO::FETCH_ASSOC);
        foreach ($rows as $row) {
            if (!empty($row['pk'])) {
                return $row['name'];
            }
        }
        return null;
    }

    /**
     * Executes a query and returns the first column of the first row.
     *
     * @param string               $sql    The SQL query to execute.
     * @param array<string, mixed> $params Parameters to bind to the query.
     *
     * @return string|null The column value or null if no results.
     */
    private function queryOne(string $sql, array $params): ?string
    {
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute($params);
        return $stmt->fetchColumn() ?: null;
    }
}
