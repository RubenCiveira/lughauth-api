<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Audit;

use Override;
use PDO;
use PDOStatement;

class AuditablePdoStatement extends PDOStatement
{
    private array $boundParams = [];

    protected function __construct(
        private readonly AuditContext $context,
        private readonly PDO $pdo
    ) {
    }

    #[Override]
    public function bindParam($parameter, &$variable, $data_type = \PDO::PARAM_STR, $length = null, $driver_options = null): bool
    {
        $this->boundParams[$parameter] = $variable;
        return parent::bindParam($parameter, $variable, $data_type, $length, $driver_options);
    }

    #[Override]
    public function bindValue($parameter, $value, $data_type = \PDO::PARAM_STR): bool
    {
        $this->boundParams[$parameter] = $value;
        return parent::bindValue($parameter, $value, $data_type);
    }

    #[Override]
    public function execute(?array $params = null): bool
    {
        $isWrite = preg_match('/^\s*(INSERT|UPDATE|DELETE)\s+(?:INTO\s+)?`?([a-zA-Z0-9_]+)`?/i', $this->queryString, $match);
        if (!$isWrite || !$this->context->hasAction()) {
            return parent::execute($params);
        }

        $operation = strtoupper($match[1]);
        $table = $match[2];

        // Ejecutamos primero
        $result = parent::execute($params);
        if (!$result) {
            return false;
        }

        $driver = $this->pdo->getAttribute(PDO::ATTR_DRIVER_NAME);

        // Determinar clave primaria de la tabla
        $pkColumn = $this->findPrimaryKeyColumn($table, $driver);
        if (!$pkColumn) {
            return true; // No se puede auditar sin PK
        }

        if ($params) {
            foreach ($params as $k => $v) {
                $this->boundParams[$k] = $v;
            }
        }

        $primaryKeyValue = $this->resolvePrimaryKeyValue($operation, $pkColumn, $driver);

        if ($primaryKeyValue === null) {
            return true; // No auditable
        }

        $stmt = $this->pdo->prepare("SELECT * FROM `$table` WHERE `$pkColumn` = :id");
        $stmt->execute(['id' => $primaryKeyValue]);
        $row = $stmt->fetch(\PDO::FETCH_ASSOC);

        if (!$row) {
            return true;
        }

        $this->context->addChange(new AuditChange(
            actionId: $this->context->getActionId(),
            targetType: ucfirst($table),
            targetId: (string) $primaryKeyValue,
            changeType: strtolower($operation),
            payload: $row
        ));

        return true;
    }

    private function extractTable(string $sql): ?string
    {
        if (preg_match('/^\s*(UPDATE|INSERT INTO|DELETE FROM)\s+`?([a-zA-Z0-9_]+)`?/i', $sql, $m)) {
            return $m[2];
        }
        return null;
    }

    private function resolvePrimaryKeyValue(string $operation, string $pkColumn, string $driver): mixed
    {
        if ($operation === 'INSERT') {
            return match ($driver) {
                'pgsql'     => $this->pdo->lastInsertId(), // o usar RETURNING en query real
                'mysql', 'mariadb', 'sqlite' => $this->pdo->lastInsertId(),
                'sqlsrv'    => $this->pdo->query("SELECT SCOPE_IDENTITY()")->fetchColumn(),
                default     => null,
            };
        }

        // Para UPDATE o DELETE, requerimos introspección adicional o bind manual
        // Podrías mejorar esto si capturas $params antes de execute()
        return $this->boundParams[$pkColumn] ?? null;
    }

    private function findPrimaryKeyColumn(string $table, string $driver): ?string
    {
        return match ($driver) {
            'mysql', 'mariadb' => $this->queryOne(
                "SELECT COLUMN_NAME
             FROM INFORMATION_SCHEMA.COLUMNS
             WHERE TABLE_SCHEMA = DATABASE()
               AND TABLE_NAME = :table
               AND COLUMN_KEY = 'PRI'
             LIMIT 1",
                ['table' => $table]
            ),
            'pgsql' => $this->queryOne(
                "SELECT a.attname
             FROM pg_index i
             JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey)
             WHERE i.indrelid = :table::regclass AND i.indisprimary
             LIMIT 1",
                ['table' => $table]
            ),
            'sqlsrv' => $this->queryOne(
                "SELECT c.COLUMN_NAME
             FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc
             JOIN INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE ccu ON tc.CONSTRAINT_NAME = ccu.CONSTRAINT_NAME
             JOIN INFORMATION_SCHEMA.COLUMNS c ON c.TABLE_NAME = tc.TABLE_NAME AND c.COLUMN_NAME = ccu.COLUMN_NAME
             WHERE tc.TABLE_NAME = :table AND tc.CONSTRAINT_TYPE = 'PRIMARY KEY'",
                ['table' => $table]
            ),
            'sqlite' => $this->findPrimaryKeyColumnSqlite($table),
            default => null
        };
    }

    private function findPrimaryKeyColumnSqlite(string $table): ?string
    {
        $stmt = $this->pdo->prepare("PRAGMA table_info($table)");
        $stmt->execute();
        $rows = $stmt->fetchAll(\PDO::FETCH_ASSOC);
        foreach ($rows as $row) {
            if (!empty($row['pk'])) {
                return $row['name'];
            }
        }
        return null;
    }

    private function queryOne(string $sql, array $params): ?string
    {
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute($params);
        return $stmt->fetchColumn() ?: null;
    }
}
