<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Audit;

use Override;
use PDO;
use DateTimeInterface;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Ramsey\Uuid\Uuid;
use Civi\Lughauth\Shared\Context;
use Civi\Lughauth\Shared\AppConfig;

/**
 * PSR-15 middleware that captures and persists audit trail data for HTTP requests.
 *
 * This middleware intercepts all modifying HTTP requests (POST, PUT, PATCH, DELETE)
 * and records the action along with any database changes that occurred during
 * request processing. It provides:
 *
 * - **Action logging**: Records request metadata (actor, IP, path, method).
 * - **Change tracking**: Persists entity-level changes collected by auditable statements.
 * - **Retention management**: Automatically exports and purges old audit records.
 *
 * The retention policy exports audit data to gzip-compressed JSON files before
 * deletion, ensuring compliance and forensic capabilities.
 *
 * @see AuditContext Where changes are accumulated during the request.
 * @see AuditablePdoStatement Captures database modifications automatically.
 */
class AuditMiddleware implements MiddlewareInterface
{
    /** @var int Number of weeks to retain audit records before export and deletion. */
    private readonly int $retentionWeeks;

    /** @var string Directory path for exported audit archives. */
    private readonly string $exportDir;

    /**
     * Creates the audit middleware with required dependencies.
     *
     * @param PDO          $pdo        Database connection for audit table operations.
     * @param AuditContext $context    Request-scoped context for collecting changes.
     * @param Context      $appContext Application context providing identity and connection info.
     * @param AppConfig    $config     Configuration for retention policy settings.
     */
    public function __construct(
        /** @var PDO Database connection for persisting audit records. */
        private readonly PDO $pdo,
        /** @var AuditContext Request-scoped change accumulator. */
        private readonly AuditContext $context,
        /** @var Context Application context with identity and connection data. */
        private readonly Context $appContext,
        AppConfig $config
    ) {
        $this->retentionWeeks = intval($config->get('app.audit.retention-weeks', 0));
        $this->exportDir = __DIR__ . '/../../../../var/audit';
        $this->clear();
    }

    /**
     * Processes the request and records audit trail data for modifying operations.
     *
     * For POST, PUT, PATCH, and DELETE requests that complete successfully (status < 400),
     * this method persists an audit action record along with any entity changes
     * collected during request handling.
     *
     * @param Request                 $request The incoming HTTP request.
     * @param RequestHandlerInterface $handler The next handler in the middleware chain.
     *
     * @return ResponseInterface The response from the handler.
     */
    #[Override]
    public function process(Request $request, RequestHandlerInterface $handler): ResponseInterface
    {
        $method = strtoupper($request->getMethod());
        $auditable = in_array($method, ['POST', 'PUT', 'PATCH', 'DELETE'], true);

        $actionId = Uuid::uuid4()->toString();
        $this->context->setActionId($actionId);

        $response = $handler->handle($request);

        if (!$auditable || $response->getStatusCode() >= 400) {
            return $response;
        }


        $now = (new \DateTimeImmutable())->format('Y-m-d H:i:s');
        $stmt = $this->pdo->prepare(
            'INSERT INTO _audit_action (
                id, occurred_at, actor_id, actor_type, actor_ip,
                tenant_id, session_id, client_id, user_agent,
                request_method, request_path, action_type
            ) VALUES (
                :id, :occurred_at, :actor_id, :actor_type, :actor_ip,
                :tenant_id, :session_id, :client_id, :user_agent,
                :method, :path, :action_type
            )'
        );

        $identity = $this->appContext->getIdentity();
        $connection = $this->appContext->getConnection();

        $stmt->execute([
            'id' => $actionId,
            'actor_id' => $identity->anonimous ? 'anonimous' : $identity->name,
            'actor_type' => 'user',
            'actor_ip' => $connection->source,
            'tenant_id' => $identity->tenant,
            'session_id' => $identity->token !== null ? substr($identity->token, 0, 100) : '',
            'client_id' => $connection->application,
            'user_agent' => $request->getHeaderLine('User-Agent'),
            'method' => $method,
            'path' => $request->getUri()->getPath(),
            'action_type' => $method . ' ' . $request->getUri()->getPath(),
            'occurred_at' => $now
        ]);

        $changes = $this->context->consumeChanges();

        if (!empty($changes)) {

            $stmt = $this->pdo->prepare("
                INSERT INTO _audit_change (id, action_id, target_type, target_id, change_type, change_order, payload, metadata)
                VALUES (:id, :action_id, :target_type, :target_id, :change_type, :change_order, :payload, :metadata)
            ");

            foreach ($changes as $i => $change) {
                $stmt->execute([
                    'id' => Uuid::uuid4()->toString(),
                    'action_id' => $change->actionId,
                    'target_type' => $change->targetType,
                    'target_id' => $change->targetId,
                    'change_type' => $change->changeType,
                    'change_order' => $i,
                    'payload' => json_encode($change->payload),
                    'metadata' => $change->metadata !== null ? json_encode($change->metadata) : null,
                ]);
            }
        }

        return $response;
    }

    /**
     * Checks for and processes audit records that have exceeded the retention period.
     *
     * Called during middleware construction to opportunistically clean up old
     * audit data without requiring a dedicated cron job.
     *
     * @return void
     */
    private function clear(): void
    {
        $now = new \DateTimeImmutable('now', new \DateTimeZone('UTC'));

        // Inicio de la semana actual (lunes 00:00)
        $weekStart = $now->modify(('Monday' === $now->format('l') ? 'this' : 'last') . ' Monday')->setTime(0, 0);
        $cutoff = $weekStart->modify("-{$this->retentionWeeks} weeks");

        $cutoffStr = $cutoff->format('Y-m-d H:i:s');
        // Comprobamos si hay algo que borrar
        $stmt = $this->pdo->prepare("SELECT COUNT(*) FROM _audit_action WHERE occurred_at < :cutoff");
        $stmt->execute(['cutoff' => $cutoffStr]);

        if ((int) $stmt->fetchColumn() === 0) {
            return; // Nada que hacer
        }

        $this->exportAndDeleteBefore($cutoff);
    }

    /**
     * Exports audit records older than the cutoff date and removes them from the database.
     *
     * Records are exported to a gzip-compressed JSON file organized by ISO week,
     * then deleted within a transaction to ensure data integrity.
     *
     * @param DateTimeInterface $cutoff Records older than this date will be exported and deleted.
     *
     * @return void
     */
    private function exportAndDeleteBefore(DateTimeInterface $cutoff): void
    {
        $cutoffStr = $cutoff->format('Y-m-d H:i:s');
        $stmt = $this->pdo->prepare("
            SELECT aa.*, ac.*
            FROM _audit_action aa
            LEFT JOIN _audit_change ac ON ac.action_id = aa.id
            WHERE aa.occurred_at < :cutoff
            ORDER BY aa.occurred_at ASC
        ");
        $stmt->execute(['cutoff' => $cutoffStr]);

        $data = $stmt->fetchAll(PDO::FETCH_ASSOC);

        if (empty($data)) {
            return;
        }

        // Guardar en archivo comprimido
        $filename = sprintf('%s/audit-%s.json.gz', rtrim($this->exportDir, '/'), $cutoff->format('o-W'));
        @mkdir(dirname($filename), recursive: true);
        $gz = gzopen($filename, 'w9');
        if ($gz !== false) {
            $json = json_encode($data, JSON_PRETTY_PRINT);
            if ($json !== false) {
                gzwrite($gz, $json);
            }
            gzclose($gz);
        }

        // Borrar registros
        $this->pdo->beginTransaction();

        $this->pdo->exec("
            DELETE FROM _audit_change
            WHERE action_id IN (
                SELECT id FROM _audit_action WHERE occurred_at < '{$cutoffStr}'
            )
        ");
        $this->pdo->exec("
            DELETE FROM _audit_action WHERE occurred_at < '{$cutoffStr}'
        ");

        $this->pdo->commit();
    }
}
