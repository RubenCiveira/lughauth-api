<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure;

use PDO;
use Exception;
use DateInterval;
use DI\ContainerBuilder;
use Slim\App;
use Slim\Factory\AppFactory;
use Slim\Middleware\ErrorMiddleware;
use Psr\Container\ContainerInterface;
use Psr\EventDispatcher\EventDispatcherInterface;
use Psr\Http\Message\RequestFactoryInterface;
use Psr\Http\Message\StreamFactoryInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Log\LoggerInterface;
use Psr\SimpleCache\CacheInterface;
use Psr\Http\Client\ClientInterface;
use GuzzleHttp\Client;
use Monolog\Logger;
use Monolog\Formatter\JsonFormatter;
use Nimbly\Capsule\Factory\RequestFactory;
use Nimbly\Capsule\Factory\StreamFactory;
use Prometheus\CollectorRegistry;
use Prometheus\Storage\PDO as StoragePDO;
use Prometheus\Storage\Redis as StorageRedis;
use OpenTelemetry\API\Trace\TracerInterface;
use OpenTelemetry\SDK\Trace\TracerProvider;
use OpenTelemetry\SDK\Trace\SpanProcessor\SimpleSpanProcessor;
use OpenTelemetry\Contrib\Otlp\SpanExporter;
use OpenTelemetry\SDK\Common\Export\Http\PsrTransportFactory;
use OpenTelemetry\SDK\Trace\SpanExporterInterface;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Context;
use Civi\Lughauth\Shared\Event\EventListenersRegistrarInterface;
use Civi\Lughauth\Shared\Infrastructure\Audit\AuditablePdoWrapper;
use Civi\Lughauth\Shared\Infrastructure\Audit\AuditContext;
use Civi\Lughauth\Shared\Infrastructure\Audit\AuditMiddleware;
use Civi\Lughauth\Shared\Infrastructure\Audit\AuditQueryService;
use Civi\Lughauth\Shared\Infrastructure\Middelware\JwtVerifierMiddleware;
use Civi\Lughauth\Shared\Infrastructure\Middelware\CorsMiddleware;
use Civi\Lughauth\Shared\Infrastructure\Event\EventBus;
use Civi\Lughauth\Shared\Infrastructure\Log\MonologGzipRotatingFileHandler;
use Civi\Lughauth\Shared\Infrastructure\Log\SpanJsonGzipRotatingFileExporter;
use Civi\Lughauth\Shared\Infrastructure\Log\TraceContextProcessor;
use Civi\Lughauth\Shared\Infrastructure\MicroPlugin\ErrorsPlugin;
use Civi\Lughauth\Shared\Infrastructure\MicroPlugin\GenericSecurityPlugin;
use Civi\Lughauth\Shared\Infrastructure\MicroPlugin\ManagementPlugin;
use Civi\Lughauth\Shared\Infrastructure\Middelware\AccessControlMiddleware;
use Civi\Lughauth\Shared\Infrastructure\Middelware\HttpCompressionMiddleware;
use Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\FixedIntervalWindowPolicy;
use Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\MetricsFS;
use Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics\TimeWindowPolicy;
use Civi\Lughauth\Shared\Infrastructure\Middelware\PrometheusMetricMiddleware;
use Civi\Lughauth\Shared\Infrastructure\Middelware\Rate\PdoRateLimiterStorage;
use Civi\Lughauth\Shared\Infrastructure\Middelware\RateLimitMiddleware;
use Civi\Lughauth\Shared\Infrastructure\Middelware\TelemetrySpanMiddleware;
use Civi\Lughauth\Shared\Infrastructure\Scheduler\SchedulerManager;
use Civi\Lughauth\Shared\Infrastructure\Scheduler\Supervisor;
use DI\Container;
use OpenTelemetry\Context\ContextInterface;
use OpenTelemetry\SDK\Common\Attribute\Attributes;
use OpenTelemetry\SDK\Resource\ResourceInfo;
use OpenTelemetry\SDK\Trace\ReadWriteSpanInterface;
use OpenTelemetry\SDK\Trace\TracerProviderBuilder;
use Override;
use Symfony\Component\Cache\Adapter\FilesystemAdapter;
use Symfony\Component\Cache\Adapter\RedisAdapter;
use Symfony\Component\Cache\Psr16Cache;
use Symfony\Component\Lock\LockFactory;
use Symfony\Component\Lock\Store\FlockStore;
use Symfony\Component\Lock\Store\RedisStore;
use Symfony\Component\RateLimiter\Storage\CacheStorage;
use Symfony\Component\RateLimiter\Storage\StorageInterface;

class Micro
{
    public readonly App $app;
    public readonly EventBus $bus;
    public readonly AppConfig $config;
    public readonly MicroConfig $definition;
    public readonly ContainerInterface $container;
    public readonly ErrorMiddleware $errorHandler;
    private array $interfaces = [];

    private array $plugins = [];

    public function __construct(private readonly ContainerBuilder $depenencies, private readonly ?MicroConfig $def = null)
    {
    }
    private function build(): void
    {
        $depenencies = $this->depenencies;
        $def = $this->def;
        if (!$def) {
            $def = new MicroConfig();
        }
        $this->definition = $def;
        $this->config = new AppConfig();
        if (file_exists(__DIR__.'/../../../var/cache/di-definitions.php')) {
            $defs = require __DIR__.'/../../../var/cache/di-definitions.php';
        } else {
            $defs = [];
        }
        $defs[AppConfig::class] = $this->config;
        $defs[MicroConfig::class] = $this->definition;
        if ($this->definition->withAudit) {
            $this->withAudit($defs);
        }
        $this->withContainer($defs, $depenencies);
        $this->withCache($defs);
        $this->withLock($defs);
        $this->withLogging($defs);
        $this->withDatabase($defs);
        $this->withHttpClient($defs);
        $this->withEventBus($defs);
        if ($this->definition->withTelemetry) {
            $this->withTelementry($defs);
        }
        if ($this->definition->withMetrics) {
            $this->withMetrics($defs);
        }
        if ($this->definition->withRate) {
            $this->withRate($defs);
        }
        foreach ($this->plugins as $base) {
            $temp = $base->registerServiceDefinition($defs);
            $defs = [...$defs, ...$temp];
        }
        $depenencies->addDefinitions($defs);
        $depenencies->useAutowiring(true);
        $depenencies->useAttributes(true);
        $container = $depenencies->build();

        AppFactory::setContainer($container);
        $this->app = AppFactory::create();
        $container->set(App::class, $this->app);
        $this->container = $container;

        // Opcional: definir base path si tu app no está en "/"
        $scriptName = $_SERVER['SCRIPT_NAME']; // Devuelve algo como "/midashboard/index.php"
        $basePath = str_replace('/index.php', '', $scriptName); // "/midashboard"
        $this->app->setBasePath($basePath);

        // Middleware para parsear json
        $this->app->addBodyParsingMiddleware();

        $this->app->add(AccessControlMiddleware::class);
        $this->app->add(JwtVerifierMiddleware::class);
        $this->app->add(HttpCompressionMiddleware::class);
        if ($this->definition->withTelemetry) {
            $this->app->add(TelemetrySpanMiddleware::class);
        }
        if ($this->definition->withRate) {
            $this->app->add(RateLimitMiddleware::class);
        }
        if ($this->definition->withMetrics) {
            $this->app->add(PrometheusMetricMiddleware::class);
        }
        if ($this->definition->withAudit) {
            $this->app->add(AuditMiddleware::class);
        }

        $logger = null;
        if ($this->container->has(LoggerInterface::class)) {
            $logger = $this->container->get(LoggerInterface::class);
        }
        $this->app->addRoutingMiddleware();
        CorsMiddleware::register($this->app);
        $this->errorHandler = $this->app->addErrorMiddleware($this->config->develop, null !== $logger, $this->config->develop, $logger);
        $this->errorHandler->setErrorHandler(Exception::class, function (ServerRequestInterface $request, Exception $exception): ResponseInterface {
            echo $exception->getTraceAsString();
            die();
        });
        $container->set(ErrorMiddleware::class, $this->errorHandler);
        $this->interfaces = [];
        $this->register(new ErrorsPlugin());
        $this->register(new ManagementPlugin());
        $this->register(new GenericSecurityPlugin());

        foreach ($this->plugins as $base) {
            $base->bindServices($container);
            $managers = $base->getManagementsInterfaces($this->container);
            foreach ($managers as $manager) {
                $this->interfaces[] = $manager;
            }
        }
    }

    public function run()
    {
        $this->build();
        $this->registerManagers($this->app, $this->container);
        $vardir = __DIR__.'/../../../var/';
        if (!is_dir($vardir)) {
            mkdir($vardir, 0777, true);
        }
        $lockFile = fopen($vardir.'startup.lock', 'c');
        $startUpFile = $vardir.'startup.flag';
        if (flock($lockFile, LOCK_EX | LOCK_NB)) {
            if (!file_exists($startUpFile)) {
                $logger = null;
                if ($this->container->has(LoggerInterface::class)) {
                    $logger = $this->container->get(LoggerInterface::class);
                }
                $processor = new StartupProcessor($logger);
                foreach ($this->plugins as $startup) {
                    $startup->registerStartup($processor);
                }
                $processor->run($this->container);


                file_put_contents($startUpFile, '1');
            }
            flock($lockFile, LOCK_UN);
        }
        fclose($lockFile);

        register_shutdown_function([$this, 'ensureBackgroundSupervisor']);

        if (isset($_ENV['CRON'])) {
            $logger = null;
            if ($this->container->has(LoggerInterface::class)) {
                $logger = $this->container->get(LoggerInterface::class);
            }
            $logger->info('Start scheduler manager');
            $manager = $this->container->get(SchedulerManager::class);
            $locker = $this->container->get(LockFactory::class);
            $cache = $this->container->get(CacheInterface::class);
            $manager->run($locker, $cache, $this->container);
            $logger->info('Scheduler manager ready');
        } else {
            $this->app->run();
        }
        if (function_exists('fastcgi_finish_request')) {
            fastcgi_finish_request();
        }
    }

    public function register(MicroPlugin $base)
    {
        $this->plugins[] = $base;
    }

    private function ensureBackgroundSupervisor()
    {
        $scheme = 'http';
        if (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off') {
            $scheme = 'https';
        }
        $url = $scheme . '://' . ($_SERVER['SERVER_NAME'] ?? 'localhost') . ':' . ($_SERVER['SERVER_PORT'] ?? 80)
                    . dirname($_SERVER['SCRIPT_NAME']) . '/cron';
        $supervisor = new Supervisor(__DIR__.'/../../../');
        $supervisor->ensureRunning($url);
    }

    private function withTelementry(&$def)
    {
        $def[SpanExporterInterface::class] = function (AppConfig $config) {
            $name = $config->name;
            $base = dirname(__DIR__) . "/../../var/trace";
            if (true) {
                if (!is_dir($base)) {
                    mkdir($base);
                }
                $exporter = new SpanJsonGzipRotatingFileExporter($base . '/' . $name . '-telemetry.json', 10);
            } else {
                $transport = (new PsrTransportFactory())->create(
                    endpoint: 'http://localhost:4318/v1/traces', // URL del OTLP endpoint
                    contentType: 'application/x-protobuf',        // Protobuf es el estándar OTLP
                    headers: []                                   // opcional: ['Authorization' => 'Bearer ...']
                );
                $exporter = new SpanExporter($transport);
            }
            return $exporter;
        };
        $def[TracerInterface::class] = function (SpanExporterInterface $exporter, AppConfig $config, Context $context): TracerInterface {
            $resource = ResourceInfo::create(Attributes::create([
                'service.name'        => 'phylax-logs',
                'service.namespace'   => 'backoffice',
                'service.version'     => '1.4.2',
                'service.instance.id' => php_uname('n') . '-' . getmypid(),
                'deployment.environment' => 'prod',
            ]));
            $processor = new InjectResourceAttrsProcessor($exporter, $context);
            $provider = new TracerProvider($processor);
            $provider = (new TracerProviderBuilder())
                ->setResource($resource)
                ->addSpanProcessor($processor)
                ->build();
            return $provider->getTracer($config->get('app.name', 'php-service') . '_' . $config->get('app.version', '1'));
        };
    }

    private function withRate(&$def)
    {
        $def[StorageInterface::class] = function (ContainerInterface $container, AppConfig $conf) {
            if ("redis" === $conf->get("app.state.vault.engine")) {
                return new CacheStorage(new RedisAdapter(new \Redis()));
            } else {
                return new PdoRateLimiterStorage($container->get(PDO::class));
            }
        };
    }

    private function withMetrics(&$def)
    {
        $def[MetricsFS::class] = function () {
            $base = dirname(__DIR__) . "/../../var/history-metrics";
            return new MetricsFS($base);
        };
        $def[TimeWindowPolicy::class] = function () {
            $base = dirname(__DIR__) . "/../../var/history-metrics/lock";
            return new FixedIntervalWindowPolicy($base);
        };
        $def[CollectorRegistry::class] = function (ContainerInterface $container, AppConfig $conf) {
            if ("redis" === $conf->get("app.state.vault.engine")) {
                $storage = new StorageRedis();
            } else {
                $storage = new StoragePDO($container->get(PDO::class), '_prometheus_');
            }
            return new CollectorRegistry($storage);
        };
    }

    private function withAudit(&$def)
    {
        $def[AuditContext::class] = \DI\autowire(AuditContext::class);
        $def[AuditMiddleware::class] = function (Container $container, Context $appContext, AppConfig $conf) {
            $pdo = $container->get('DIRECT_PDO');
            $context = $container->get(AuditContext::class);
            return new AuditMiddleware($pdo, $context, $appContext, $conf);
        };
        $def[AuditQueryService::class] = function (Container $container) {
            $pdo = $container->get('DIRECT_PDO');
            return new AuditQueryService($pdo);
        };
    }

    private function withContainer(&$def, $builder)
    {
        $def[ContainerBuilder::class] = $builder;
    }

    private function withCache(&$def)
    {
        $def[CacheInterface::class] = function (AppConfig $conf) {
            if ("redis" === $conf->get("app.state.vault.engine")) {
                $interval = new DateInterval($conf->get('app.cache.lifetime', 'PT2H'));
                $now = new \DateTimeImmutable();
                $future = $now->add($interval);
                $defaultLifetime = $future->getTimestamp() - $now->getTimestamp();
                return new Psr16Cache(new RedisAdapter(new \Redis(), $conf->get('app.cache.namespace', ''), $defaultLifetime));
            } else {
                $dir = dirname(__DIR__) . "/../../var/cache";
                if (!is_dir($dir)) {
                    mkdir($dir);
                }
                return new Psr16Cache(new FilesystemAdapter('', 0, $dir));
            }
        };
    }

    private function withDatabase(&$def)
    {
        if ($this->definition->withAudit) {
            $def['DIRECT_PDO'] = function (AppConfig $config) {
                return new PDO($config->get('database.url'), $config->get('database.username'), $config->get('database.password'), [
                    PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION
                ]);
            };
            $def[PDO::class] = function (Container $container, AppConfig $config) {
                $context = $container->get(AuditContext::class);
                return new AuditablePdoWrapper($context, $config->get('database.url'), $config->get('database.username'), $config->get('database.password'), [
                    PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION
                ]);
            };
        } else {
            $def[PDO::class] = function (AppConfig $config) {
                return new PDO($config->get('database.url'), $config->get('database.username'), $config->get('database.password'), [
                    PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION
                ]);
            };
        }
    }

    private function withLock(&$def)
    {
        $def[LockFactory::class] = function (AppConfig $conf) {
            if ("redis" === $conf->get("app.state.vault.engine")) {
                $store = new RedisStore(new \Redis());
            } else {
                $store = new FlockStore();
            }
            return new LockFactory($store);
        };
    }

    private function withLogging(&$def)
    {
        $def[LoggerInterface::class] = function (AppConfig $config, TraceContextProcessor $tracer) {
            $name = $config->name;
            $base = dirname(__DIR__) . "/../../var/log";
            if (!is_dir($base)) {
                mkdir($base);
            }
            $handler = new MonologGzipRotatingFileHandler($base . "/".$name.".jsonl", 10);
            $handler->setFormatter(new JsonFormatter(JsonFormatter::BATCH_MODE_NEWLINES));
            $logger = new Logger($name, [$handler]);
            $logger->pushProcessor($tracer);
            return $logger;
        };
    }

    private function withEventBus(&$def)
    {
        $def[EventDispatcherInterface::class] = function (EventBus $bus) {
            return $bus->dispacher;
        };
        $def[EventListenersRegistrarInterface::class] = function (EventBus $bus) {
            return $bus;
        };
    }

    private function withHttpClient(&$def)
    {
        $def[RequestFactoryInterface::class] = function () {
            return new RequestFactory();
        };
        $def[StreamFactoryInterface::class] = function () {
            return new StreamFactory();
        };
        $def[ClientInterface::class]  = function () {
            return new Client([
                'max_duration' => 10, // Establece un tiempo máximo para la solicitud
                'timeout' => 10.0,    // Timeout para la espera de respuesta del servidor
                'http_version' => '1.0', // Prueba especificar HTTP/1.1 explícitamente
            ]);
        };
    }

    private function registerManagers(App $app, ContainerInterface $container)
    {
        $appConfig = $container->get(AppConfig::class);
        $base = $appConfig->managementEndpoint;
        $interfaces = $this->interfaces;
        $app->get("{$base}", function ($request, ResponseInterface $response) use ($interfaces) {
            $value = [];
            foreach ($interfaces as $interface) {
                if ($interface->get()) {
                    $value[] = [
                        'url' => './' . $interface->name(),
                        'method' => 'GET'
                    ];
                }
                if ($interface->set()) {
                    $value[] = [
                        'url' => './' . $interface->name(),
                        'method' => 'POST'
                    ];
                }
            }
            $response->getBody()->write(json_encode($value));
            return $response->withHeader('Content-Type', 'application/json');
        });
        foreach ($this->interfaces as $interface) {
            $name = $interface->name();
            $get = $interface->get();
            if ($get) {
                $app->get("{$base}/{$name}", function ($request, ResponseInterface $response) use ($get) {
                    $value = $get($request, $response);
                    $contentType = $response->getHeader('Content-Type');
                    if ($value instanceof ResponseInterface) {
                        return $value;
                    } elseif (is_string($value)) {
                        $response->getBody()->write($value);
                        if (!$contentType) {
                            $contentType = str_starts_with($value, '<html') ? 'text/html' : 'text/plain';
                        }
                    } else {
                        if (!$contentType) {
                            $contentType = 'application/json';
                        }
                        $response->getBody()->write(json_encode($value));
                    }
                    return $response->withHeader('Content-Type', $contentType);
                });
            }
            $set = $interface->set();
            if ($set) {
                $app->post("{$base}/{$name}", function (ServerRequestInterface $request, ResponseInterface $response) use ($set) {
                    $data = $request->getParsedBody();
                    $value = $set($request, $data);
                    if (is_string($value)) {
                        $response->getBody()->write($value);
                        return $response->withHeader('Content-Type', 'text/plain');
                    } else {
                        $response->getBody()->write(json_encode($value));
                        return $response->withHeader('Content-Type', 'application/json');
                    }
                });
            }
        }
    }
}

final class InjectResourceAttrsProcessor extends SimpleSpanProcessor
{
    public function __construct(SpanExporterInterface $exporter, private readonly Context $context)
    {
        parent::__construct($exporter);
    }
    #[Override]
    public function onStart(ReadWriteSpanInterface $span, ContextInterface $context): void
    {
        $data = $this->context->getInstanceData();
        foreach ($data as $k => $v) {
            $span->setAttribute($k, $v);
        }
    }
}
