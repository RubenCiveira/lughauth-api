<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure;

use Slim\App;
use Slim\Psr7\Stream;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;

/**
 * Static file and template serving handler for the Slim application.
 *
 * TemplateMapper registers a catch-all route that serves static files
 * and Twig templates from the `templates/` directory. It implements:
 *
 * - **Static file serving**: Directly serves CSS, JS, images, etc. with
 *   appropriate MIME types, ETag caching, and optional gzip compression.
 * - **Template rendering**: Processes `.tpl` files through Twig.
 * - **SPA fallback**: Falls back to `index.html` or `index.tpl` for
 *   client-side routing support.
 * - **Security**: Prevents path traversal attacks via realpath validation.
 *
 * Caching headers are set for aggressive browser caching (1 year, immutable).
 * ETags are computed from file size and modification time for conditional requests.
 *
 * @see Micro::run() Registers this mapper when not in CRON mode.
 */
class TemplateMapper
{
    /**
     * Registers the catch-all static/template route with the Slim application.
     *
     * This method adds a `GET /{path:.*}` route that handles all unmatched
     * requests by attempting to serve files from the templates directory.
     *
     * @param App $app The Slim application instance.
     *
     * @return void
     */
    public static function register(App $app): void
    {
        $app->get('/{path:.*}', function (ServerRequestInterface $request, ResponseInterface $response, array $args) use ($app) {
            $path = $args['path'] ?? '';

            // Normalizar: si vienen "/" o cadena vacía, tratamos como raíz
            if ($path === '' || $path === '/') {
                $path = 'index.html'; // o simplemente '' y que dispare el fallback abajo
            }

            $templateDir = realpath(__DIR__ . '/../../../templates');

            // Construimos la ruta solicitada
            $requestedPath = $templateDir . '/' . ltrim($path, '/');

            // Seguridad: evitar path traversal ("../")
            $requestedReal = realpath($requestedPath);
            if ($requestedReal === false || strncmp($requestedReal, $templateDir, strlen($templateDir)) !== 0) {
                $requestedReal = null;
            }

            $fallbackTpl  = $templateDir . '/index.tpl';
            $fallbackHtml = $templateDir . '/index.html';

            if ($requestedReal && is_file($requestedReal)) {
                // ---------------------------------------------
                // 1) Si existe el fichero solicitado
                // ---------------------------------------------
                $ext = pathinfo($requestedReal, PATHINFO_EXTENSION);
                return ($ext === 'tpl')
                        ? self::asTemplate($requestedReal, $templateDir, $app, $response)
                        : self::asStatic($requestedReal, $request, $response);
            } elseif (is_file($fallbackTpl)) {
                // ---------------------------------------------
                // 2) Fallback a index.tpl
                // ---------------------------------------------
                return self::asTemplate($fallbackTpl, $templateDir, $app, $response);
            } elseif (is_file($fallbackHtml)) {
                // ---------------------------------------------
                // 3) Fallback index.html
                // ---------------------------------------------
                return self::asStatic($fallbackHtml, $request, $response);
            } else {
                // ---------------------------------------------
                // 4) Nada encontrado: 404
                // ---------------------------------------------
                $response->getBody()->write('Not Found');
                return $response->withStatus(404);
            }
        });
    }

    /**
     * Serves a static file with caching headers and optional gzip compression.
     *
     * Implements HTTP caching with ETag and Last-Modified headers. Returns
     * 304 Not Modified when the client's cached version is still valid.
     * Compresses response with gzip if the client supports it.
     *
     * @param string                 $requestedReal The absolute path to the file.
     * @param ServerRequestInterface $request       The incoming HTTP request.
     * @param ResponseInterface      $response      The response to populate.
     *
     * @return ResponseInterface The response with file content or 304 status.
     */
    private static function asStatic(string $requestedReal, ServerRequestInterface $request, ResponseInterface $response): ResponseInterface
    {
        $mimeType = mime_content_type($requestedReal) ?: 'application/octet-stream';
        if (str_ends_with($requestedReal, '.html')) {
            $mimeType = 'text/html; charset=utf-8';
        }

        $lastModifiedTime = filemtime($requestedReal) ?: time();
        $lastModified = gmdate('D, d M Y H:i:s', $lastModifiedTime) . ' GMT';

        // ETag sencillo basado en tamaño + mtime
        $fileSize = filesize($requestedReal) ?: 0;
        $etag = sprintf('W/"%x-%x"', $fileSize, $lastModifiedTime);

        // Comprobamos If-None-Match para devolver 304 si procede
        $ifNoneMatch = $request->getHeaderLine('If-None-Match');
        if ($ifNoneMatch !== '' && trim($ifNoneMatch) === $etag) {
            return $response
                ->withStatus(304)
                ->withHeader('ETag', $etag)
                ->withHeader('Cache-Control', 'public, max-age=31536000, immutable')
                ->withHeader('Last-Modified', $lastModified);
        }
        // ¿El cliente soporta gzip?
        $acceptEncoding = $request->getHeaderLine('Accept-Encoding');
        $supportsGzip = stripos($acceptEncoding, 'gzip') !== false;

        if ($supportsGzip) {
            // Leemos y comprimimos en memoria
            $contents = file_get_contents($requestedReal);
            if ($contents === false) {
                $response->getBody()->write('Error reading file');
                return $response->withStatus(500);
            }
            $gzipped = gzencode($contents, 6);
            $stream = fopen('php://temp', 'rb+');
            fwrite($stream, $gzipped);
            rewind($stream);

            $body = new Stream($stream);
            return $response
                ->withBody($body)
                ->withHeader('Content-Type', $mimeType)
                ->withHeader('Content-Encoding', 'gzip')
                ->withHeader('Content-Length', (string) strlen($gzipped))
                ->withHeader('Cache-Control', 'public, max-age=31536000, immutable')
                ->withHeader('Last-Modified', $lastModified)
                ->withHeader('ETag', $etag);
        }
        // Sin gzip: servimos el fichero tal cual como stream
        $stream = new Stream(fopen($requestedReal, 'rb'));
        return $response
            ->withBody($stream)
            ->withHeader('Content-Type', $mimeType)
            ->withHeader('Cache-Control', 'public, max-age=31536000, immutable')
            ->withHeader('Last-Modified', $lastModified)
            ->withHeader('ETag', $etag);
    }

    /**
     * Renders a Twig template and returns the HTML response.
     *
     * Retrieves the Twig environment from the container and renders
     * the specified template file. The template path is computed
     * relative to the templates directory.
     *
     * @param string            $requestedReal The absolute path to the template file.
     * @param string            $templateDir   The base templates directory path.
     * @param App               $app           The Slim application (for container access).
     * @param ResponseInterface $response      The response to populate.
     *
     * @return ResponseInterface The response with rendered HTML content.
     */
    private static function asTemplate(string $requestedReal, string $templateDir, App $app, ResponseInterface $response): ResponseInterface
    {
        $container = $app->getContainer();
        /** @var \Twig\Environment $twig */
        $twig = $container->get('view'); // ajusta según tu config

        $templateName = substr($requestedReal, strlen($templateDir) + 1); // p.ej. "foo/page.tpl"

        $html = $twig->render($templateName, [
            // pasar variables si quieres
        ]);

        $response->getBody()->write($html);
        return $response
            ->withHeader('Content-Type', 'text/html; charset=utf-8');
    }
}
