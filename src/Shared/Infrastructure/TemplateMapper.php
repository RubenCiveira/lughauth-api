<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure;

use Slim\App;
use Slim\Psr7\Stream;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;

class TemplateMapper
{
    public static function register(App $app)
    {
        $app->get('/{path:.*}', function (ServerRequestInterface $request, ResponseInterface $response, array $args) use ($app) {
            $path = $args['path'] ?? '';

            // Normalizar: si vienen "/" o cadena vacía, tratamos como raíz
            if ($path === '' || $path === '/') {
                $path = 'index.html'; // o simplemente '' y que dispare el fallback abajo
            }

            $templateDir = realpath(__DIR__ . '/../../../templates');

            // Construimos la ruta solicitada
            $requestedPath = $templateDir . '/' . ltrim($path, '/');

            // Seguridad: evitar path traversal ("../")
            $requestedReal = realpath($requestedPath);
            if ($requestedReal === false || strncmp($requestedReal, $templateDir, strlen($templateDir)) !== 0) {
                $requestedReal = null;
            }

            $fallbackTpl  = $templateDir . '/index.tpl';
            $fallbackHtml = $templateDir . '/index.html';

            if ($requestedReal && is_file($requestedReal)) {
                // ---------------------------------------------
                // 1) Si existe el fichero solicitado
                // ---------------------------------------------
                $ext = pathinfo($requestedReal, PATHINFO_EXTENSION);
                return ($ext === 'tpl')
                        ? self::asTemplate($requestedReal, $templateDir, $app, $response)
                        : self::asStatic($requestedReal, $request, $response);
            } elseif (is_file($fallbackTpl)) {
                // ---------------------------------------------
                // 2) Fallback a index.tpl
                // ---------------------------------------------
                return self::asTemplate($fallbackTpl, $templateDir, $app, $response);
            } elseif (is_file($fallbackHtml)) {
                // ---------------------------------------------
                // 3) Fallback index.html
                // ---------------------------------------------
                return self::asStatic($fallbackHtml, $request, $response);
            } else {
                // ---------------------------------------------
                // 4) Nada encontrado: 404
                // ---------------------------------------------
                $response->getBody()->write('Not Found');
                return $response->withStatus(404);
            }
        });
    }

    private static function asStatic(string $requestedReal, ServerRequestInterface $request, ResponseInterface $response): ResponseInterface
    {
        $mimeType = mime_content_type($requestedReal) ?: 'application/octet-stream';
        if (str_ends_with($requestedReal, '.html')) {
            $mimeType = 'text/html; charset=utf-8';
        }

        $lastModifiedTime = filemtime($requestedReal) ?: time();
        $lastModified = gmdate('D, d M Y H:i:s', $lastModifiedTime) . ' GMT';

        // ETag sencillo basado en tamaño + mtime
        $fileSize = filesize($requestedReal) ?: 0;
        $etag = sprintf('W/"%x-%x"', $fileSize, $lastModifiedTime);

        // Comprobamos If-None-Match para devolver 304 si procede
        $ifNoneMatch = $request->getHeaderLine('If-None-Match');
        if ($ifNoneMatch !== '' && trim($ifNoneMatch) === $etag) {
            return $response
                ->withStatus(304)
                ->withHeader('ETag', $etag)
                ->withHeader('Cache-Control', 'public, max-age=31536000, immutable')
                ->withHeader('Last-Modified', $lastModified);
        }
        // ¿El cliente soporta gzip?
        $acceptEncoding = $request->getHeaderLine('Accept-Encoding');
        $supportsGzip = stripos($acceptEncoding, 'gzip') !== false;

        if ($supportsGzip) {
            // Leemos y comprimimos en memoria
            $contents = file_get_contents($requestedReal);
            if ($contents === false) {
                $response->getBody()->write('Error reading file');
                return $response->withStatus(500);
            }
            $gzipped = gzencode($contents, 6);
            $stream = fopen('php://temp', 'rb+');
            fwrite($stream, $gzipped);
            rewind($stream);

            $body = new Stream($stream);
            return $response
                ->withBody($body)
                ->withHeader('Content-Type', $mimeType)
                ->withHeader('Content-Encoding', 'gzip')
                ->withHeader('Content-Length', (string) strlen($gzipped))
                ->withHeader('Cache-Control', 'public, max-age=31536000, immutable')
                ->withHeader('Last-Modified', $lastModified)
                ->withHeader('ETag', $etag);
        }
        // Sin gzip: servimos el fichero tal cual como stream
        $stream = new Stream(fopen($requestedReal, 'rb'));
        return $response
            ->withBody($stream)
            ->withHeader('Content-Type', $mimeType)
            ->withHeader('Cache-Control', 'public, max-age=31536000, immutable')
            ->withHeader('Last-Modified', $lastModified)
            ->withHeader('ETag', $etag);
    }

    private static function asTemplate(string $requestedReal, string $templateDir, App $app, ResponseInterface $response): ResponseInterface
    {
        $container = $app->getContainer();
        /** @var \Twig\Environment $twig */
        $twig = $container->get('view'); // ajusta según tu config

        $templateName = substr($requestedReal, strlen($templateDir) + 1); // p.ej. "foo/page.tpl"

        $html = $twig->render($templateName, [
            // pasar variables si quieres
        ]);

        $response->getBody()->write($html);
        return $response
            ->withHeader('Content-Type', 'text/html; charset=utf-8');
    }
}
