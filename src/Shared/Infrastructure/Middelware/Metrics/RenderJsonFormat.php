<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics;

use Override;
use Prometheus\RendererInterface;

final class RenderJsonFormat implements RendererInterface
{
    /**
     * @param array{
     *   include?: list<string>,        // regex sobre *nombre de familia* (no el sample)
     *   exclude?: list<string>,        // regex a excluir
     *   label_allow?: list<string>,    // etiquetas que quieres conservar (si vacío: todas)
     *   ts_ms?: int,                   // timestamp ms para todas las muestras (default: now)
     *   preserve_zero_fraction?: bool  // true -> 0.0 no se convierte a 0
     * } $opts
     */
    #[Override]
    public function render(array $families): string
    {
        $tsMs   = isset($opts['ts_ms']) ? (int)$opts['ts_ms'] : (int)floor(microtime(true) * 1000);
        // $inc    = $this->compile($opts['include'] ?? []);
        // $exc    = $this->compile($opts['exclude'] ?? []);
        $allow  = $opts['label_allow'] ?? [];         // lista (si vacío -> no filtra)
        $flags  = JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE;
        if (!empty($opts['preserve_zero_fraction'])) {
            $flags |= JSON_PRESERVE_ZERO_FRACTION;
        }

        $rows = [];

        foreach ($families as $fam) {
            // Compat getters/props
            $familyName = \method_exists($fam, 'getName') ? $fam->getName() : ($fam->name ?? '');
            $familyHelp = \method_exists($fam, 'getHelp') ? $fam->getHelp() : ($fam->help ?? '');
            $familyType = \method_exists($fam, 'getType') ? $fam->getType() : ($fam->type ?? 'gauge');
            $samples    = \method_exists($fam, 'getSamples') ? $fam->getSamples() : ($fam->samples ?? []);

            // if (!$this->match($familyName, $inc, $exc)) {
            //     continue;
            // }

            foreach ($samples as $s) {
                // Normaliza sample (objeto o array)
                if (\is_object($s)) {
                    $sName    = \method_exists($s,'getName')        ? $s->getName()        : ($s->name ?? '');
                    $names    = \method_exists($s,'getLabelNames')  ? $s->getLabelNames()  : ($s->labelNames ?? []);
                    $values   = \method_exists($s,'getLabelValues') ? $s->getLabelValues() : ($s->labelValues ?? []);
                    $valueRaw = \method_exists($s,'getValue')       ? $s->getValue()       : ($s->value ?? 0);
                } else {
                    /** @var array{name:string,labelNames:array,labelValues:array,value:mixed} $s */
                    $sName    = $s['name']        ?? '';
                    $names    = $s['labelNames']  ?? [];
                    $values   = $s['labelValues'] ?? [];
                    $valueRaw = $s['value']       ?? 0;
                }

                // 1) Emparejo por índice (tal como define prom-php)
                $pair = [];
                $len  = \min(\count($names), \count($values));
                for ($i = 0; $i < $len; $i++) {
                    $pair[(string)$names[$i]] = (string)$values[$i];
                }

                // 2) Fix para histogram buckets con arrays desalineados
                $isBucket = ($familyType === 'histogram') && \str_ends_with($sName, '_bucket');
                if ($isBucket) {
                    $pair = $this->fixBucketLabels($pair, $names, $values);
                }

                // 3) Aplica whitelist (si se pide)
                if (!empty($allow)) {
                    $pair = \array_filter(
                        $pair,
                        fn($_, $k) => \in_array($k, $allow, true),
                        \ARRAY_FILTER_USE_BOTH
                    );
                }

                \ksort($pair, \SORT_STRING);

                // 4) Valor numérico sin truncar
                $value = \is_numeric($valueRaw) ? (float)$valueRaw : $valueRaw;

                $rows[] = [
                    'ts'     => $tsMs,
                    'family' => $familyName,    // opcional, útil para agrupar
                    'metric' => $sName,         // incluye _bucket/_sum/_count
                    'type'   => (string)$familyType,
                    'help'   => $familyHelp,
                    'labels' => $pair,
                    'value'  => $value,
                ];
            }
        }

        return json_encode($rows, $flags);
    }

    /** Alinea correctamente 'le' y una etiqueta de ruta (script/route/path/uri/endpoint) si vienen cruzadas. */
    private function fixBucketLabels(array $pair, array $names, array $values): array
    {
        $looksPath = fn($v) => \is_string($v) && $v !== '' && $v[0] === '/';
        $isLeOk    = fn($v) => $v === '+Inf' || \is_numeric($v);

        // Caso reportado: names=['le'], values=['/api/...','0.03'] → reconstruir
        // Si 'le' parece ruta y hay un valor numérico/+Inf, intercambiamos.
        if (isset($pair['le']) && $looksPath($pair['le'])) {
            $candidateLe = null;
            foreach ($values as $v) {
                if ($isLeOk($v)) { $candidateLe = (string)$v; break; }
            }
            if ($candidateLe !== null) {
                $routeVal = $pair['le'];
                $pair['le'] = $candidateLe;

                // Si ya hay 'script' con una ruta, mantenlo; si no, crea 'script'
                $hasScriptRoute = isset($pair['script']) && $looksPath($pair['script']);
                if (!$hasScriptRoute) {
                    // intenta usar alguna de las convencionales si existiera
                    foreach (['route','path','uri','endpoint'] as $rk) {
                        if (isset($pair[$rk]) && $looksPath($pair[$rk])) {
                            $pair['script'] = $pair[$rk];
                            $routeVal = null; // ya tenemos una
                            break;
                        }
                    }
                    if ($routeVal !== null) {
                        $pair['script'] = $routeVal;
                    }
                }
            }
        }

        // Si falta 'le', intenta recuperarlo de values
        if (!isset($pair['le'])) {
            foreach ($values as $v) {
                if ($isLeOk($v)) { $pair['le'] = (string)$v; break; }
            }
        }

        // Si falta 'script', intenta derivarlo de otras etiquetas o de cualquier ruta presente
        if (!isset($pair['script'])) {
            foreach (['route','path','uri','endpoint'] as $rk) {
                if (isset($pair[$rk]) && $looksPath($pair[$rk])) {
                    $pair['script'] = $pair[$rk];
                    break;
                }
            }
            if (!isset($pair['script'])) {
                foreach ($pair as $k => $v) {
                    if ($looksPath($v)) { $pair['script'] = $v; break; }
                }
            }
        }

        return $pair;
    }

    /** @param list<string> $pats */
    private function compile(array $pats): array
    {
        return \array_map(
            fn(string $p) => \str_starts_with($p, '/') ? $p : '/'.\str_replace('/', '\/', $p).'/',
            $pats
        );
    }

    /** @param list<string> $inc @param list<string> $exc */
    private function match(string $name, array $inc, array $exc): bool
    {
        foreach ($exc as $re) { if (@\preg_match($re, $name) && \preg_match($re, $name)) return false; }
        if (!$inc) return true;
        foreach ($inc as $re) { if (@\preg_match($re, $name) && \preg_match($re, $name)) return true; }
        return false;
    }
}
