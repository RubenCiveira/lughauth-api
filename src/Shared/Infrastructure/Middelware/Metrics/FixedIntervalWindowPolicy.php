<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics;

use Override;

/**
 * Emits a trace signal once per fixed interval using a lock file.
 */
final class FixedIntervalWindowPolicy implements TimeWindowPolicy
{
    /**
     * Creates a new fixed interval window policy.
     */
    public function __construct(
        /** @var string Path to the lock file used to track intervals. */
        private readonly string $lockFile,
        /** @var int Interval length in seconds. */
        private readonly int $intervalSeconds = 900 /* 15m */
    ) {
    }

    /**
     * Determines whether the current interval should emit a trace.
     */
    #[Override]
    public function mustTrace(): bool
    {
        $lockFile = $this->lockFile ?? sys_get_temp_dir() . '/trace-window.lock';
        $interval = max(1, (int)($this->intervalSeconds ?? 900)); // 15m por defecto
        $now      = time();

        // Asegura dir
        $dir = dirname($lockFile);
        if (!is_dir($dir) && !@mkdir($dir, 0775, true) && !is_dir($dir)) {
            return false;
        }

        // Abre/crea sin truncar
        $h = @fopen($lockFile, 'c+'); // crea si no existe
        if (!$h) {
            return false;
        }

        try {
            if (!@flock($h, LOCK_EX)) {
                return false;
            }

            // Lee contenido actual
            $lastTs = 0;
            $stat = @fstat($h) ?: [];
            if (($stat['size'] ?? 0) > 0) {
                rewind($h);
                // lee hasta 64 bytes por si hubiera \n u otros
                $raw = stream_get_contents($h, 64) ?: '';
                $raw = trim($raw);
                if (ctype_digit($raw)) {
                    $lastTs = (int)$raw;
                }
            }

            // Si no hay timestamp válido, inicializa escribiendo now
            $invalid = ($lastTs <= 0) || ($lastTs > $now + 300); // futuro (>5 min) también es inválido
            $expired = !$invalid && (($now - $lastTs) >= $interval);

            if ($invalid || $expired) {
                // Escribe now como único contenido (no usamos filemtime)
                rewind($h);
                $data = (string)$now;
                $ok = (fwrite($h, $data) !== false);
                // elimina basura si antes era más grande
                ftruncate($h, strlen($data));
                fflush($h);
                return $ok; // true si se pudo escribir
            }

            return false; // ventana aún no expirada
        } finally {
            @flock($h, LOCK_UN);
            @fclose($h);
        }
    }
}
