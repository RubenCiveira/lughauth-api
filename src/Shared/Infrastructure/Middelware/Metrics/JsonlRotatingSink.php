<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics;

final class JsonlRotatingSink implements MetricsSink
{
    private const FILE_PREFIX = 'metrics-'; // metrics-YYYY-MM-DD.jsonl
    private const EXT        = '.jsonl';

    private string $currentFilename = '';
    /** @var resource|null */
    private $handle = null;
    private string $today = '';
    private int $appendCount = 0;

    public function __construct(
        private readonly string $dir,
        private readonly bool   $gzipOldDays = true,
        private readonly int    $ttlDays = 30,             // ðŸ‘ˆ retenciÃ³n
        private readonly bool   $enableOpportunisticDownsample = true, // ðŸ‘ˆ si quieres generar @5m/@1h
        private readonly int    $sheddingStepMs = 60_000,  // ðŸ‘ˆ 1m: colapsado por bucket si hay back-pressure
        private readonly int    $shedBatchThreshold = 10_000 // ðŸ‘ˆ si un batch supera esto, se â€œadelgazaâ€
    ) {
        if (!\is_dir($dir) && !@\mkdir($dir, 0775, true) && !\is_dir($dir)) {
            throw new \RuntimeException("Cannot create metrics dir: {$dir}");
        }
        $this->rollIfNeeded();
    }

    /** @param list<array<string,mixed>> $batch */
    public function appendBatch(array $batch): void
    {
        if ($batch === []) {
            return;
        }

        $this->rollIfNeeded();
        // Back-pressure 1: si el batch ya viene enorme, adelgaza antes de tocar disco
        if (\count($batch) >= $this->shedBatchThreshold) {
            $batch = $this->shedBatch($batch, $this->sheddingStepMs);
        }
        $h = $this->handle;
        if (!\is_resource($h)) {
            throw new \RuntimeException('Metrics sink handle not open');
        }
        // Intento de lock no bloqueante
        $locked = @\flock($h, \LOCK_EX | \LOCK_NB);
        if (!$locked) {
            // Back-pressure 2: el writer estÃ¡ ocupado â†’ adelgaza y luego bloquea normal
            $batch = $this->shedBatch($batch, $this->sheddingStepMs);
            $locked = @\flock($h, \LOCK_EX);
        }
        // Construye bloque JSONL en memoria
        $buf = '';
        foreach ($batch as $row) {
            $buf .= \json_encode($row, \JSON_UNESCAPED_SLASHES) . "\n";
        }
        try {
            @\fwrite($h, $buf);
        } finally {
            if ($locked) {
                @\flock($h, \LOCK_UN);
            }
        }
        @\fflush($h);
        // Mantenimiento oportunista cada N escrituras
        if ((++$this->appendCount % 50) === 0) {
            $this->enforceTtl(); // borra viejos (jsonl y gz)
            if ($this->enableOpportunisticDownsample) {
                $this->maybeDownsampleOlderDays();
            }
        }
    }

    private function rollIfNeeded(): void
    {
        $today = \gmdate('Y-m-d');
        if ($this->today === $today && \is_resource($this->handle)) {
            return;
        }

        if (\is_resource($this->handle)) {
            @\fclose($this->handle);
            $this->handle = null;
        }

        $this->today = $today;
        $this->currentFilename = $this->dir . '/' . self::FILE_PREFIX . $today . self::EXT;
        $this->handle = @\fopen($this->currentFilename, 'ab');
        if (!$this->handle) {
            throw new \RuntimeException("Cannot open metrics file: {$this->currentFilename}");
        }
        @\stream_set_write_buffer($this->handle, 256 * 1024);

        // Tras rotar, comprime y limpia (no en el hot path de cada append)
        if ($this->gzipOldDays) {
            $this->gzipOlderFilesExcept($today);
        }
        $this->enforceTtl();
        if ($this->enableOpportunisticDownsample) {
            $this->maybeDownsampleOlderDays();
        }
    }

    /** Elimina ficheros > TTL dÃ­as (jsonl y .gz). */
    private function enforceTtl(): void
    {
        if ($this->ttlDays <= 0) {
            return;
        }
        $cut = (new \DateTimeImmutable('now', new \DateTimeZone('UTC')))->modify("-{$this->ttlDays} days");
        foreach (\glob($this->dir . '/' . self::FILE_PREFIX . '*.{jsonl,jsonl.gz}', \GLOB_BRACE) ?: [] as $file) {
            $d = $this->extractDayFromFilename($file);
            if (!$d) {
                continue;
            }
            if ($d < $cut->format('Y-m-d')) {
                @\unlink($file);
            }
        }
    }

    /** Comprime a .gz todos los dÃ­as distintos del actual que no lo estÃ©n ya */
    private function gzipOlderFilesExcept(string $keepDay): void
    {
        $pattern = $this->dir . '/' . self::FILE_PREFIX . '*.jsonl';
        foreach (\glob($pattern) ?: [] as $file) {
            if (!\is_file($file)) {
                continue;
            }
            if (\str_contains($file, $keepDay)) {
                continue;
            }
            $gz = $file . '.gz';
            if (\file_exists($gz)) {
                continue;
            }

            $in = @\fopen($file, 'rb');
            $out = @\gzopen($gz, 'wb9');
            if ($in && $out) {
                while (!\feof($in)) {
                    $chunk = \fread($in, 1_048_576);
                    if ($chunk === false) {
                        break;
                    }
                    \gzwrite($out, $chunk);
                }
                \gzclose($out);
                \fclose($in);
                @\unlink($file);
            } else {
                if ($out) {
                    \gzclose($out);
                }
                if ($in) {
                    \fclose($in);
                }
            }
        }
    }

    /** Downsample oportunista: >2 dÃ­as â†’ @5m, >14 dÃ­as â†’ @1h (y borra el original gz si el agregado se crea OK). */
    private function maybeDownsampleOlderDays(): void
    {
        $utc = new \DateTimeZone('UTC');
        $d2  = (new \DateTimeImmutable('now', $utc))->modify('-2 days')->format('Y-m-d');
        $d14 = (new \DateTimeImmutable('now', $utc))->modify('-14 days')->format('Y-m-d');

        foreach (\glob($this->dir . '/' . self::FILE_PREFIX . '*.jsonl.gz') ?: [] as $gz) {
            $day = $this->extractDayFromFilename($gz);
            if (!$day) {
                continue;
            }

            if ($day <= $d14) {
                $this->downsampleGzFile($gz, 3600); // 1h
            } elseif ($day <= $d2) {
                $this->downsampleGzFile($gz, 300);  // 5m
            }
        }
    }

    /** Lee un .jsonl.gz, bucketiza por step (s) y genera metrics-YYYY-MM-DD@{step}.jsonl.gz */
    private function downsampleGzFile(string $gzFile, int $stepSeconds): void
    {
        $suffix = '@' . ($stepSeconds >= 3600 ? '1h' : ($stepSeconds >= 300 ? '5m' : $stepSeconds . 's'));
        $out = \preg_replace('/\.jsonl\.gz$/', $suffix . '.jsonl.gz', $gzFile);
        if (!$out || \file_exists($out)) {
            return;
        } // ya existe agregado

        $in = @\gzopen($gzFile, 'rb');
        $tmp = $out . '.tmp';
        $ogz = @\gzopen($tmp, 'wb6');
        if (!$in || !$ogz) {
            if ($in) {
                \gzclose($in);
            } if ($ogz) {
                \gzclose($ogz);
            } return;
        }

        $buckets = []; // key(metric+labels+bucket) => ['value'=>..., 'type'=>...]
        $stepMs = $stepSeconds * 1000;

        while (!\gzeof($in)) {
            $line = \gzgets($in);
            if ($line === false) {
                break;
            }
            $row = \json_decode($line, true);
            if (!\is_array($row)) {
                continue;
            }

            $ts  = (int)($row['ts'] ?? 0);
            $typ = (string)($row['type'] ?? 'gauge');
            $met = (string)($row['metric'] ?? '');
            $lbl = $row['labels'] ?? [];
            \ksort($lbl, \SORT_STRING);
            $bucket = (int)\floor($ts / $stepMs) * $stepMs;
            $key = $met . '|' . \json_encode($lbl, \JSON_UNESCAPED_SLASHES) . '|' . $bucket;

            // Estrategia simple: gauge â†’ Ãºltima; counter â†’ mÃ¡ximo (monotÃ³nico)
            $val = $row['value'];
            if (!isset($buckets[$key])) {
                $buckets[$key] = ['ts' => $bucket, 'metric' => $met, 'type' => $typ, 'labels' => $lbl, 'value' => $val];
            } else {
                if ($typ === 'counter') {
                    $buckets[$key]['value'] = \max((float)$buckets[$key]['value'], (float)$val);
                } else {
                    $buckets[$key]['value'] = $val; // Ãºltima
                }
            }
        }
        \gzclose($in);

        // Escribe buckets ordenados por ts
        \usort($buckets, fn ($a, $b) => ($a['ts'] <=> $b['ts']) ?: \strcmp($a['metric'], $b['metric']));
        foreach ($buckets as $r) {
            \gzwrite($ogz, \json_encode($r, \JSON_UNESCAPED_SLASHES) . "\n");
        }
        \gzclose($ogz);

        // Renombra tmp â†’ final y borra original
        @\rename($tmp, $out);
        @\unlink($gzFile);
    }

    private function extractDayFromFilename(string $file): ?string
    {
        if (\preg_match('/metrics\-(\d{4}\-\d{2}\-\d{2})/', \basename($file), $m)) {
            return $m[1];
        }
        return null;
    }

    /**
     * Shedding: colapsa un batch a 1 muestra por (metric+labels) por bucket de stepMs.
     * - gauge â†’ Ãºltima del bucket
     * - counter â†’ mÃ¡ximo del bucket (respeta monotonicidad)
     * - histogram/summary: tal cual (no se colapsa aquÃ­; ajusta si lo necesitas)
     * @param list<array<string,mixed>> $batch
     * @return list<array<string,mixed>>
     */
    private function shedBatch(array $batch, int $stepMs): array
    {
        $out = [];
        $map = []; // key => index en $out
        foreach ($batch as $row) {
            $typ = (string)($row['type'] ?? 'gauge');
            if ($typ === 'histogram' || $typ === 'summary') { // no colapsamos aquÃ­
                $out[] = $row;
                continue;
            }
            $ts = (int)($row['ts'] ?? 0);
            $bucket = (int)\floor($ts / $stepMs) * $stepMs;
            $met = (string)$row['metric'];
            $lbl = $row['labels'] ?? [];
            \ksort($lbl, \SORT_STRING);
            $key = $met . '|' . \json_encode($lbl, \JSON_UNESCAPED_SLASHES) . '|' . $bucket;

            if (!isset($map[$key])) {
                $row['ts'] = $bucket;
                $map[$key] = \count($out);
                $out[] = $row;
            } else {
                $idx = $map[$key];
                if ($typ === 'counter') {
                    $out[$idx]['value'] = \max((float)$out[$idx]['value'], (float)$row['value']);
                } else { // gauge
                    $out[$idx] = $row; // nos quedamos con la Ãºltima
                    $out[$idx]['ts'] = $bucket;
                }
            }
        }
        return $out;
    }
}
