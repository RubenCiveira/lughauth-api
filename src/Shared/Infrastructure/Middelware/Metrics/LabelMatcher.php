<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics;

/**
 * Evaluates Prometheus-style label matchers against a label set.
 */
final class LabelMatcher
{
    /**
     * Creates a new label matcher.
     */
    public function __construct(
        /** @var string Label key to match. */
        public string $key,
        /** @var string Match operator ('=', '!=', '=~', '!~'). */
        public string $op,
        /** @var string Match value or regex. */
        public string $val
    ) {
    }

    /**
     * Determines whether the labels match the matcher.
     *
     * @param array<string, string> $labels Label set to evaluate.
     */
    public function matches(array $labels): bool
    {
        $has = array_key_exists($this->key, $labels);
        $lv  = $has ? (string)$labels[$this->key] : null;

        return match ($this->op) {
            '='  => $has && $lv === $this->val,
            '!=' => !$has || $lv !== $this->val,
            '=~' => $has && $this->regexMatch($lv, $this->val),
            '!~' => !$has || !$this->regexMatch($lv, $this->val),
            default => false,
        };
    }

    private function regexMatch(string $value, string $re2): bool
    {
        // PromQL (RE2) es "full match": ^(?:regex)$
        // Convertimos a PCRE y escapamos el delimitador elegido (~).
        $del = '~';
        $pattern = $del . '\A(?:' . str_replace($del, '\\' . $del, $re2) . ')\z' . $del . 'u';

        $ok = @preg_match($pattern, $value);
        if ($ok === false) {
            // patrÃ³n invÃ¡lido -> por seguridad, no coincide
            return false;
        }
        return $ok === 1;
    }
}
