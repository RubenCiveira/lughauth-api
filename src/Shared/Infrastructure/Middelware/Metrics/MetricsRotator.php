<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics;

/**
 * Rotates metrics files and prunes expired data.
 */
final class MetricsRotator
{
    /**
     * Creates a new metrics rotator.
     */
    public function __construct(
        /** @var string Root directory for metrics storage. */
        private string $root,
        /** @var array<string, int> TTL per partition in days. */
        private array $ttlDays = [
            'raw'        => 14,
            'rollup_5m'  => 60,
            'rollup_1h'  => 365,
        ],
        /** @var bool Whether to gzip rotated files. */
        private bool $gzipOnRotate = true,
        /** @var array<int, string> Partitions to skip gzip on. */
        private array $gzipSkipPartitions = [],
    ) {
        $this->root = rtrim($root, '/');
    }

    /**
     * Rotates all metrics under the root directory.
     */
    public function rotateAll(): void
    {
        foreach (glob($this->root.'/*', GLOB_ONLYDIR) ?: [] as $metricDir) {
            $this->rotateMetric(basename($metricDir));
        }
    }

    /**
     * Rotates a single metric directory.
     *
     * @param string $metric Metric name to rotate.
     */
    public function rotateMetric(string $metric): void
    {
        $metricDir = "{$this->root}/{$metric}";
        if (!is_dir($metricDir)) {
            return;
        }

        $lockFile = "{$metricDir}/.rotator.lock";
        $fh = @fopen($lockFile, 'c+');
        if (!$fh || !@flock($fh, LOCK_EX | LOCK_NB)) {
            if ($fh) {
                @fclose($fh);
            }
            return;
        }

        try {
            $this->processMetric($metricDir);
            $this->pruneEmptyDirs($metricDir);
        } finally {
            @flock($fh, LOCK_UN);
            @fclose($fh);
            // no borramos el lock; se reutiliza
        }
    }

    private function processMetric(string $metricDir): void
    {
        // Recorre todas las series
        foreach (glob($metricDir.'/series/*/*', GLOB_ONLYDIR) ?: [] as $seriesDir) {
            $this->processSeries($seriesDir);
        }
    }

    private function processSeries(string $seriesDir): void
    {
        foreach (array_keys($this->ttlDays) as $partition) {
            $partDir = "{$seriesDir}/{$partition}";
            if (!is_dir($partDir)) {
                continue;
            }

            // YYYY
            foreach (glob($partDir.'/*', GLOB_ONLYDIR) ?: [] as $yDir) {
                $y = basename($yDir);
                if (!ctype_digit($y) || strlen($y) !== 4) {
                    continue;
                }

                // MM
                foreach (glob($yDir.'/*', GLOB_ONLYDIR) ?: [] as $mDir) {
                    $m = basename($mDir);
                    if (!ctype_digit($m) || (int)$m < 1 || (int)$m > 12) {
                        continue;
                    }

                    // DD.jsonl(.gz)
                    foreach (glob($mDir.'/*.jsonl*') ?: [] as $dayFile) {
                        $this->maybeGzip($dayFile, $partition);
                        $this->maybeDelete($dayFile, $partition);
                    }
                }
            }
        }
    }

    private function maybeGzip(string $path, string $partition): void
    {
        if (!$this->gzipOnRotate) {
            return;
        }
        if (in_array($partition, $this->gzipSkipPartitions, true)) {
            return;
        }
        if (str_ends_with($path, '.gz')) {
            return;
        }

        // No comprimir “hoy”
        $info = $this->extractYmdFromPath($path);
        if (!$info) {
            return;
        }
        [$y, $m, $d] = $info;
        $today = (new \DateTimeImmutable('now', new \DateTimeZone('UTC')))->format('Y-m-d');
        if (sprintf('%04d-%02d-%02d', $y, $m, $d) === $today) {
            return;
        }

        // Comprimir
        $gz = $path.'.gz';
        $in = @fopen($path, 'rb');
        if (!$in) {
            return;
        }
        $out = @gzopen($gz, 'wb9');
        if (!$out) {
            @fclose($in);
            return;
        }

        try {
            while (!feof($in)) {
                $chunk = fread($in, 262144);
                if ($chunk === false) {
                    break;
                }
                gzwrite($out, $chunk);
            }
        } finally {
            @fclose($in);
            @gzclose($out);
        }
        // Si todo bien, borra el original
        @unlink($path);
    }

    private function maybeDelete(string $path, string $partition): void
    {
        $ttlDays = $this->ttlDays[$partition] ?? null;
        if (null === $ttlDays) {
            return;
        }
        $ymd = $this->extractYmdFromPath($path);
        if (null === $ymd) {
            return;
        }
        [$y, $m, $d] = $ymd;
        
        $fileDate = \DateTimeImmutable::createFromFormat('!Y-n-j', "{$y}-{$m}-{$d}", new \DateTimeZone('UTC'));

        $cutoff = (new \DateTimeImmutable('now', new \DateTimeZone('UTC')))->modify("-{$ttlDays} days")->setTime(0, 0);
        if ($fileDate < $cutoff) {
            @unlink($path);
        }
    }

    /** Sube limpiando directorios vacíos: …/DD.jsonl(.gz) → MM → YYYY → partition → series → shard→ … */
    private function pruneEmptyDirs(string $rootDir): void
    {
        $it = new \RecursiveIteratorIterator(
            new \RecursiveDirectoryIterator($rootDir, \FilesystemIterator::SKIP_DOTS),
            \RecursiveIteratorIterator::CHILD_FIRST
        );

        foreach ($it as $path => $info) {
            if ($info->isDir()) {
                // no toques el directorio de la métrica principal
                if ($path === $rootDir) {
                    continue;
                }
                @rmdir($path); // rmdir sólo borra si está vacío
            }
        }
    }

    /** Extrae [Y,M,D] desde …/<partition>/YYYY/MM/DD.jsonl(.gz) */
    private function extractYmdFromPath(string $path): ?array
    {
        // Busca /NNNN/NN/NN.jsonl[.gz]
        if (!preg_match('~/(20\d{2})/([01]\d)/([0-3]\d)\.jsonl(\.gz)?$~', str_replace('\\', '/', $path), $m)) {
            return null;
        }
        return [(int)$m[1], (int)$m[2], (int)$m[3]];
    }
}
