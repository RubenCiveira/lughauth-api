<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics;

/**
 * Layout:
 * /root/<metric>/series/<shard>/<sha>/
 *   labels.json
 *   raw/YYYY/MM/DD.jsonl(.gz)
 */
final class MetricsFS
{

    /** Normaliza etiquetas (ksort) */
    public static function canonicalLabels(array $labels): array
    {
        ksort($labels, SORT_STRING);
        return $labels;
    }

    /** Id estable de serie (sha1 sobre labels ordenadas, json estable) */
    public static function seriesId(array $labels): string
    {
        return sha1(json_encode(self::canonicalLabels($labels), JSON_UNESCAPED_SLASHES));
    }

    /** Shard (2 hex) para repartir directorios */
    private static function shard(string $sha): string
    {
        return substr($sha, 0, 2);
    }

    private readonly MetricsRotator $rotator;

    public function __construct(private string $root)
    {
        $this->root = rtrim($root, '/');
        $this->rotator = new MetricsRotator($root);
    }

    public function rotate()
    {
        $this->rotator->rotateAll();
    }

    public function metricDir(string $metric): string
    {
        return "{$this->root}/{$metric}";
    }

    public function seriesDir(string $metric, string $sha): string
    {
        return $this->metricDir($metric) . '/series/' . self::shard($sha) . '/' . $sha;
    }

    /** Fichero diario para partición (raw, rollup_5m, …) */
    public function dayFile(string $metric, string $sha, string $partition, int $tsMs, bool $gzAllowed = false): string
    {
        $dt = (new \DateTimeImmutable('@' . intdiv($tsMs, 1000)))->setTimezone(new \DateTimeZone('UTC'));
        // $dir = $this->seriesDir($metric, $sha) . "/{$partition}/" . $dt->format('Y/m');
        $dir = $this->seriesDir($metric, $sha) . "/{$partition}/" . $dt->format('Y/m');
        @mkdir($dir, 0775, true);
        $path = "{$dir}/" . $dt->format('d') . '.jsonl';
        // si pidieron un nombre “esperando” .gz (para lecturas), probamos ambos
        if ($gzAllowed && !is_file($path) && is_file($path . '.gz')) {
            return $path . '.gz';
        }
        return $path;
    }

    /** Crea/actualiza labels.json (idempotente) */
    public function upsertLabels(string $metric, string $sha, array $labels, int $tsMs): void
    {
        $dir = $this->seriesDir($metric, $sha);
        @mkdir($dir, 0775, true);
        $file = "{$dir}/labels.json";

        $labels = self::canonicalLabels($labels);
        $now    = $tsMs;
        $data   = ['labels' => $labels, 'createdAt' => $now, 'updatedAt' => $now];

        if (is_file($file)) {
            $old = json_decode((string)@file_get_contents($file), true) ?: [];
            $data['createdAt'] = $old['createdAt'] ?? $now;
        }
        @file_put_contents($file, json_encode($data, JSON_UNESCAPED_SLASHES | JSON_PRESERVE_ZERO_FRACTION));
    }

    /** Añade un dato a raw (append JSONL con lock corto). */
    public function appendRaw(string $metric, array $labels, float|int $value, int $tsMs): void
    {
        $labels = self::canonicalLabels($labels);
        $sha    = self::seriesId($labels);

        $this->upsertLabels($metric, $sha, $labels, $tsMs);

        $file = $this->dayFile($metric, $sha, 'raw', $tsMs, false);
        $fh = @fopen($file, 'ab');
        if (!$fh) return;
        try {
            if (@flock($fh, LOCK_EX)) {
                @fwrite($fh, json_encode(['ts' => (int)$tsMs, 'v' => (float)$value], JSON_PRESERVE_ZERO_FRACTION) . "\n");
                @flock($fh, LOCK_UN);
            }
        } finally {
            @fclose($fh);
        }
    }

    /** Itera series: devuelve [sha => labels] para el metric (lee labels.json). */
    public function listSeries(string $metric): array
    {
        $pattern = $this->metricDir($metric) . '/series/*/*/labels.json';
        $out = [];
        foreach (glob($pattern) ?: [] as $file) {
            $sha = basename(dirname($file));
            $row = json_decode((string)@file_get_contents($file), true);
            if (!is_array($row) || !isset($row['labels'])) continue;
            $out[$sha] = $row['labels'];
        }
        return $out;
    }

    /** Itera líneas JSONL(.gz) → cada línea como array ['ts'=>int,'v'=>float] */
    public static function readJsonlStream(string $path): \Generator
    {
        $isGz = str_ends_with($path, '.gz');

        if ($isGz) {
            $h = @gzopen($path, 'rb');
            if ($h === false) return;
            try {
                while (!gzeof($h)) {
                    $line = gzgets($h);
                    if ($line === false) break;
                    $line = trim($line);
                    if ($line === '') continue;
                    $row = json_decode($line, true);
                    if (is_array($row) && isset($row['ts'])) yield $row;
                }
            } finally { @gzclose($h); }
        } else {
            $h = @fopen($path, 'rb');
            if ($h === false) return;
            try {
                while (!feof($h)) {
                    $line = fgets($h);
                    if ($line === false) break;
                    $line = trim($line);
                    if ($line === '') continue;
                    $row = json_decode($line, true);
                    if (is_array($row) && isset($row['ts'])) yield $row;
                }
            } finally { @fclose($h); }
        }
    }
}
