<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics;

/**
 * Filesystem layout and helpers for metrics persistence.
 */
final class MetricsFS
{
    /**
     * Normalizes labels by sorting keys.
     */
    public static function canonicalLabels(array $labels): array
    {
        ksort($labels, SORT_STRING);
        return $labels;
    }

    /**
     * Builds a stable series identifier from canonical labels.
     */
    public static function seriesId(array $labels): string
    {
        return sha1(json_encode(self::canonicalLabels($labels), JSON_UNESCAPED_SLASHES));
    }

    /** Shard (2 hex) para repartir directorios */
    private static function shard(string $sha): string
    {
        return substr($sha, 0, 2);
    }

    /** @var MetricsRotator Rotator used for pruning and gzip operations. */
    private readonly MetricsRotator $rotator;

    /**
     * Creates a new metrics filesystem helper.
     */
    public function __construct(
        /** @var string Root directory for metrics files. */
        private string $root
    ) {
        $this->root = rtrim($root, '/');
        $this->rotator = new MetricsRotator($root);
    }

    /**
     * Rotates all metrics using the configured rotator.
     */
    public function rotate()
    {
        $this->rotator->rotateAll();
    }

    /**
     * Returns the directory for a metric.
     */
    public function metricDir(string $metric): string
    {
        return "{$this->root}/{$metric}";
    }

    /**
     * Returns the directory for a metric series.
     */
    public function seriesDir(string $metric, string $sha): string
    {
        return $this->metricDir($metric) . '/series/' . self::shard($sha) . '/' . $sha;
    }

    /**
     * Returns the daily file path for a partition.
     */
    public function dayFile(string $metric, string $sha, string $partition, int $tsMs, bool $gzAllowed = false): string
    {
        $dt = (new \DateTimeImmutable('@' . intdiv($tsMs, 1000)))->setTimezone(new \DateTimeZone('UTC'));
        // $dir = $this->seriesDir($metric, $sha) . "/{$partition}/" . $dt->format('Y/m');
        $dir = $this->seriesDir($metric, $sha) . "/{$partition}/" . $dt->format('Y/m');
        @mkdir($dir, 0775, true);
        $path = "{$dir}/" . $dt->format('d') . '.jsonl';
        // si pidieron un nombre “esperando” .gz (para lecturas), probamos ambos
        if ($gzAllowed && !is_file($path) && is_file($path . '.gz')) {
            return $path . '.gz';
        }
        return $path;
    }

    /**
     * Creates or updates labels.json for a series.
     */
    public function upsertLabels(string $metric, string $sha, array $labels, int $tsMs): void
    {
        $dir = $this->seriesDir($metric, $sha);
        @mkdir($dir, 0775, true);
        $file = "{$dir}/labels.json";

        $labels = self::canonicalLabels($labels);
        $now    = $tsMs;
        $data   = ['labels' => $labels, 'createdAt' => $now, 'updatedAt' => $now];

        if (is_file($file)) {
            $old = json_decode((string)@file_get_contents($file), true) ?: [];
            $data['createdAt'] = $old['createdAt'] ?? $now;
        }
        @file_put_contents($file, json_encode($data, JSON_UNESCAPED_SLASHES | JSON_PRESERVE_ZERO_FRACTION));
    }

    /**
     * Appends a raw data point to the JSONL file.
     */
    public function appendRaw(string $metric, array $labels, float|int $value, int $tsMs): void
    {
        $labels = self::canonicalLabels($labels);
        $sha    = self::seriesId($labels);

        $this->upsertLabels($metric, $sha, $labels, $tsMs);

        $file = $this->dayFile($metric, $sha, 'raw', $tsMs, false);
        $fh = @fopen($file, 'ab');
        if (!$fh) {
            return;
        }
        try {
            if (@flock($fh, LOCK_EX)) {
                @fwrite($fh, json_encode(['ts' => (int)$tsMs, 'v' => (float)$value], JSON_PRESERVE_ZERO_FRACTION) . "\n");
                @flock($fh, LOCK_UN);
            }
        } finally {
            @fclose($fh);
        }
    }

    /**
     * Lists series for a metric by reading labels.json files.
     */
    public function listSeries(string $metric): array
    {
        $pattern = $this->metricDir($metric) . '/series/*/*/labels.json';
        $out = [];
        foreach (glob($pattern) ?: [] as $file) {
            $sha = basename(dirname($file));
            $row = json_decode((string)@file_get_contents($file), true);
            if (!is_array($row) || !isset($row['labels'])) {
                continue;
            }
            $out[$sha] = $row['labels'];
        }
        return $out;
    }

    /**
     * Streams JSONL rows from a plain or gzipped file.
     */
    public static function readJsonlStream(string $path): \Generator
    {
        $isGz = str_ends_with($path, '.gz');

        if ($isGz) {
            $h = @gzopen($path, 'rb');
            if ($h === false) {
                return;
            }
            try {
                while (!gzeof($h)) {
                    $line = gzgets($h);
                    if ($line === false) {
                        break;
                    }
                    $line = trim($line);
                    if ($line === '') {
                        continue;
                    }
                    $row = json_decode($line, true);
                    if (is_array($row) && isset($row['ts'])) {
                        yield $row;
                    }
                }
            } finally {
                @gzclose($h);
            }
        } else {
            $h = @fopen($path, 'rb');
            if ($h === false) {
                return;
            }
            try {
                while (!feof($h)) {
                    $line = fgets($h);
                    if ($line === false) {
                        break;
                    }
                    $line = trim($line);
                    if ($line === '') {
                        continue;
                    }
                    $row = json_decode($line, true);
                    if (is_array($row) && isset($row['ts'])) {
                        yield $row;
                    }
                }
            } finally {
                @fclose($h);
            }
        }
    }
}
