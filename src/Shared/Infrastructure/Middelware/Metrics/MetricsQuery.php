<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Middelware\Metrics;

/** Query engine básico: series(), range(raw), rate(counter), sumBy(...) */
final class MetricsQuery
{
    public function __construct(private MetricsFS $fs)
    {
    }

    /** Devuelve lista de series [ ['sha'=>..., 'labels'=>[...] ], … ] filtrando por matchers */
    public function series(string $metric, LabelMatcher ...$matchers): array
    {
        $all = $this->fs->listSeries($metric);
        $out = [];
        foreach ($all as $sha => $labels) {
            $ok = true;
            foreach ($matchers as $m) {
                if (!$m->matches($labels)) {
                    $ok = false;
                    break;
                }
            }
            if ($ok) {
                $out[] = ['sha' => $sha, 'labels' => $labels];
            }
        }
        return $out;
    }

    /**
     * range: lee puntos entre $startMs..$endMs.
     * $stepSec opcional: si se indica, hace resample (avg por cubo).
     * return: array de timeseries: [ ['labels'=>..., 'points'=> [ [ts, value], ... ]], ... ]
     */
    public function range(
        string $metric,
        int $startMs,
        int $endMs,
        ?int $stepSec = null,
        string $partition = 'raw',
        LabelMatcher ...$matchers
    ): array {
        $partition = $partition ?: $this->pickPartition($startMs, $endMs);

        $series = $this->series($metric, ...$matchers);
        $result = [];
        foreach ($series as $s) {
            $pts = $this->readSeriesRange($metric, $s['sha'], $startMs, $endMs, $partition);
            if ($stepSec !== null && $stepSec > 0) {
                $pts = $this->resampleAvg($pts, $startMs, $endMs, $stepSec);
            }
            $result[] = ['labels' => $s['labels'], 'points' => $pts];
        }
        return $result;
    }

    public function rate(
        string $metric,
        int $startMs,
        int $endMs,
        int $stepSec,
        string $partition = 'raw',
        LabelMatcher ...$matchers
    ): array {
        $series = $this->series($metric, ...$matchers);
        $out = [];
        foreach ($series as $s) {
            // lee un poco antes para primera derivada
            $raw = $this->readSeriesRange($metric, $s['sha'], $startMs - ($stepSec * 1000), $endMs, $partition);
            $rate = $this->rateResample($raw, $startMs, $endMs, $stepSec);
            $out[] = ['labels' => $s['labels'], 'points' => $rate];
        }
        return $out;
    }

    // añade $partition y úsalo en la ruta
    private function readSeriesRange(
        string $metric,
        string $sha,
        int $startMs,
        int $endMs,
        string $partition = 'raw'
    ): array {
        $out = [];
        $start = (new \DateTimeImmutable('@' . intdiv($startMs, 1000)))->setTimezone(new \DateTimeZone('UTC'));
        $end   = (new \DateTimeImmutable('@' . intdiv($endMs, 1000)))->setTimezone(new \DateTimeZone('UTC'));

        for ($dt = $start->setTime(0, 0); $dt <= $end; $dt = $dt->modify('+1 day')) {
            $y = (int)$dt->format('Y');
            $m = (int)$dt->format('m');
            $d = (int)$dt->format('d');
            $base  = $this->fs->seriesDir($metric, $sha) . '/' . $partition . '/' . sprintf('%04d/%02d/%02d.jsonl', $y, $m, $d);
            $paths = [ $base . '.gz', $base ]; // intenta gzip primero
            foreach ($paths as $p) {
                if (!is_file($p)) {
                    continue;
                }
                foreach (MetricsFS::readJsonlStream($p) as $row) {
                    $ts = (int)$row['ts'];
                    if ($ts < $startMs || $ts > $endMs) {
                        continue;
                    }
                    $out[] = [$ts, (float)$row['v']];
                }
            }
        }
        usort($out, fn ($a, $b) => $a[0] <=> $b[0]);
        return $out;
    }

    /** sum by(labels) sobre múltiples series (asume puntos alineados por ts) */
    public function sumBy(array $timeseries, array $groupBy): array
    {
        // clave = concatenación de etiquetas groupBy
        $buckets = [];
        foreach ($timeseries as $ts) {
            $key = [];
            foreach ($groupBy as $k) {
                $key[] = ($ts['labels'][$k] ?? '');
            }
            $k = implode("\x1F", $key);

            if (!isset($buckets[$k])) {
                $buckets[$k] = ['labels' => array_intersect_key($ts['labels'], array_flip($groupBy)), 'points' => []];
            }
            // suma punto a punto
            foreach ($ts['points'] as [$t, $v]) {
                $buckets[$k]['points'][$t] = ($buckets[$k]['points'][$t] ?? 0) + (float)$v;
            }
        }
        // ordenar por ts y normalizar formato
        $out = [];
        foreach ($buckets as $b) {
            ksort($b['points']);
            $pts = [];
            foreach ($b['points'] as $t => $v) {
                $pts[] = [(int)$t, (float)$v];
            }
            $out[] = ['labels' => $b['labels'], 'points' => $pts];
        }
        return $out;
    }

    private function pickPartition(int $startMs, int $endMs): string
    {
        $rangeSec = max(1, intdiv($endMs - $startMs, 1000));
        if ($rangeSec > 14 * 24 * 3600) {
            return 'rollup_1h';
        }
        if ($rangeSec > 2 * 24 * 3600) {
            return 'rollup_5m';
        }
        return 'raw';
    }

    /** Resample promedio por cubos [start, end] a step segundos */
    private function resampleAvg(array $pts, int $startMs, int $endMs, int $stepSec): array
    {
        $stepMs = $stepSec * 1000;
        $b = (int) (floor($startMs / $stepMs) * $stepMs);
        $e = (int) (ceil($endMs   / $stepMs) * $stepMs);

        $sum = [];
        $cnt = [];
        foreach ($pts as [$t,$v]) {
            $bucket = (int)(floor($t / $stepMs) * $stepMs);
            $sum[$bucket] = ($sum[$bucket] ?? 0) + (float)$v;
            $cnt[$bucket] = ($cnt[$bucket] ?? 0) + 1;
        }
        $out = [];
        for ($t = $b; $t <= $e; $t += $stepMs) {
            if (isset($cnt[$t]) && $cnt[$t] > 0) {
                $out[] = [$t, $sum[$t] / $cnt[$t]];
            } else {
                $out[] = [$t, NAN];
            } // sin dato
        }
        return $this->interpolateOnGrid($out);
        // print_r($out);
        // die("FIN");
        // return $out;
        // return $this->interpolateLinear($pts, $stepSec);
    }

    /** rate por segundo: diferencia positiva / delta_t, re-muestreado a step */
    private function rateResample(array $pts, int $startMs, int $endMs, int $stepSec): array
    {
        if (count($pts) < 2) {
            return $this->resampleAvg([], $startMs, $endMs, $stepSec);
        }

        // 1) derivada puntual con resets
        $pairs = [];
        $prevT = null;
        $prevV = null;
        foreach ($pts as [$t,$v]) {
            if ($prevT !== null) {
                $dv = (float)$v - (float)$prevV;
                $dt = max(1, (int)(($t - $prevT) / 1000)); // s
                if ($dv >= 0) { // contador normal
                    $pairs[] = [$t, $dv / $dt];
                } else {
                    // reset: ignora este salto
                }
            }
            $prevT = $t;
            $prevV = $v;
        }
        // 2) resample promedio por cubos
        return $this->resampleAvg($pairs, $startMs, $endMs, $stepSec);
    }

    private function interpolateOnGrid(array $grid, string $edgePolicy = 'nan'): array
    {
        $n = count($grid);
        if ($n === 0) {
            return $grid;
        }

        $isFinite = static fn ($x) => is_finite($x) && !is_nan($x);

        // Índice del próximo válido a la derecha
        $nextIdx = array_fill(0, $n, -1);
        $last = -1;
        for ($i = $n - 1; $i >= 0; $i--) {
            $last = $isFinite($grid[$i][1]) ? $i : $last;
            $nextIdx[$i] = $last;
        }

        $prev = -1;
        for ($i = 0; $i < $n; $i++) {
            [$t,$v] = $grid[$i];

            if ($isFinite($v)) {
                $prev = $i;
                continue;
            }

            // bloque de NaNs [i..j-1]
            $j = $i;
            while ($j < $n && !$isFinite($grid[$j][1])) {
                $j++;
            }

            $left  = $prev;
            $right = ($j < $n) ? $j : -1;

            if ($left !== -1 && $right !== -1) {
                // Interpolar linealmente entre left..right
                [$tl,$vl] = $grid[$left];
                [$tr,$vr] = $grid[$right];
                $dt = $tr - $tl;
                if ($dt != 0.0) {
                    for ($k = $i; $k < $j; $k++) {
                        $tk = $grid[$k][0];
                        $alpha = ($tk - $tl) / $dt;
                        $grid[$k][1] = $vl + ($vr - $vl) * $alpha;
                    }
                }
            } else {
                // Borde: aplicar política
                if ($edgePolicy === 'zero') {
                    for ($k = $i; $k < $j; $k++) {
                        $grid[$k][1] = 0.0;
                    }
                } elseif ($edgePolicy === 'ffill' && $right !== -1) {
                    $val = $grid[$right][1];
                    for ($k = $i; $k < $j; $k++) {
                        $grid[$k][1] = $val;
                    }
                } elseif ($edgePolicy === 'bfill' && $left !== -1) {
                    $val = $grid[$left][1];
                    for ($k = $i; $k < $j; $k++) {
                        $grid[$k][1] = $val;
                    }
                }
                // con 'nan' se deja tal cual
            }
            $i = $j - 1; // saltar el bloque
        }
        foreach ($grid as $k => $v) {
            if (is_nan($v[1])) {
                $grid[$k][1] = 0;
            }
        }
        return $grid;
    }
}
