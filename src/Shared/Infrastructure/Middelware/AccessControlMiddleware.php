<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Middelware;

use Psr\Http\Client\ClientInterface;
use Psr\Http\Message\RequestFactoryInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Message\StreamFactoryInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Psr\SimpleCache\CacheInterface;
use Slim\App;
use Slim\Psr7\Factory\ResponseFactory;
use Symfony\Component\Yaml\Yaml;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Context;
use Civi\Lughauth\Shared\Exception\UnauthorizedException;

/**
 * Enforces access control rules defined in the guard configuration.
 */
class AccessControlMiddleware
{
    /**
     * @var array<string, array<string, mixed>> Parsed access control rules.
     */
    private array $rules;

    /**
     * Creates a new access control middleware.
     */
    public function __construct(
        /** @var App Slim application instance. */
        private readonly App $app,
        /** @var Context Request context holding identity and connection details. */
        private readonly Context $context,
        /** @var AppConfig Configuration provider. */
        private readonly AppConfig $config,
        /** @var CacheInterface Cache for API key verification. */
        private readonly CacheInterface $cache,
        /** @var RequestFactoryInterface Factory for remote verification requests. */
        private readonly RequestFactoryInterface $requestFactory,
        /** @var ClientInterface HTTP client used for API key verification. */
        private readonly ClientInterface $client,
        /** @var StreamFactoryInterface Stream factory for request bodies. */
        private readonly StreamFactoryInterface $streamFactory,
        string $rulesFile = __DIR__ . '/../../../../config/guard.yaml'
    ) {
        $this->rules = Yaml::parseFile($rulesFile) ?? [];
    }

    /**
     * Applies the access control rules to the incoming request.
     */
    public function __invoke(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {
        $basePath = $this->app->getBasePath(); // e.g. '/api'

        $path = $request->getUri()->getPath();

        // Eliminar el basePath del path, si lo tiene
        if (!empty($basePath) && str_starts_with($path, $basePath)) {
            $path = substr($path, strlen($basePath));
            if ($path === '') {
                $path = '/';
            }
        }

        $identity = $this->context->getIdentity();
        $connection = $this->context->getConnection();

        $matchedRule = $this->matchRule($path);
        if (!$matchedRule) {
            return $handler->handle($request); // No hay restricciones
        }

        // Validaciones
        if (isset($matchedRule['anonimous']) && !$matchedRule['anonimous'] && $identity->anonimous) {
            return $this->deny(401, "Unauthorized");
        }

        if (isset($matchedRule['roles']) && !$identity->hasAnyRole(...$matchedRule['roles'])) {
            return $this->deny(403, "Forbidden: role");
        }

        if (isset($matchedRule['groups']) && !array_intersect($matchedRule['groups'], $identity->groups ?? [])) {
            return $this->deny(403, "Forbidden: group");
        }

        if (isset($matchedRule['api-key-scope'])) {
            $apiKey = $request->getHeaderLine('x-api-key');
            if (!$apiKey) {
                return $this->deny(401, "Missing API Key");
            }
            $this->validateApiKey($apiKey, $matchedRule['api-key-scope']);
        }

        if (isset($matchedRule['cidr'])) {
            $ok = false;
            foreach ($matchedRule['cidr'] as $range) {
                if ($connection->inRange($range)) {
                    $ok = true;
                    break;
                }
            }
            if (!$ok) {
                return $this->deny(403, "Forbidden: cidr");
            }
        }

        if (isset($matchedRule['scopes'])) {
            $ok = false;
            foreach ($matchedRule['scopes'] as $scope) {
                if ($identity->hasScope($scope)) {
                    $ok = true;
                    break;
                }
            }
            if (!$ok) {
                return $this->deny(403, "Forbidden: scope");
            }
        }

        return $handler->handle($request);
    }

    /**
     * Matches the request path to a configured access rule.
     *
     * @param string $path Normalized request path.
     * @return array<string, mixed>|null Matching rule data, or null if none match.
     */
    private function matchRule(string $path): ?array
    {
        // Coincidencia exacta o por prefijo
        foreach ($this->rules as $routePattern => $rule) {
            if ($path === $routePattern || str_starts_with($path, rtrim($routePattern, '/'))) {
                return $rule;
            }
        }
        return null;
    }

    /**
     * Builds a JSON error response for denied requests.
     *
     * @param int $statusCode HTTP status code to return.
     * @param string $message Error message to include.
     */
    private function deny(int $statusCode, string $message): ResponseInterface
    {
        $responseFactory = new ResponseFactory();
        $response = $responseFactory->createResponse($statusCode);
        $response->getBody()->write(json_encode(['error' => $message]));
        return $response->withHeader('Content-Type', 'application/json');
    }

    /**
     * Validates an API key against the configured scope requirements.
     *
     * @param string $key API key provided by the client.
     * @param string $scope Required scope for the request.
     */
    private function validateApiKey(string $key, string $scope)
    {
        if ($this->cache->has('api-key-verify--' . $key)) {
            $info = json_decode($this->cache->get('api-key-verify--' . $key), true);
        } else {
            $url = $this->config->get('security.api.key.verify.location');
            $body = json_encode(['api-key' => $key]);
            $stream = $this->streamFactory->createStream($body);

            $response = $this->client->sendRequest($this->requestFactory->createRequest('POST', $url)
                    ->withHeader('Content-Type', 'application/json')
                    ->withBody($stream));
            if ($response->getStatusCode() !== 200) {
                throw new UnauthorizedException(message: 'Unable to verify.');
            } else {
                $body = (string) $response->getBody();
                if ($body) {
                    $this->cache->set('api-key-verify--' . $key, $body);
                }
                $info = json_decode($body, true);
            }
        }
        if (!isset($info['scopes']) || !in_array($scope, $info['scopes'])) {
            throw new UnauthorizedException(message: 'Insuficient scope.');
        }
    }
}
