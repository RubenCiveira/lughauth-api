<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Shared\Infrastructure\Middelware;

use DateTime;
use Psr\SimpleCache\CacheInterface;
use Psr\Http\Client\ClientInterface;
use Psr\Http\Message\RequestFactoryInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Server\RequestHandlerInterface;
use Jose\Component\Core\JWKSet;
use Jose\Component\Signature\Serializer\CompactSerializer;
use Jose\Component\Signature\JWSVerifier;
use Jose\Component\Core\AlgorithmManager;
use Jose\Component\Signature\Algorithm\RS256;
use Civi\Lughauth\Shared\AppConfig;
use Civi\Lughauth\Shared\Context;
use Civi\Lughauth\Shared\Exception\UnauthorizedException;
use Civi\Lughauth\Shared\Security\Connection;
use Civi\Lughauth\Shared\Security\Identity;

class JwtVerifierMiddleware
{
    private readonly ?string $jwksUrl;
    private readonly ?string $requiredIssuer;
    private readonly ?string $requiredAudiences;
    private readonly ?string $rolesPath;

    // Tiene que descargar y mantener sincronizado el repositorio de claves publicas.
    public function __construct(
        private readonly AppConfig $config,
        private readonly Context $context,
        private readonly CacheInterface $cache,
        private readonly RequestFactoryInterface $requestFactory,
        private readonly ClientInterface $client
    ) {
        $this->jwksUrl = $config->get('security.jwt.verify.publickey.location', '-');
        $this->requiredIssuer = $config->get('security.jwt.verify.issuer');
        $this->requiredAudiences = $config->get('security.jwt.verify.audiences');
        $this->rolesPath = $config->get('security.jwt.verify.path.roles');
    }

    public function __invoke(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface
    {
        if ($this->jwksUrl !== '-') {
            $auth = $request->getHeader('Authorization');
            if ($auth && str_starts_with($auth[0], 'Bearer ')) {
                $this->verifyAuth(substr($auth[0], 7), Identity::AUTH_SCOPE_BOTH);
            } elseif (isset($_COOKIE['Authorization']) && 'GET' == $request->getMethod()) {
                $this->verifyAuth($_COOKIE['Authorization'], Identity::AUTH_SCOPE_READ);
            } elseif (isset($_GET['Authorization']) && 'GET' == $request->getMethod()) {
                $this->verifyAuth($_GET['Authorization'], Identity::AUTH_SCOPE_READ);
            }
        }
        return $handler->handle($request);
    }

    private function verifyAuth(string $token, string $authScope): string
    {
        $cache_key = "verify_access_{$token}";
        if ($this->cache->has($cache_key)) {
            [$connection, $identity, $error] = json_decode($this->cache->get($cache_key), true);
            if ($error) {
                throw new UnauthorizedException(message: $error);
            } else {
                [$connection, $identity] = $this->deseiralize([$connection, $identity]);
                $this->context->setSecurityContext($connection, $identity);
            }
        } else {
            $jwks = $this->getJwks();
            try {
                $jwt = $this->extractJwt($token);
                if ($this->verify($jwt, $jwks)) {
                    $payload = json_decode($jwt->getPayload());
                    $nbf = $payload->nbf;
                    $exp = $payload->exp;
                    $now = time();
                    if (($now - $nbf) > 1000) {
                        $fail = 'The provided JWT is not ready for use.';
                        $this->cache->set($cache_key, json_encode([null, null, $fail]));
                        throw new UnauthorizedException(message: $fail);
                    } elseif ($now > $exp) {
                        $fail = 'The provided JWT is expired.';
                        $this->cache->set($cache_key, json_encode([null, null, $fail]));
                        throw new UnauthorizedException(message: $fail);
                    } elseif (!$nbf || !$exp) {
                        $fail = 'The provided JWT dont have valid time range.';
                        $this->cache->set($cache_key, json_encode([null, null, $fail]));
                        throw new UnauthorizedException(message: $fail);
                    } else {
                        $this->verifyToken($payload);
                        $claims = get_object_vars($payload);
                        $propertiesToRemove = ['sub', 'grant_type', 'aud', 'azp', 'scope', 'iss', 'groups', 'typ', 'exp', 'iat', 'jti'];
                        foreach ($propertiesToRemove as $property) {
                            unset($claims[$property]);
                        }
                        $identity = new Identity(
                            anonimous: false,
                            authScope: $authScope,
                            id: $payload->sub,
                            name: $payload->sub,
                            issuer: $payload->iss,
                            roles: $this->extractRoles($payload),
                            groups: $payload->groups ?? null,
                            tenant: $payload->tenant ?? 'main',
                            claims: $claims ?? null
                        );
                        $connection = Connection::remoteHttp($payload->azp, $this->config);
                        $this->cache->set($cache_key, json_encode([$connection, $identity, null]));
                        $this->context->setSecurityContext($connection, $identity);
                    }
                } else {
                    $fail = 'The provided JWT could not be verified.';
                    $this->cache->set($cache_key, json_encode([null, null, $fail]));
                    throw new UnauthorizedException(message: $fail);
                }
            } catch (\InvalidArgumentException $je) {
                $fail = 'The provided JWT is not valid.';
                $this->cache->set($cache_key, json_encode([null, null, $fail]));
                throw new UnauthorizedException(message: $fail);
            }
        }
        return $token;
    }

    private function deseiralize($vcc)
    {
        [$cc, $ac] = $vcc;
        $identity = new Identity(
            anonimous: $ac['anonimous'],
            authScope: $ac['authScope'],
            id: $ac['id'],
            name: $ac['name'],
            issuer: $ac['issuer'],
            roles: $ac['roles'],
            groups: $ac['groups'],
            tenant: $ac['tenant'],
            claims: $ac['claims']
        );
        $connection = new Connection(
            remote: $cc['remote'],
            startTime: new DateTime($cc['startTime']['date']),
            application: $cc['application'],
            callback: $cc['callback'],
            source: $cc['source'],
            target: $cc['target'],
            locale: $cc['locale']
        );
        return [$connection, $identity];
    }

    private function extractJwt(string $token)
    {
        $serializer = new CompactSerializer();
        return $serializer->unserialize($token);
    }

    private function verify($jwt, string $jwks)
    {
        $jwkSet = JWKSet::createFromJson($jwks);
        $isVerified = false;
        if ($jwt) {
            // Crear un verificador de JWS con el algoritmo correspondiente
            $algorithmManager = new AlgorithmManager([new RS256()]);
            $jwsVerifier = new JWSVerifier($algorithmManager);
            // Verificar el token con el JWKSet
            $isVerified = $jwsVerifier->verifyWithKeySet($jwt, $jwkSet, 0);
        }
        return $isVerified;
    }

    private function getJwks()
    {
        $cache_key = 'jwks.verify.publickey';
        if ($this->cache->has($cache_key)) {
            return $this->cache->get($cache_key);
        } else {
            $response = $this->client->sendRequest($this->requestFactory->createRequest('GET', $this->jwksUrl));
            $item = '' . $response->getBody();
            $this->cache->set($cache_key, $item, new \DateInterval('PT1H'));
            return $item;
        }
    }

    private function verifyToken($payload)
    {
        if ($this->requiredIssuer && $payload->iss != $this->requiredIssuer) {
            throw new UnauthorizedException(message: 'The issuer is not valid.');
        }
        if ($this->requiredAudiences) {
            // Tiene que tener todas las audiencias.
            $reqs = [];
            foreach (explode(',', $this->requiredAudiences) as $au) {
                $reqs[$au] = true;
            }
            $auds = is_array($payload->aud) ? $payload->aud : [ $payload->aud ];
            foreach ($auds as $target) {
                unset($reqs[$target]);
            }
            if (count($reqs) > 1) {
                throw new UnauthorizedException(message: 'The audience is not valid.');
            }
        }
    }

    private function extractRoles($payload): array
    {
        $path = explode('/', $this->rolesPath);
        $in = (array)$payload;
        foreach ($path as $part) {
            if (isset($in[$part])) {
                $in = (array)$in[$part];
            } else {
                return [];
            }
        }
        return $in;
    }
}
