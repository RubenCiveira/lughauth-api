<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Features\Oidc\Common\Infrastructure\Driven;

use DateTimeImmutable;
use Civi\Lughauth\Shared\Value\Random;
use Civi\Lughauth\Shared\Observability\LoggerAwareTrait;
use Civi\Lughauth\Features\Access\Tenant\Domain\Gateway\TenantReadGateway;
use Civi\Lughauth\Features\Access\Tenant\Domain\Tenant;
use Civi\Lughauth\Features\Access\TenantTermsOfUse\Domain\Gateway\TenantTermsOfUseFilter;
use Civi\Lughauth\Features\Access\TenantTermsOfUse\Domain\Gateway\TenantTermsOfUseReadGateway;
use Civi\Lughauth\Features\Access\TenantTermsOfUse\Domain\TenantTermsOfUse;
use Civi\Lughauth\Features\Access\User\Domain\Gateway\UserReadGateway;
use Civi\Lughauth\Features\Access\User\Domain\Gateway\UserWriteGateway;
use Civi\Lughauth\Features\Access\User\Domain\User;
use Civi\Lughauth\Features\Access\User\Domain\UserApproveOptions;
use Civi\Lughauth\Features\Access\UserAccessTemporalCode\Domain\Gateway\UserAccessTemporalCodeWriteGateway;
use Civi\Lughauth\Features\Access\UserAccessTemporalCode\Domain\UserAccessTemporalCode;
use Civi\Lughauth\Features\Access\UserAccessTemporalCode\Domain\UserAccessTemporalCodeAttributes;
use Civi\Lughauth\Features\Oidc\Authentication\Domain\AuthenticationResult;
use Civi\Lughauth\Features\Oidc\Authentication\Domain\Exception\LoginException;

class UserLoaderAdapter
{
    use LoggerAwareTrait;

    public function __construct(
        private readonly TenantReadGateway $tenants,
        private readonly UserAccessTemporalCodeWriteGateway $codeWriter,
        private readonly UserReadGateway $users,
        private readonly UserWriteGateway $usersWriter,
        private readonly TenantTermsOfUseReadGateway $terms,
    ) {
    }

    public function userCodeForUpdate(User $user): UserAccessTemporalCode
    {
        $code = $this->codeWriter->findOneForUpdateByUser($user);
        if (!$code) {
            $atts = new UserAccessTemporalCodeAttributes();
            $atts->uid(Random::comb());
            $atts->user($user);
            $code = $this->codeWriter->create(UserAccessTemporalCode::create($atts));
        }
        return $code;
    }

    public function loadTenantTerms(Tenant $tenant): ?TenantTermsOfUse
    {
        /** @var ?TenantTermsOfUse  */
        $last = null;
        $now = new DateTimeImmutable();
        $query = new TenantTermsOfUseFilter(tenant: $tenant);
        $all = $this->terms->list($query);
        foreach ($all as $term) {
            $on = $term->getActivationDate();
            if (!$on || !$term->isEnabled() || $on > $now) {
                // No date.
                continue;
            }
            if ($last != null && $last->getActivationDate() > $on) {
                // Date before prev selected
                continue;
            }
            $last = $term;
        }
        return $last;
    }

    public function updateCode(UserAccessTemporalCode $user): UserAccessTemporalCode
    {
        return $this->codeWriter->update($user, $user);
    }

    public function checkTenant(string $tenant, string $username): Tenant
    {
        $result = $this->tenants->findOneByName($tenant);
        if (!$result) {
            $this->inexistentTenant($tenant);
            throw new LoginException(auth: AuthenticationResult::unknowUser($tenant, $username));
        }
        if (!$result->isEnabled()) {
            $this->disabledTenant($tenant);
            throw new LoginException(auth: AuthenticationResult::unknowUser($tenant, $username));
        }
        return $result;
    }

    /**
     * @return array{0: User, 1: UserAccessTemporalCode}
     */
    public function checkUserByRecoveryCode(Tenant $tenant, string $code): array
    {
        if ($recover = $this->codeWriter->findOneForUpdateByRecoveryCode($code)) {
            if ($theUser = $this->usersWriter->findOneForUpdateByUid($recover->getUser()->uid())) {
                if ($tenant->uid() === $theUser->getTenant()->uid()) {
                    $username = $theUser->getName();
                    $this->checkLookupUser($tenant, $theUser, $username);
                    return [$theUser, $recover];
                }
            }
        }
        throw new LoginException(auth: AuthenticationResult::unknowUser($tenant->getName(), $code));
    }

    /**
     * @return array{0: User, 1: UserAccessTemporalCode}
     */
    public function checkUserByRegisterCode(Tenant $tenant, string $code): array
    {
        if ($recover = $this->codeWriter->findOneForUpdateByRegisterCode($code)) {
            if ($theUser = $this->usersWriter->findOneForUpdateByUid($recover->getUser()->uid())) {
                if ($tenant->uid() === $theUser->getTenant()->uid()) {
                    $username = $theUser->getName();
                    $user = $this->users->findOneByTenantAndName($tenant, $username);
                    if ($user->getApprove() !== UserApproveOptions::UNVERIFIED) {
                        throw new LoginException(auth: AuthenticationResult::unknowUser($tenant->getName(), $username));
                    }
                    return [$theUser, $recover];
                }
            }
        }
        throw new LoginException(auth: AuthenticationResult::unknowUser($tenant->getName(), $code));
    }

    public function checkUserNameOrEmail(Tenant $tenant, string $username): User
    {
        return $this->checkLookupUser($tenant, $this->users->findOneByTenantAndName($tenant, $username), $username);
    }

    public function checkUser(Tenant $tenant, string $username): User
    {
        return $this->checkLookupUser($tenant, $this->users->findOneByTenantAndName($tenant, $username), $username);
    }

    public function checkUserSubjet(Tenant $tenant, string $username): User
    {
        return $this->checkLookupUser($tenant, $this->users->findOneByUid($username), $username);
    }

    private function checkLookupUser(Tenant $tenant, ?User $theUser, string $username): User
    {
        if (!$theUser) {
            $this->inexistentUser($tenant->getName(), $username);
            throw new LoginException(auth: AuthenticationResult::unknowUser($tenant->getName(), $username));
        }
        if ($theUser->getTenant()->uid() != $tenant->uid()) {
            $this->inexistentUser($tenant->getName(), $username);
            throw new LoginException(auth: AuthenticationResult::unknowUser($tenant->getName(), $username));
        }
        if (!$theUser->isEnabled()) {
            $this->disabledUser($tenant->getName(), $username);
            throw new LoginException(auth: AuthenticationResult::unknowUser($tenant->getName(), $username));
        }
        if ($blocked = $theUser->getBlockedUntil()) {
            if ($blocked > new DateTimeImmutable()) {
                $this->blockedUser($tenant->getName(), $username);
                throw new LoginException(auth: AuthenticationResult::unknowUser($tenant->getName(), $username));
            }
        }
        if (UserApproveOptions::ACCEPTED !== $theUser->getApprove()) {
            $this->unacceptedUser($tenant->getName(), $username);
            throw new LoginException(auth: AuthenticationResult::unknowUser($tenant->getName(), $username));
        }
        return $theUser;
    }

    private function disabledTenant(string $tenant)
    {
        $this->logError('Try login on a disabled tenant', ['tenant-name' => $tenant]);
    }

    private function inexistentTenant(string $tenant)
    {
        $this->logError('Try login on an inexistent tenant', ['tenant-name' => $tenant]);
    }

    private function inexistentUser(string $tenant, string $user)
    {
        $this->logError('Try login on an inexistent user on a tenant', ['tenant-name' => $tenant, 'user-name' => $user]);
    }

    private function unacceptedUser(string $tenant, string $user)
    {
        $this->logError('Try login with a disabled user on a tenant', ['tenant-name' => $tenant, 'user-name' => $user]);
    }

    private function disabledUser(string $tenant, string $user)
    {
        $this->logError('Try login with a disabled user on a tenant', ['tenant-name' => $tenant, 'user-name' => $user]);
    }

    private function blockedUser(string $tenant, string $user)
    {
        $this->logError('Try login with a blocked user on a tenant', ['tenant-name' => $tenant, 'user-name' => $user]);
    }
}
