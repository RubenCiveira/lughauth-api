<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Features\Oidc\Key\Domain;

use Civi\Lughauth\Features\Oidc\Key\Domain\Gateway\TokenStoreGateway;
use Jose\Component\Core\JWKSet;
use Jose\Component\KeyManagement\JWKFactory;
use Jose\Component\Signature\Serializer\CompactSerializer;
use Jose\Component\Core\AlgorithmManager;
use Jose\Component\Signature\Algorithm\RS256;
use Jose\Component\Signature\JWSBuilder;
use Jose\Component\Signature\JWSVerifier;
use Ramsey\Uuid\Uuid;

class KeysManagerService
{
    public function __construct(
        private readonly KeyConfig $config,
        private readonly TokenStoreGateway $repository
    ) {
    }

    public function sign(string $tenant, array $data, \DateInterval $expiration): string
    {
        $this->checkNewNeeded($tenant);
        $key = $this->repository->currentKey($tenant);
        if (!$key) {
            throw new \Exception('There is no active key');
        }
        // Crear el gestor de algoritmos con RS256
        $privateKeyContent = JWKFactory::createFromKey($key->privateKey);

        $algorithmManager = new AlgorithmManager([new RS256()]);

        // Crear un JWT Builder
        $jwsBuilder = new JWSBuilder($algorithmManager);

        $initial = new \DateTimeImmutable();
        $end = $initial->add($expiration);
        $data = array_merge(['typ' => 'Bearer',
                'jti' => $key->kid,
                'iat' => $initial->getTimestamp(),
                'nbf' => $initial->getTimestamp(),
                'exp' => $end->getTimestamp()], $data);
        foreach ($data as $k => $v) {
            if (null === $v) {
                unset($data[$k]);
            }
        }
        // Payload del JWT
        $payload = json_encode($data);
        // Construir y firmar el token
        $token = $jwsBuilder->create() // Crear el JWS
                    ->withPayload($payload) // Establecer el payload
                    ->addSignature($privateKeyContent, ['alg' => 'RS256']) // AÃ±adir la firma
                    ->build();

        // Serializar el token a formato compacto
        $serializer = new CompactSerializer();
        return $serializer->serialize($token, 0);
    }

    /**
     *  @param KeyPair[] $elementos Array de objetos de tipo MiClase
     */
    public function keysAsJwks(string $tenant): JWKSet
    {
        $this->checkNewNeeded($tenant);
        $keys = [];
        $result = $this->repository->listKeys($tenant);
        foreach ($result as $pk) {
            $keys[] = JWKFactory::createFromKey(
                $pk->publicKey,
                null,
                ['kid' => $pk->kid, 'alg' => $pk->alg, 'use' => $pk->keyUse]
            );
        }
        return new JWKSet($keys);
    }

    public function signKeypass(string $tenant, array $data, \DateInterval $expiration): string
    {
        return $this->sign($tenant, ['keypass' => $data], $expiration);
    }

    public function verifiedKeypass(string $tenant, string $token)
    {
        $jwkSet = $this->keysAsJwks($tenant);
        // $jwkSet = JWKSet::createFromJson($info->jwks);
        $serializer = new CompactSerializer();
        try {
            $jwt = $serializer->unserialize($token);
        } catch (\InvalidArgumentException $je) {
            $jwt = null;
        }
        $isVerified = false;
        if ($jwt) {
            // Crear un verificador de JWS con el algoritmo correspondiente
            $algorithmManager = new AlgorithmManager([new RS256()]);
            $jwsVerifier = new JWSVerifier($algorithmManager);
            // Verificar el token con el JWKSet
            $isVerified = $jwsVerifier->verifyWithKeySet($jwt, $jwkSet, 0);
        }
        $result = null;
        if ($isVerified) {
            $payload = json_decode($jwt->getPayload());
            $nbf = $payload->nbf;
            $exp = $payload->exp;
            $result = $payload->keypass;
            if (!$nbf || !$exp) {
                $result = null;
            }
            $now = time();
            if ($now < $nbf) {
                $result = null;
            }
            if ($now > $exp) {
                $result = null;
            }
        }
        return $result;
    }

    private function checkNewNeeded(string $tenant)
    {
        $expected = new \DateTime();
        for ($i = 0; $i < $this->config->futures; $i++) {
            $expected = $expected->add($this->config->ttl);
        }
        $end = $this->repository->nextKeysExpiration($tenant);
        if ($expected > $end) {
            $since = (new \DateTimeImmutable())->setTimestamp(time() - 3600);
            $differenceInSeconds = $expected->getTimestamp() - $since->getTimestamp();
            $intervalInSeconds = $this->intervalInSeconds($this->config->ttl);
            $numberOfIntervals = (int) ceil($differenceInSeconds / $intervalInSeconds);
            for ($i = 0; $i < $numberOfIntervals + 1; $i++) {
                // Tengo que crear una clave y guardarla.
                $pair = $this->createKeyPair();
                $this->repository->saveKey($tenant, $pair, $since, $this->config->ttl);
                $since = $since->add($this->config->ttl);
            }
        }
    }

    private function createKeyPair(): KeyPair
    {
        $privateKeyResource = openssl_pkey_new([
            'private_key_type' => OPENSSL_KEYTYPE_RSA,
            'private_key_bits' => 4096,
        ]);
        if ($privateKeyResource === false) {
            while ($msg = openssl_error_string()) {
                echo "OpenSSL error: $msg\n";
            }
            throw new \RuntimeException('No se pudo generar la clave RSA');
        }
        // Exportar claves
        openssl_pkey_export($privateKeyResource, $privateKey);
        $publicKey = openssl_pkey_get_details($privateKeyResource)['key'];
        return new KeyPair(
            kid: Uuid::uuid4()->toString(),
            alg: 'RS256',
            keyUse: 'sig',
            privateKey: $privateKey,
            publicKey: $publicKey
        );
    }

    private function intervalInSeconds(\DateInterval $range)
    {
        return $range->y * 31536000
                   + $range->m * 2419200
                   + $range->d * 86400
                   + $range->h * 3600
                   + $range->i * 60
                   + $range->s;

    }
}
