<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Features\Oidc\Client\Infrastructure\Driven;

use Override;
use Civi\Lughauth\Shared\Context;
use Civi\Lughauth\Shared\Security\AesCypherService;
use Civi\Lughauth\Shared\Observability\LoggerAwareTrait;
use Civi\Lughauth\Features\Oidc\Client\Domain\ClientData;
use Civi\Lughauth\Features\Oidc\Client\Domain\Gateway\ClientStoreRepository;
use Civi\Lughauth\Features\Access\TrustedClient\Domain\Gateway\TrustedClientReadGateway;

class ClientStoreAdapter implements ClientStoreRepository
{
    use LoggerAwareTrait;

    public function __construct(
        private readonly Context $context,
        private readonly AesCypherService $cypher,
        private readonly TrustedClientReadGateway $clients,
    ) {
    }

    #[Override]
    public function clientData(string $clientId, string $clientSecret): ?ClientData
    {
        $existent = $this->clients->findOneByCode($clientId);
        if ($existent) {
            if (!$existent->getEnabled()) {
                // Not enabled
                $this->notEnabled($clientId);
                return null;
            } elseif ($clientSecret !== $existent->getPlainSecretOauth($this->cypher)) {
                // Wrong passwrod
                $this->wrongPassword($clientId);
                return null;
            } else {
                return new ClientData($clientId, ['password'], true);
            }
        } else {
            // No code
            $this->inexistent($clientId);
            return null;
        }
    }

    #[Override]
    public function publicClientData(string $id, string $tenant, string $redirectUrl, string $scope): ?ClientData
    {
        $existent = $this->clients->findOneByCode($id);
        if ($existent) {
            if (!$existent->getEnabled()) {
                $this->notEnabled($id);
                // Not enabled
                return null;
            } elseif (!$existent->getPublicAllow()) {
                // Not public allowed
                $this->notPublic($id);
                return null;
            } else {
                $allowed = false;
                if (str_starts_with($this->context->getBaseUrl(), $redirectUrl)) {
                    $allowed = true;
                } else {
                    $redirects = $existent->getAllowedRedirects();
                    foreach ($redirects as $redirect) {
                        $url = $redirect->getUrl();
                        $local = str_starts_with($url, 'http://localhost:') ||  str_starts_with($url, 'http://localhost/');
                        $every = str_ends_with($url, '*');
                        if ($redirectUrl == $redirect->getUrl()) {
                            $allowed = true;
                            break;
                        } elseif ($local && $every && str_starts_with($redirectUrl, substr($url, 0, -1))) {
                            $allowed = true;
                            break;
                        }
                    }
                }
                if (!$allowed) {
                    // No redirect existent
                    $this->notAllowed($id, $redirectUrl);
                    return null;
                } else {
                    return new ClientData($id, ['password'], true);
                }
            }
        } else {
            $this->inexistent($id);
            return null;
        }
    }

    private function notPublic(string $clientId)
    {
        $this->logError('Try to get a public token from a not public Trusted Client', ['client-id' => $clientId]);
    }

    private function notEnabled(string $clientId)
    {
        $this->logError('Try to get a token from a not enabled Trusted Client', ['client-id' => $clientId]);
    }

    private function inexistent(string $clientId)
    {
        $this->logError('Try to get a token for a inexistent Trusted Client', ['client-id' => $clientId]);
    }

    private function wrongPassword(string $clientId)
    {
        $this->logError('Try to get a token for a Trusted Client with wrong password', ['client-id' => $clientId]);
    }

    private function notAllowed(string $clientId, string $url)
    {
        $this->logError('Try to get a token for from a public Trusted Client with wrong redirect url', ['client-id' => $clientId, 'redirect-url' => $url]);
    }
}
