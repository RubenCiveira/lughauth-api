<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Features\Oidc\Authentication\Infrastructure\Driver\Html\Services;

use DateInterval;
use Civi\Lughauth\Features\Oidc\Authentication\Domain\AuthenticationRequest;
use Civi\Lughauth\Features\Oidc\Authentication\Domain\AuthenticationResult;
use Civi\Lughauth\Features\Oidc\Authentication\Domain\AuthorizedChalleges;
use Civi\Lughauth\Features\Oidc\Authentication\Domain\Exception\LoginException;
use Civi\Lughauth\Features\Oidc\Authentication\Infrastructure\Driver\Html\Entities\PublicLoginSessionResponse;
use Civi\Lughauth\Features\Oidc\Client\Domain\ClientData;
use Civi\Lughauth\Features\Oidc\Client\Domain\Gateway\ClientStoreGateway;
use Civi\Lughauth\Features\Oidc\Key\Domain\KeysManagerService;
use Civi\Lughauth\Features\Oidc\Session\Domain\Gateway\SessionStoreGateway;
use Civi\Lughauth\Features\Oidc\User\Application\Usecase\ChangePasswordUsecase;
use Civi\Lughauth\Features\Oidc\User\Application\Usecase\LoginUsecase;
use Civi\Lughauth\Features\Oidc\User\Domain\PublicLoginAuthResponse;
use Civi\Lughauth\Shared\Context;
use Ramsey\Uuid\Uuid;

class PublicLogin
{
    public function __construct(
        private readonly Context $context,
        private readonly KeysManagerService $manager,
        private readonly LoginUsecase $userLoginGateway,
        private readonly SessionStoreGateway $session,
        private readonly ClientStoreGateway $clients,
        private readonly ChangePasswordUsecase $userChpassGateway,
    ) {
    }

    public function allowUserRecoverPassword(string $tenant): bool
    {
        return $this->userChpassGateway->allowRecover($tenant);
    }

    public function askPassChange(
        AuthenticationRequest $client,
        AuthorizedChalleges $keypass,
        string $user,
        string $tenant,
        string $issuer,
        string $csid,
        string $state,
        string $nonce
    ): string {
        $url = $this->context->getBaseUrl() . '/oauth/openid/' . $tenant . '/authorize?'
            . 'client_id=' . urlencode($client->client->id)
            . '&scope=' . urlencode($client->scope)
            . '&state=' . urlencode($state)
            . '&nonce=' . urlencode($nonce)
            . '&audience=' . urlencode(implode(',', $client->audiences))
            . '&redirect_uri=' . urlencode($client->redirect)
            . '&response_type=' . urlencode($client->responseType)
            . '&step=recover-pass&recover_send=true';
        $this->userChpassGateway->requestForChange($url, $tenant, $user);
        return $url;
    }

    public function confirmPassChange(
        AuthenticationRequest $client,
        AuthorizedChalleges $keypass,
        string $code,
        string $newpass,
        string $tenant,
        string $issuer,
        string $csid,
        string $state,
        string $nonce
    ): PublicLoginAuthResponse {
        $user = $this->userChpassGateway->validateChangeRequest($tenant, $code, $newpass);
        if ($user) {
            $keypass->username = $user;
            return $this->preAutenticate($client, $keypass, $tenant, $issuer, $csid, $state, $nonce);
        } else {
            throw new LoginException(auth: AuthenticationResult::waitNewpass('', 'Unable to change to password: please retry'));
        }
    }

    public function validateForcePassChange(
        AuthenticationRequest $client,
        AuthorizedChalleges $keypass,
        string $oldpass,
        string $newpass,
        string $tenant,
        string $issuer,
        string $csid,
        string $state,
        string $nonce
    ): PublicLoginAuthResponse {
        if ($this->userChpassGateway->forceUpdatePassword($tenant, $keypass->username, $oldpass, $newpass)) {
            return $this->preAutenticate($client, $keypass, $tenant, $issuer, $csid, $state, $nonce);
        } else {
            throw new LoginException(auth: AuthenticationResult::newPasswordRequired('unable_to_change'));
        }
    }

    public function publicClientData(string $id, string $tenant, string $redirectUrl, string $scope): ?ClientData
    {
        return $this->clients->publicClientData($id, $tenant, $redirectUrl, $scope);
    }

    public function removeSesion(string $code): void
    {
        $this->session->deleteSession($code);
    }

    public function loadSession(string $code, string $nonce, string $state): ?PublicLoginSessionResponse
    {
        $session = $this->session->loadSession($code);
        if ($session) {
            // TODO: en bbdd metemos el withMFA
            return new PublicLoginSessionResponse(
                csid: $session->csid,
                issuer: $session->issuer,
                userId: $session->userId,
                clientId: $session->clientId,
                withMfa: $session->withMfa,
            );
        } else {
            return null;
        }
    }

    public function preAutenticate(
        AuthenticationRequest $request,
        AuthorizedChalleges $keypass,
        string $tenant,
        string $issuer,
        string $csid,
        string $state,
        string $nonce
    ): PublicLoginAuthResponse {
        return $this->saveIt(
            $this->userLoginGateway->fillPreAuthenticated($tenant, $request, $keypass),
            $request,
            $keypass,
            $keypass->username,
            $issuer,
            $csid,
            $state,
            $nonce
        );
    }

    public function autenticate(
        AuthenticationRequest $request,
        AuthorizedChalleges $keypass,
        string $tenant,
        string $username,
        string $password,
        string $issuer,
        string $csid,
        string $state,
        string $nonce
    ): PublicLoginAuthResponse {
        return $this->saveIt($this->userLoginGateway->validatedUserData($tenant, $username, $password, $request), $request, $keypass, $username, $issuer, $csid, $state, $nonce);
    }

    private function saveIt(
        AuthenticationResult $validation,
        AuthenticationRequest $request,
        AuthorizedChalleges $keypass,
        string $username,
        string $issuer,
        string $csid,
        string $state,
        string $nonce
    ): PublicLoginAuthResponse {
        if (!$validation->valid) {
            throw new LoginException($validation, $validation->error);
        }
        $session = Uuid::uuid4()->toString();
        $authData = [
            'aud' => $this->tokenAudiences($request->client->id, $validation->audiences ?? []),
            'azp' => $request->client->id,
            'iss' => $issuer,
            'sub' => $username,
            'tenant' => $validation->tenant,
            'tenant-name' => $validation->tenantName,
            'scope' => $validation->scope,
            'roles' => $validation->roles,
            'groups' => $validation->groups
        ];
        $idData = [
            'typ' => 'ID',
            'nonce' => $nonce,
            'session_state' => $session,
            's_hash' => self::generateHash($state),
        ];
        $sessionId = Uuid::uuid4()->toString();
        $sessionExpiration = new DateInterval("P15D");

        $this->session->saveSession($sessionId, $request->client, $issuer, $keypass, $validation, $csid, $sessionExpiration);

        return new PublicLoginAuthResponse(
            tenant: $validation->tenant,
            manager: $this->manager,
            authData: $authData,
            authExpiration: new DateInterval("PT10M"),
            idData: $idData,
            idExpiration: new DateInterval("PT10M"),
            sessionId: $sessionId,
            sessionExpiration: $sessionExpiration
        );
    }

    private function tokenAudiences($clientId, $audiences)
    {
        return array_values(array_unique([$clientId, ...$audiences ?? []]));
    }

    public static function generateHash(string $value): string
    {
        // Obtener la instancia de SHA-256
        $hashedValue = hash('sha256', $value, true);

        // Tomar la primera mitad de los bytes resultantes
        $halfHashedValue = substr($hashedValue, 0, strlen($hashedValue) / 2);

        // Codificar la mitad del hash en base64url sin relleno
        $base64Url = rtrim(strtr(base64_encode($halfHashedValue), '+/', '-_'), '=');

        return $base64Url;
    }
}
