<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Features\Oidc\Authentication\Infrastructure\Driver\Html;

use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ServerRequestInterface;
use Civi\Lughauth\Features\Oidc\Authentication\Domain\AuthenticationRequest;
use Civi\Lughauth\Features\Oidc\Authentication\Domain\AuthenticationResult;
use Civi\Lughauth\Features\Oidc\Authentication\Domain\AuthorizedChalleges;
use Civi\Lughauth\Features\Oidc\User\Domain\PublicLoginAuthResponse;
use Civi\Lughauth\Features\Oidc\Authentication\Infrastructure\Driver\Html\Forms\ConsentForm;
use Civi\Lughauth\Features\Oidc\Authentication\Infrastructure\Driver\Html\Forms\DelegateForm;
use Civi\Lughauth\Features\Oidc\Authentication\Infrastructure\Driver\Html\Forms\LoginForm;
use Civi\Lughauth\Features\Oidc\Authentication\Infrastructure\Driver\Html\Forms\NewMfaForm;
use Civi\Lughauth\Features\Oidc\Authentication\Infrastructure\Driver\Html\Forms\NewPassForm;
use Civi\Lughauth\Features\Oidc\Authentication\Infrastructure\Driver\Html\Forms\RecoverPassForm;
use Civi\Lughauth\Features\Oidc\Authentication\Infrastructure\Driver\Html\Forms\UseMfaForm;
use Civi\Lughauth\Features\Oidc\Authentication\Infrastructure\Driver\Html\Services\DecorateHtml;
use Civi\Lughauth\Features\Oidc\Authentication\Infrastructure\Driver\Html\Services\HtmlSecurer;
use Civi\Lughauth\Features\Oidc\Authentication\Infrastructure\Driver\Html\Services\PublicLogin;
use Civi\Lughauth\Features\Oidc\Authentication\Domain\Exception\LoginException;
use Civi\Lughauth\Features\Oidc\Authentication\Infrastructure\Driver\Html\Forms\RegisterUserForm;
use Civi\Lughauth\Features\Oidc\Client\Domain\ClientData;
use Civi\Lughauth\Features\Oidc\Key\Domain\KeysManagerService;
use Civi\Lughauth\Features\Oidc\Session\Domain\Gateway\TemporalKeysGateway;
use Civi\Lughauth\Features\Oidc\Session\Domain\TemporalAuthCode;
use Civi\Lughauth\Shared\Context;
use Civi\Lughauth\Shared\Infrastructure\Http\Cookie;
use Civi\Lughauth\Shared\Exception\UnauthorizedException;

class AuthorizeHtml
{
    private readonly array $forms;
    private readonly string $base;

    public function __construct(
        private readonly Context $context,
        private readonly PublicLogin $publicLogin,
        private readonly HtmlSecurer $securer,
        private readonly DecorateHtml  $decorator,
        private readonly KeysManagerService  $keys,
        private readonly TemporalKeysGateway $temporals,
        ConsentForm $conset,
        LoginForm $login,
        NewMfaForm $mfa,
        NewPassForm $pass,
        UseMfaForm $useMfa,
        RecoverPassForm $recover,
        DelegateForm $delegate,
        RegisterUserForm $register,
    ) {
        $this->base = $this->context->getBaseUrl() . '/oauth';
        $this->forms = [$conset, $login, $mfa, $pass, $useMfa, $recover, $register, $delegate ];
    }

    public function authorize(ServerRequestInterface $request, ResponseInterface $response, array $args): ResponseInterface
    {
        $base = $this->base;
        $tenant = $args['tenant'];
        $query = $request->getQueryParams();
        $responseType = $query['response_type'];
        $clientId = $query['client_id'];
        $state = $query['state'];
        $redirect = $query['redirect_uri'];
        $scope = $query['scope'];
        $nonce = $query['nonce'];
        $audiences = $query['audience'] ?? '';
        $prompt = $query['prompt'] ?? '';
        $cookies = $request->getCookieParams();
        $session = $cookies['AUTH_SESSION_ID'] ?? '';
        $locale = $request->getHeader('accept-language')[0];

        // Public login interface => client allowed
        // Session => direct login
        $this->verifyClient($clientId, $tenant, $redirect, $scope);
        $sess = $this->publicLogin->loadSession($session, $nonce, $state);
        if ($sess) {
            return $this->cisdPage($request, $response, $tenant, $base, $locale, $responseType, $clientId, $state, $redirect, $scope, $nonce, $audiences, $prompt);
        } elseif ("none" === $prompt) {
            return $this->redirectError($base, $tenant, $redirect, 'No session', $response);
        } else {
            return $this->paint(null, $locale, $base, $tenant, null, [], null, $request, $response);
        }
    }

    public function refresh(ServerRequestInterface $request, ResponseInterface $response, array $args): ResponseInterface
    {
        $body = $request->getParsedBody();
        $base = $this->base;
        $tenant = $args['tenant'];
        $query = $request->getQueryParams();
        $responseType = $query['response_type'];
        $clientId = $query['client_id'];
        $state = $query['state'];
        $redirect = $query['redirect_uri'];
        $scope = $query['scope'];
        $nonce = $query['nonce'];
        $audiences = $query['audience'] ?? '';
        $cookies = $request->getCookieParams();
        $session = $cookies['AUTH_SESSION_ID'];
        $locale = $request->getHeader('accept-language')[0];

        $client = $this->verifyClient($clientId, $tenant, $redirect, $scope);
        $csid = $this->securer->verifyToken($body['csid']);
        if (!$csid) {
            throw new UnauthorizedException();
        }
        $sess = $this->publicLogin->loadSession($session, $nonce, $state);
        if ($sess) {
            if ($csid !== $sess->csid) {
                // FIXME: go to login...
                throw new UnauthorizedException('Only refresh from same server');
            }
            $authRequest = new AuthenticationRequest(client: $client, scope: $scope, redirect: $redirect, responseType: $responseType, audiences: array_values(array_unique([$clientId, ...$audiences ? explode(',', $audiences) : []])));
            $challenges = new AuthorizedChalleges();
            $challenges->username = $sess->userId;
            $challenges->mfa = $sess->withMfa;
            $challenges->session = true;
            $issuer = $base . '/openid/' . $tenant;
            // auth-csid
            $auth = $this->publicLogin->preAutenticate($authRequest, $challenges, $tenant, $issuer, $csid, $state, $nonce);
            return $this->redirectOk($base, $tenant, $responseType, $redirect, $state, $nonce, $auth, $response, $client, $authRequest);
        } else {
            return $this->redirectError($base, $tenant, $redirect, 'No session', $response);
        }
    }

    public function formAuthorize(ServerRequestInterface $request, ResponseInterface $response, array $args): ResponseInterface
    {
        $body = $request->getParsedBody();
        $base = $this->base;
        $tenant = $args['tenant'];
        $query = $request->getQueryParams();
        $responseType = $query['response_type'];
        $clientId = $query['client_id'];
        $state = $query['state'];
        $redirect = $query['redirect_uri'];
        $scope = $query['scope'];
        $nonce = $query['nonce'];
        $audiences = $query['audience'] ?? '';
        $cookies = $request->getCookieParams();
        $preSession = $cookies['PRE_SESSION_ID'] ?? '';
        $locale = $request->getHeader('accept-language')[0];
        $client = $this->verifyClient($clientId, $tenant, $redirect, $scope);
        $clientRequest = new AuthenticationRequest(client: $client, scope: $scope, redirect: $redirect, responseType: $responseType, audiences: array_values(array_unique([$clientId, ...$audiences ? explode(',', $audiences) : []])));
        $challenges = new AuthorizedChalleges();
        if ($preSession) {
            $keypass = (array) $this->keys->verifiedKeypass($tenant, $preSession);
            $challenges->decode((array) $keypass['challenges'] ?? []);
        }
        $step = $body['step'] ?? '';
        try {
            $issuer = $base . '/openid/' . $tenant;
            // Tengo que sacar la password de fuera
            if (isset($body['csid'])) {
                $csid = $this->securer->verifyToken($body['csid']);
                if (!$csid) {
                    throw new UnauthorizedException('missingin_csid');
                }
                $auth = null;
                foreach ($this->forms as $form) {
                    if ($step == $form->step()) {
                        $auth = $form->autenticate($clientRequest, $tenant, $issuer, $csid ?? null, $state, $nonce, $challenges, $body);
                        break;
                    }
                }
                if (!$auth) {
                    // loger no form
                    throw new UnauthorizedException();
                }
                return $this->redirectOk($base, $tenant, $responseType, $redirect, $state, $nonce, $auth, $response, $client, $clientRequest);
            } elseif (!$step) {
                return $this->paint(null, $locale, $base, $tenant, null, [], null, $request, $response);
            } else {
                $result = null;
                foreach ($this->forms as $form) {
                    if ($step == $form->step()) {
                        $result = $form->paint(null, $locale, $base, $tenant, $challenges ?? new AuthorizedChalleges(), $body ?? [], $request, $response);
                        break;
                    }
                }
                if (!$result) {
                    throw new UnauthorizedException();
                }
                return $result;
            }
        } catch (LoginException $ex) {
            $response = $this->paint($ex->getMessage(), $locale, $base, $tenant, $challenges, $body, $ex->auth, $request, $response);
            $cookie = $this->storePreSession($base, $tenant, $challenges);
            return $cookie->attach($response);
        } catch (UnauthorizedException $ex) {
            $response = $this->paint($ex->getMessage(), $locale, $base, $tenant, $challenges, $body, null, $request, $response);
            $cookie = $this->storePreSession($base, $tenant, $challenges);
            return $cookie->attach($response);
        }
    }

    private function verifyClient(string $clientId, string $tenant, string $redirect, string $scope): ClientData
    {
        $client = $this->publicLogin->publicClientData($clientId, $tenant, $redirect, $scope);
        if (!$client) {
            throw new UnauthorizedException('Client not allowed');
        } else {
            return $client;
        }
    }

    private function redirectError(string $base, string $tenant, string $redirect, string $error, ResponseInterface $response): ResponseInterface
    {
        $response = $response->withStatus(302)->withHeader('Location', $redirect . '#error=' . urlencode($error));
        return $this->clearSession($response, $base, $tenant);
    }

    private function redirectOk(
        string $base,
        string $tenant,
        string $responseType,
        string $redirect,
        string $state,
        string $nonce,
        PublicLoginAuthResponse $auth,
        ResponseInterface $response,
        ClientData $client,
        AuthenticationRequest $authRequest
    ): ResponseInterface {
        $cookie = new Cookie(
            name: 'AUTH_SESSION_ID',
            value: $auth->getSessionId(),
            path: $base . '/openid/' . $tenant . '/',
            secure: false,
            sameSite: true,
            httpOnly: true,
            expiration: $auth->getSessionExpiration()
        );
        $location = $redirect;
        $hasCode =  $this->hasResponse($responseType, 'code');
        if ($hasCode) {
            $location .= '?state=' . $state ;
            $data = new TemporalAuthCode(
                data: $auth->asAuthenticationResult(),
                client: $client,
                nonce: $nonce,
                request: $authRequest
            );
            $location .= '&code=' . $this->temporals->registerTemporalAuthCode($data);
        } else {
            $location .= '#state=' . $state . '&nonce=' . $nonce;
        }
        $hasId = $this->hasResponse($responseType, 'id_token');
        $hasAccess = $this->hasResponse($responseType, 'token');
        if ($hasId) {
            $location .= '&id_token=' . $auth->withIdToken($hasAccess);
        }
        if ($hasAccess) {
            $now = new \DateTimeImmutable();
            $until = $now->add($auth->getAccessExpiration());

            $location .= '&access_token=' . $auth->withAccessToken();
            $location .= '&expires_in=' . ($until->getTimestamp() - $now->getTimestamp());
        }
        $response = $response->withStatus(302)->withHeader('Location', $location);
        return $cookie->attach($response);
    }

    private function paint(?string $message, string $locale, string $base, string $tenant, ?AuthorizedChalleges $challenges, ?array $body, ?AuthenticationResult $error, ServerRequestInterface $request, ResponseInterface $response): ResponseInterface
    {
        $result = null;
        $params = $request->getQueryParams();
        foreach ($this->forms as $form) {
            $handle = isset($params['step']) && $error == null ? $form->step() === $params['step'] : $form->handle($error);
            if ($handle) {
                $error = !$error && $message ? new AuthenticationResult(valid: false, errorMessage: $message) : $error;
                $result = $form->paint($error, $locale, $base, $tenant, $challenges ?? new AuthorizedChalleges(), $body ?? [], $request, $response);
                break;
            }
        }
        if (!$result) {
            throw new UnauthorizedException();
        }
        return $this->clearSession($result, $base, $tenant);
    }

    private function clearSession(ResponseInterface $response, string $base, string $tenant): ResponseInterface
    {
        $authCookie = new Cookie(name: 'AUTH_SESSION_ID', path: $base . '/openid/' . $tenant . '/');
        $preCookie = new Cookie(name: 'PRE_SESSION_ID', path: $base . '/openid/' . $tenant . '/');
        return $preCookie->remove($authCookie->remove($response));
    }

    private function storePreSession(string $base, string $tenant, AuthorizedChalleges $challenges): Cookie
    {
        $duration = new \DateInterval("PT10M");
        $text = $this->keys->signKeypass($tenant, ['challenges' => $challenges->encode()], $duration);
        return new Cookie(
            name: 'PRE_SESSION_ID',
            value: $text,
            path: $base . '/openid/' . $tenant . '/',
            expiration: $duration,
            secure: false,
            sameSite: true,
            httpOnly: true
        );
    }

    private function hasResponse($response_type, $token)
    {
        return preg_match('/(?<=^|\s)' . $token . '(?=\s|$)/', $response_type);
    }

    private function cisdPage(
        RequestInterface $request,
        ResponseInterface $response,
        string $tenant,
        string $base,
        string $locale,
        string $responseType,
        string $clientId,
        string $state,
        string $redirect,
        string $scope,
        string $nonce,
        string $audiences,
        string $prompt,
    ) {
        $js = $this->securer->configureScripts([
            $this->securer->addSign("sign"),
            $this->securer->autoSubmit("refresh")
        ]);
        $url = $base."/openid/".$tenant. "/check-session"
            . "?response_type=".urlencode($responseType)
            . "&client_id=".urlencode($clientId)
            . "&state=".urlencode($state)
            . "&redirect_uri=".urlencode($redirect)
            . "&scope=".urlencode($scope)
            . "&nonce=".urlencode($nonce)
            . "&audience=".urlencode($audiences)
            . "&prompt=".urlencode($prompt)
        ;
        $response->getBody()->write($this->decorator->getFullPage($request, 'Mfa', $js . "<h1>Verifiy login source...</h1>"
            . "<form id=\"refresh\" action=\"".$url."\" method=\"POST\">"
            . "<input type=\"hidden\" name=\"csid\" id=\"sign\" />"
            . "<input type=\"submit\" />"
            . "</form>", $locale));
        return $response;
    }
}
