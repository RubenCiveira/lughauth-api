<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Features\Oidc\User\Infrastructure\Driven;

use Override;
use DateInterval;
use DateTimeImmutable;
use Civi\Lughauth\Shared\Value\Random;
use Civi\Lughauth\Shared\Security\AesCypherService;
use Civi\Lughauth\Shared\Observability\LoggerAwareTrait;
use Civi\Lughauth\Features\Access\User\Domain\User;
use Civi\Lughauth\Features\Access\Tenant\Domain\Tenant;
use Civi\Lughauth\Features\Access\User\Domain\Gateway\UserReadGateway;
use Civi\Lughauth\Features\Access\Tenant\Domain\Gateway\TenantReadGateway;
use Civi\Lughauth\Features\Access\TenantTermsOfUse\Domain\Gateway\TenantTermsOfUseReadGateway;
use Civi\Lughauth\Features\Access\TrustedClient\Domain\Gateway\TrustedClientReadGateway;
use Civi\Lughauth\Features\Access\UserAccessTemporalCode\Domain\Gateway\UserAccessTemporalCodeFilter;
use Civi\Lughauth\Features\Access\UserAccessTemporalCode\Domain\Gateway\UserAccessTemporalCodeWriteGateway;
use Civi\Lughauth\Features\Access\UserAccessTemporalCode\Domain\UserAccessTemporalCode;
use Civi\Lughauth\Features\Access\UserAccessTemporalCode\Domain\UserAccessTemporalCodeAttributes;
use Civi\Lughauth\Features\Access\UserIdentity\Domain\Gateway\UserIdentityFilter;
use Civi\Lughauth\Features\Access\UserIdentity\Domain\Gateway\UserIdentityReadGateway;
use Civi\Lughauth\Features\Access\Role\Domain\Gateway\RoleReadGateway;
use Civi\Lughauth\Features\Access\RelyingParty\Domain\Gateway\RelyingPartyReadGateway;
use Civi\Lughauth\Features\Access\TenantConfig\Domain\Gateway\TenantConfigReadGateway;
use Civi\Lughauth\Features\Access\User\Domain\Gateway\UserWriteGateway;
use Civi\Lughauth\Features\Oidc\Authentication\Domain\AuthenticationRequest;
use Civi\Lughauth\Features\Oidc\Authentication\Domain\AuthenticationResult;
use Civi\Lughauth\Features\Oidc\Authentication\Domain\AuthorizedChalleges;
use Civi\Lughauth\Features\Oidc\Authentication\Domain\Exception\LoginException;
use Civi\Lughauth\Features\Oidc\User\Domain\Gateway\LoginRepository;

class LoginAdapter implements LoginRepository
{
    use LoggerAwareTrait;

    public function __construct(
        private readonly AesCypherService $cypher,
        private readonly TenantReadGateway $tenants,
        private readonly TenantConfigReadGateway $configs,
        private readonly TenantTermsOfUseReadGateway $terms,
        private readonly UserIdentityReadGateway $identities,
        private readonly TrustedClientReadGateway $clients,
        private readonly RelyingPartyReadGateway $parties,
        private readonly UserReadGateway $users,
        private readonly UserWriteGateway $writeUsers,
        private readonly RoleReadGateway $roles,
        private readonly UserAccessTemporalCodeWriteGateway $codeWriter
    ) {
    }
    #[Override]
    public function fillPreAuthenticated(
        string $tenant,
        AuthenticationRequest $client,
        AuthorizedChalleges $challenges
    ): AuthenticationResult {
        if ($challenges->username === 'jose') {
            // return AuthenticationResult::notAllowedAccess($tenant, '');
            return AuthenticationResult::unknowUser($tenant, $challenges->username);
        } else {
            $loadRoles = 'main' == $tenant ? ['ROOT'] : ['rol-1'];
            $roles = [];
            if ($client->audiences) {
                foreach ($client->audiences as $audience) {
                    $roles[$audience] = $loadRoles;
                }
            } else {
                $roles = $loadRoles;
            }
            return new AuthenticationResult(
                valid: true,
                id: $challenges->username,
                tenant: $tenant,
                tenantName: 'tenantName',
                scope: $client->scope,
                audiences: $client->audiences,
                roles: $roles,
                groups: ['group-1']
            );
        }
    }

    #[Override]
    public function validatedUserData(
        string $tenant,
        string $username,
        string $password,
        AuthenticationRequest $client
    ): AuthenticationResult {
        $theTenant = $this->checkTenant($tenant, $username);
        $theUser = $this->checkUser($theTenant, $username);
        $this->checkPassword($theTenant, $theUser, $password);
        if ($temp = $this->checkTemporalPassword($theTenant, $theUser)) {
            return $temp;
        }
        if ($reqMfa = $this->checkMfaConfigurationRequired($theTenant, $theUser)) {
            return $reqMfa;
        }
        if ($mfa = $this->checkMfa($theTenant, $theUser)) {
            return $mfa;
        }
        if ($terms = $this->checkTerms($theTenant, $theUser)) {
            return $terms;
        }
        $this->markLoginOk($theUser);
        return new AuthenticationResult(
            valid: true,
            id: $username,
            tenant: $theTenant->uid(),
            tenantName: $theTenant->getName(),
            scope: $client->scope,
            audiences: $client->audiences,
            roles: $this->loadRoles($client, $theTenant, $theUser),
            groups: $this->loadGroups($client, $theTenant, $theUser),
        );
    }

    private function checkTenant(string $tenant, string $username): Tenant
    {
        $result = $this->tenants->findOneByName($tenant);
        if (!$result) {
            $this->inexistentTenant($tenant);
            throw new LoginException(auth: AuthenticationResult::unknowUser($tenant, $username));
        }
        if (!$result->getEnabled()) {
            $this->disabledTenant($tenant);
            throw new LoginException(auth: AuthenticationResult::unknowUser($tenant, $username));
        }
        return $result;
    }

    private function checkUser(Tenant $tenant, string $username): User
    {
        $theUser = $this->users->findOneByTenantAndName($tenant, $username);
        if (!$theUser) {
            $this->inexistentUser($tenant->getName(), $username);
            throw new LoginException(auth: AuthenticationResult::unknowUser($tenant->getName(), $username));
        }
        if (!$theUser->getEnabled()) {
            $this->disabledUser($tenant->getName(), $username);
            throw new LoginException(auth: AuthenticationResult::unknowUser($tenant->getName(), $username));
        }
        if ($blocked = $theUser->getBlockedUntil()) {
            if ($blocked > new DateTimeImmutable()) {
                $this->blockedUser($tenant->getName(), $username);
                throw new LoginException(auth: AuthenticationResult::unknowUser($tenant->getName(), $username));
            }
        }

        return $theUser;
    }

    private function checkPassword(Tenant $tenant, User $user, string $password)
    {
        if ($user->getPlainPassword($this->cypher) !== $password) {
            $this->markLoginFail($user);
            throw new LoginException(auth: AuthenticationResult::wrongCredentials($tenant?->getName() ?? 'main', $user->getName()));
        }
    }

    private function checkTemporalPassword(Tenant $tenant, User $user): ?AuthenticationResult
    {
        return $user->getTemporalPassword() ? AuthenticationResult::newPasswordRequired() : null;
    }

    private function checkTerms(Tenant $tenant, User $user): ?AuthenticationResult
    {
        // $this->terms->findOneByUid();
        return null;
    }

    private function checkMfaConfigurationRequired(Tenant $tenant, User $user): ?AuthenticationResult
    {
        if ($user->getSecondFactorSeed()) {
            return null;
        }
        $conf = $this->configs->findOneByTenant($tenant);
        return ($conf && $conf->getForceMfa()) ? AuthenticationResult::newMfaRequired() : null;
    }

    private function checkMfa(Tenant $tenant, User $user): ?AuthenticationResult
    {
        return ($user->getSecondFactorSeed() && $user->getUseSecondFactors()) ? AuthenticationResult::mfaRequired() : null;
    }

    private function markLoginFail(User $user)
    {
        $this->markLogin($user, true);
    }

    private function markLoginOk(User $user)
    {
        $this->markLogin($user, false);
    }

    private function markLogin(User $user, bool $fail)
    {
        $limit = 3;

        $filter = new UserAccessTemporalCodeFilter(
            user: $user
        );
        $code = $this->codeWriter->retrieveForUpdate($filter);
        if (!$code) {
            $atts = new UserAccessTemporalCodeAttributes();
            $atts->uid(Random::comb());
            $atts->user($user);
            $code = $this->codeWriter->create(UserAccessTemporalCode::create($atts));
        }
        $atts = $code->toAttributes();
        if ($fail) {
            if ($code->getFailedLoginAttempts() >= $limit) {
                $this->writeUsers->update($user, $user->block((new DateTimeImmutable())->add(new DateInterval("PT6H"))));
                $this->codeWriter->update($code, $code->markLoginBlock());
            } else {
                $this->codeWriter->update($code, $code->markLoginFail());
            }
        } else {
            $this->codeWriter->update($code, $code->markLoginOk());
        }
    }

    private function loadRoles(AuthenticationRequest $client, Tenant $tenant, User $user): array
    {
        $roles = [];
        // Tengo roles para cualquier audiencia
        $forAll = [];
        $this->rolesFromIdentity(new UserIdentityFilter(user: $user)->withForAllAudiences(true), $forAll);
        if ($client->audiences) {
            foreach ($client->audiences as $audience) {
                $roles[$audience] = [...$forAll];
                if ($client = $this->clients->findOneByCode($audience)) {
                    $this->rolesFromIdentity(new UserIdentityFilter(
                        user: $user,
                        trustedClient: $client
                    ), $roles[$audience]);
                }
                if ($party = $this->parties->findOneByCode($audience)) {
                    $this->rolesFromIdentity(new UserIdentityFilter(
                        user: $user,
                        relyingParty: $party
                    ), $roles[$audience]);
                }
            }
        }
        return $roles;
    }

    private function rolesFromIdentity(UserIdentityFilter $identityFilter, &$roles)
    {
        if ($tc = $this->identities->retrieve($identityFilter)) {
            foreach ($tc->getRoles() as $role) {
                $ref = $role->getRole();
                $theRole = $this->roles->enrich($ref);
                if ($theRole) {
                    $roles[] = $theRole->getName();
                }
            }
        }
    }

    private function loadGroups(AuthenticationRequest $client, Tenant $tenant, User $user): array
    {
        return [];
    }

    private function loadScopes(AuthenticationRequest $client, Tenant $tenant, User $user): ?string
    {
        return $client->scope;
    }
    private function loadAudiences(AuthenticationRequest $client, Tenant $tenant, User $user): array
    {
        return $client->audiences;
    }

    private function disabledTenant(string $tenant)
    {
        $this->logError('Try login on a disabled tenant', ['tenant-name' => $tenant]);
    }

    private function inexistentTenant(string $tenant)
    {
        $this->logError('Try login on an inexistent tenant', ['tenant-name' => $tenant]);
    }

    private function inexistentUser(string $tenant, string $user)
    {
        $this->logError('Try login on an inexistent user on a tenant', ['tenant-name' => $tenant, 'user-name' => $user]);
    }

    private function disabledUser(string $tenant, string $user)
    {
        $this->logError('Try login with a disabled user on a tenant', ['tenant-name' => $tenant, 'user-name' => $user]);
    }

    private function blockedUser(string $tenant, string $user)
    {
        $this->logError('Try login with a blocked user on a tenant', ['tenant-name' => $tenant, 'user-name' => $user]);
    }

}
