<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Features\Oidc\User\Infrastructure\Driven;

use Override;
use DateInterval;
use DateTimeImmutable;
use Civi\Lughauth\Shared\Security\AesCypherService;
use Civi\Lughauth\Shared\Observability\LoggerAwareTrait;
use Civi\Lughauth\Features\Access\User\Domain\User;
use Civi\Lughauth\Features\Access\Tenant\Domain\Tenant;
use Civi\Lughauth\Features\Access\TrustedClient\Domain\Gateway\TrustedClientReadGateway;
use Civi\Lughauth\Features\Access\UserIdentity\Domain\Gateway\UserIdentityFilter;
use Civi\Lughauth\Features\Access\UserIdentity\Domain\Gateway\UserIdentityReadGateway;
use Civi\Lughauth\Features\Access\Role\Domain\Gateway\RoleReadGateway;
use Civi\Lughauth\Features\Access\RelyingParty\Domain\Gateway\RelyingPartyReadGateway;
use Civi\Lughauth\Features\Access\TenantConfig\Domain\Gateway\TenantConfigReadGateway;
use Civi\Lughauth\Features\Access\User\Domain\Gateway\UserWriteGateway;
use Civi\Lughauth\Features\Access\UserAcceptedTermnsOfUse\Domain\Gateway\UserAcceptedTermnsOfUseReadGateway;
use Civi\Lughauth\Features\Oidc\Authentication\Domain\AuthenticationRequest;
use Civi\Lughauth\Features\Oidc\Authentication\Domain\AuthenticationResult;
use Civi\Lughauth\Features\Oidc\Authentication\Domain\AuthorizedChalleges;
use Civi\Lughauth\Features\Oidc\Authentication\Domain\Exception\LoginException;
use Civi\Lughauth\Features\Oidc\Common\Infrastructure\Driven\UserLoaderAdapter;
use Civi\Lughauth\Features\Oidc\User\Domain\Gateway\LoginRepository;

class LoginAdapter implements LoginRepository
{
    use LoggerAwareTrait;

    public function __construct(
        private readonly AesCypherService $cypher,
        private readonly UserLoaderAdapter $users,
        private readonly TenantConfigReadGateway $configs,
        private readonly UserAcceptedTermnsOfUseReadGateway $userTerms,
        private readonly UserIdentityReadGateway $identities,
        private readonly TrustedClientReadGateway $clients,
        private readonly RelyingPartyReadGateway $parties,
        private readonly UserWriteGateway $writeUsers,
        private readonly RoleReadGateway $roles,
    ) {
    }
    #[Override]
    public function fillPreAuthenticated(
        string $tenant,
        AuthenticationRequest $client,
        AuthorizedChalleges $challenges
    ): AuthenticationResult {
        $theTenant = $this->users->checkTenant($tenant, $challenges->username);
        $theUser = $this->users->checkUser($theTenant, $challenges->username);
        return new AuthenticationResult(
            valid: true,
            id: $challenges->username,
            tenant: $theTenant->uid(),
            tenantName: $theTenant->getName(),
            scope: $client->scope,
            audiences: $client->audiences,
            roles: $this->loadRoles($client, $theTenant, $theUser),
            groups: $this->loadGroups($client, $theTenant, $theUser),
        );
    }

    #[Override]
    public function validatedUserData(
        string $tenant,
        string $username,
        string $password,
        AuthenticationRequest $client
    ): AuthenticationResult {
        $theTenant = $this->users->checkTenant($tenant, $username);
        $theUser = $this->users->checkUser($theTenant, $username);
        $this->checkPassword($theTenant, $theUser, $password);
        if ($temp = $this->checkTemporalPassword($theTenant, $theUser)) {
            return $temp;
        }
        if ($reqMfa = $this->checkMfaConfigurationRequired($theTenant, $theUser)) {
            return $reqMfa;
        }
        if ($mfa = $this->checkMfa($theTenant, $theUser)) {
            return $mfa;
        }
        if ($terms = $this->checkTerms($theTenant, $theUser)) {
            return $terms;
        }
        $this->markLoginOk($theUser);
        return new AuthenticationResult(
            valid: true,
            id: $username,
            tenant: $theTenant->uid(),
            tenantName: $theTenant->getName(),
            scope: $client->scope,
            audiences: $client->audiences,
            roles: $this->loadRoles($client, $theTenant, $theUser),
            groups: $this->loadGroups($client, $theTenant, $theUser),
        );
    }

    private function checkPassword(Tenant $tenant, User $user, string $password)
    {
        if ($user->getPlainPassword($this->cypher) !== $password) {
            $this->markLoginFail($user);
            throw new LoginException(auth: AuthenticationResult::wrongCredentials($tenant?->getName() ?? 'main', $user->getName()));
        }
    }

    private function checkTemporalPassword(Tenant $tenant, User $user): ?AuthenticationResult
    {
        return $user->getTemporalPassword() ? AuthenticationResult::newPasswordRequired() : null;
    }

    private function checkTerms(Tenant $tenant, User $user): ?AuthenticationResult
    {
        if ($terms = $this->users->loadTenantTerms($tenant)) {
            $accepted = $this->userTerms->findOneByUserAndConditions($user, $terms);
            return $accepted ? null : AuthenticationResult::consentRequired($terms->getText());
        }
        return null;
    }

    private function checkMfaConfigurationRequired(Tenant $tenant, User $user): ?AuthenticationResult
    {
        if ($user->getSecondFactorSeed()) {
            return null;
        }
        if ($user->getUseSecondFactors()) {
            return AuthenticationResult::newMfaRequired();
        }
        $conf = $this->configs->findOneByTenant($tenant);
        return ($conf && $conf->getForceMfa()) ? AuthenticationResult::newMfaRequired() : null;
    }

    private function checkMfa(Tenant $tenant, User $user): ?AuthenticationResult
    {
        return ($user->getSecondFactorSeed() && $user->getUseSecondFactors()) ? AuthenticationResult::mfaRequired() : null;
    }

    private function markLoginFail(User $user)
    {
        $this->markLogin($user, true);
    }

    private function markLoginOk(User $user)
    {
        $this->markLogin($user, false);
    }

    private function markLogin(User $user, bool $fail)
    {
        $limit = 3;
        $code = $this->users->userCodeForUpdate($user);
        if ($fail) {
            if ($code->getFailedLoginAttempts() >= $limit) {
                $this->writeUsers->update($user, $user->block((new DateTimeImmutable())->add(new DateInterval("PT6H"))));
                $this->users->updateCode($code->markLoginBlock());
            } else {
                $this->users->updateCode($code->markLoginFail());
            }
        } else {
            $this->users->updateCode($code->markLoginOk());
        }
    }

    private function loadRoles(AuthenticationRequest $client, Tenant $tenant, User $user): array
    {
        $roles = [];
        // Tengo roles para cualquier audiencia
        $forAll = [];
        $this->rolesFromIdentity(new UserIdentityFilter(user: $user)->withForAllAudiences(true), $forAll);
        if ($client->audiences) {
            foreach ($client->audiences as $audience) {
                $roles[$audience] = [...$forAll];
                if ($client = $this->clients->findOneByCode($audience)) {
                    $this->rolesFromIdentity(new UserIdentityFilter(
                        user: $user,
                        trustedClient: $client
                    ), $roles[$audience]);
                }
                if ($party = $this->parties->findOneByCode($audience)) {
                    $this->rolesFromIdentity(new UserIdentityFilter(
                        user: $user,
                        relyingParty: $party
                    ), $roles[$audience]);
                }
            }
        }
        return $roles;
    }

    private function rolesFromIdentity(UserIdentityFilter $identityFilter, &$roles)
    {
        if ($tc = $this->identities->retrieve($identityFilter)) {
            foreach ($tc->getRoles() as $role) {
                $ref = $role->getRole();
                $theRole = $this->roles->resolve($ref);
                if ($theRole) {
                    $roles[] = $theRole->getName();
                }
            }
        }
    }

    private function loadGroups(AuthenticationRequest $client, Tenant $tenant, User $user): array
    {
        return [];
    }

    private function loadScopes(AuthenticationRequest $client, Tenant $tenant, User $user): ?string
    {
        return $client->scope;
    }
    private function loadAudiences(AuthenticationRequest $client, Tenant $tenant, User $user): array
    {
        return $client->audiences;
    }
}
