<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Features\Rbac\Acl\Application;

class DslParser
{
    public function parse(string $dsl): array
    {
        $tokens = $this->tokenize($dsl);
        $pos = 0;
        $roles = [];
        $resources = [];
        $matches = [];

        $current = function () use (&$tokens, &$pos) {
            return $tokens[$pos] ?? '';
        };
        $next = function () use (&$tokens, &$pos) {
            return $tokens[$pos++] ?? '';
        };
        $expect = function (string $expected) use (&$next) {
            $token = $next();
            if ($token !== $expected) {
                throw new \RuntimeException("Expected '$expected', got '$token'");
            }
        };

        while ($pos < count($tokens)) {
            $token = $current();
            if ($token === 'role') {
                $next();
                $role = $next();
                $expect('extends');
                $parents = [];
                do {
                    $parents[] = $next();
                } while ($current() === ',' && $next());
                $expect(';');
                $roles[$role]['inherits'] = $parents;
            } elseif ($token === 'resource') {
                $next();
                $res = $next();
                $expect('extends');
                $parent = $next();
                $expect(';');
                $resources[$res]['inherits'][] = $parent;
            } elseif ($token === 'match') {
                $next(); // skip 'match'
                $res = $next();
                $expect('{');

                $matchData = [];

                while ($current() !== '}') {
                    $section = $next();
                    $expect('{');

                    // Si viene directamente un 'allow', es una sección plana
                    if (in_array($current(), ['allow', 'deny'])) {
                        $rules = $this->parseRulesBlock($current, $next, $expect, $section);
                        $matchData[$section] = $rules;
                        $expect('}');
                        continue;
                    }

                    // Si vienen secciones internas como 'view', 'modify'...
                    while ($current() !== '}') {
                        $subsection = $next(); // ej. 'view', 'modify'
                        $expect('{');
                        $rules = $this->parseRulesBlock($current, $next, $expect, "$section:$subsection");
                        $expect('}');
                        $matchData["$section:$subsection"] = $rules;
                    }

                    $expect('}');
                }

                $expect('}');
                $matches[$res] = $matchData;
            } else {
                throw new \RuntimeException("Unexpected token: $token");
            }
        }

        return [
            'roles' => $roles,
            'resources' => $resources,
            'matches' => $matches,
        ];
    }

    private function parseRulesBlock(
        callable $current,
        callable $next,
        callable $expect,
        string $type
    ): array {
        $rules = [];

        while (!in_array($current(), ['}', ''])) {
            $effect = $next(); // allow / deny
            $items = [];
            while ($current() !== 'if') {
                $token = $next();
                if ($token !== ',') {
                    $items[] = $token;
                }
            }
            $expect('if');

            $condTokens = [];
            while (!in_array($current(), [';', '}'])) {
                if ($current() === '') {
                    throw new \RuntimeException("Unexpected end of input while parsing condition");
                }
                $condTokens[] = $next();
            }

            // Si el próximo token es ';', consumirlo.
            // Si es '}', permitirlo, pero dejarlo al parseador padre.
            if ($current() === ';') {
                $expect(';');
            }
            $rules[] = [
                'effect' => $effect,
                'type' => $type,
                'items' => $items,
                'condition' => $this->parseCondition($condTokens)
            ];
        }

        return $rules;
    }

    private function tokenize(string $input): array
    {
        $input = preg_replace('/([{}();,])/', ' $1 ', $input);
        return array_values(array_filter(preg_split('/\\s+/', trim($input))));
    }

    private function parseCondition(array $tokens): array
    {
        // Condición tipo flag: if @authenticated;
        if (count($tokens) === 1 && str_starts_with($tokens[0], '@')) {
            return ['flag' => $tokens[0]];
        }

        $lhs = array_shift($tokens);
        $op = array_shift($tokens);

        // Soporte para "not in"
        if ($op === 'not' && $tokens[0] === 'in') {
            array_shift($tokens); // remove 'in'
            array_shift($tokens); // remove '('
            $values = [];
            while ($tokens) {
                $val = array_shift($tokens);
                if ($val === ')') {
                    break;
                }
                if ($val !== ',') {
                    $values[] = trim($val, '"');
                }
            }
            return ['not_in' => [$lhs => $values]];
        }

        // Soporte para "in"
        if ($op === 'in') {
            array_shift($tokens); // remove '('
            $values = [];
            while ($tokens) {
                $val = array_shift($tokens);
                if ($val === ')') {
                    break;
                }
                if ($val !== ',') {
                    $values[] = trim($val, '"');
                }
            }
            return ['in' => [$lhs => $values]];
        }

        // Comparaciones == o !=
        if (in_array($op, ['==', '!='])) {
            $rhs = trim(array_shift($tokens), '"');
            return [$op => [$lhs => $rhs]];
        }

        throw new \RuntimeException("Unsupported condition operator: $op");
    }
}
