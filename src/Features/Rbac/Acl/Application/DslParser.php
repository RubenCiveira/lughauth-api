<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Features\Rbac\Acl\Application;

class DslParser
{
    public function parse(string $dsl): array
    {
        $tokens = $this->tokenize($dsl);
        $pos = 0;
        $roles = [];
        $resources = [];
        $matches = [];

        $current = fn() => $tokens[$pos] ?? '';
        $next = fn() => $tokens[$pos++] ?? '';
        $expect = function (string $expected) use (&$next) {
            $token = $next();
            if ($token !== $expected) {
                throw new \RuntimeException("Expected '$expected', got '$token'");
            }
        };

        while ($pos < count($tokens)) {
            $token = $current();
            if ($token === 'role') {
                $next(); $role = $next(); $expect('extends'); $parent = $next(); $expect(';');
                $roles[$role]['inherits'][] = $parent;
            } elseif ($token === 'resource') {
                $next(); $res = $next(); $expect('extends'); $parent = $next(); $expect(';');
                $resources[$res]['inherits'][] = $parent;
            } elseif ($token === 'match') {
                $next(); $res = $next(); $expect('{');
                $matchData = [];
                while ($current() !== '}') {
                    $section = $next(); $expect('{'); $rules = [];
                    while ($current() !== '}') {
                        $effect = $next(); $items = [];
                        while ($current() !== 'if') {
                            $token = $next(); if ($token !== ',') $items[] = $token;
                        }
                        $expect('if'); $condTokens = [];
                        while ($current() !== ';') $condTokens[] = $next();
                        $expect(';');
                        $rules[] = [
                            'effect' => $effect,
                            'type' => $section,
                            'items' => $items,
                            'condition' => $this->parseCondition($condTokens)
                        ];
                    }
                    $expect('}');
                    $matchData[$section] = $rules;
                }
                $expect('}');
                $matches[$res] = $matchData;
            } else {
                throw new \RuntimeException("Unexpected token: $token");
            }
        }

        return [
            'roles' => $roles,
            'resources' => $resources,
            'matches' => $matches,
        ];
    }

    private function tokenize(string $input): array
    {
        $input = preg_replace('/([{}();,])/', ' $1 ', $input);
        return array_values(array_filter(preg_split('/\s+/', trim($input))));
    }

    private function parseCondition(array $tokens): array
    {
        $lhs = array_shift($tokens);
        $op = array_shift($tokens);
        if ($op === 'in') {
            array_shift($tokens); // remove '('
            $values = [];
            while ($tokens) {
                $val = array_shift($tokens);
                if ($val === ')') break;
                if ($val !== ',') $values[] = trim($val, '"');
            }
            return ['in' => [$lhs => $values]];
        } elseif (in_array($op, ['==', '!='])) {
            $rhs = trim(array_shift($tokens), '"');
            return [$op => [$lhs => $rhs]];
        }
        throw new \RuntimeException("Unsupported condition operator: $op");
    }
}
