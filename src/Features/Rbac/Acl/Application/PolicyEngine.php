<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Features\Rbac\Acl\Application;

use Civi\Lughauth\Features\Rbac\Acl\Domain\RuleSet;
use Civi\Lughauth\Features\Rbac\Acl\Domain\MatchRule;

class PolicyEngine
{
    private array $roles = [];
    private RuleSet $ruleSet;
    private array $resources = [];

    public function setRoles(array $roles): void { $this->roles = $roles; }
    public function setRuleSet(RuleSet $ruleSet): void { $this->ruleSet = $ruleSet; }
    public function setResources(array $resources): void { $this->resources = $resources; }

    public function expand(): array
    {
        $result = [];

        foreach ($this->roles as $role) {
            $effectiveRoles = $this->getEffectiveRoles($role);

            foreach ($this->resources as $resource => $declared) {
                $resRules = $this->ruleSet->getResource($resource);
                if (!$resRules) continue;

                $viewable = [];
                $editable = [];

                foreach ($declared['attributes'] ?? [] as $field) {
                    $canView = $this->isAllowed(
                        $field,
                        $resRules->getAttributes(),
                        $effectiveRoles,
                        'attributes:view'
                    );

                    $canEdit = $this->isAllowed(
                        $field,
                        $resRules->getAttributes(),
                        $effectiveRoles,
                        'attributes:modify'
                    );

                    if ($canView) $viewable[] = $field;
                    if ($canView && $canEdit) $editable[] = $field;
                }

                $result[$role][$resource] = [
                    'hidden' => array_values(array_diff($declared['attributes'], $viewable)),
                    // 'readonly' => array_values(array_diff($declared['attributes'], $editable)),
                    'readonly' => array_values(array_diff($viewable, $editable)),
                ];
            }
        }

        return $result;
    }

    private function getEffectiveRoles(string $role): array
    {
        $r = $this->ruleSet->getRole($role);
        $all = [$role];
        if ($r) {
            foreach ($r->getInherits() as $parent) {
                $all = array_merge($all, $this->getEffectiveRoles($parent));
            }
        }
        return array_unique($all);
    }

    private function isAllowed(
        string $field,
        array $rules,
        array $roles,
        string $type
    ): bool {
        $matching = array_filter($rules, function (MatchRule $rule) use ($field, $roles, $type) {
            if ($rule->getType() !== $type) return false;
            if (!in_array($field, $rule->getItems(), true) && !in_array('*', $rule->getItems(), true)) {
                return false;
            }

            foreach ($roles as $r) {
                if ($rule->getCondition()->matches($r)) {
                    return true;
                }
            }
            return false;
        });

        if (empty($matching)) return false;

        $anyDeny = false;
        $allAllow = true;

        foreach ($matching as $rule) {
            foreach ($roles as $r) {
                if ($rule->getCondition()->matches($r)) {
                    if ($rule->getEffect() === 'deny') $anyDeny = true;
                    if ($rule->getEffect() !== 'allow') $allAllow = false;
                }
            }
        }

        return !$anyDeny && $allAllow;
    }
}
