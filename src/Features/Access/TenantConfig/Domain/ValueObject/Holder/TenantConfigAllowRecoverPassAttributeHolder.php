<?php

# @autogenerated
declare(strict_types=1);

namespace Civi\Lughauth\Features\Access\TenantConfig\Domain\ValueObject\Holder;

use Civi\Lughauth\Shared\Value\Validation\ConstraintFailList;
use Civi\Lughauth\Features\Access\TenantConfig\Domain\ValueObject\TenantConfigAllowRecoverPassVO;

trait TenantConfigAllowRecoverPassAttributeHolder
{
    protected TenantConfigAllowRecoverPassVO|bool|null $allowRecoverPass = null;
    protected bool $allowRecoverPassAssigned = false;

    public function getAllowRecoverPassOrDefault(?TenantConfigAllowRecoverPassVO $allowRecoverPass): ?TenantConfigAllowRecoverPassVO
    {
        return $this->allowRecoverPassAssigned ? ($this->allowRecoverPass !== null ? TenantConfigAllowRecoverPassVO::from($this->allowRecoverPass) : null) : $allowRecoverPass;
    }
    public function allowRecoverPass(TenantConfigAllowRecoverPassVO|bool|null $allowRecoverPass): static
    {
        $this->allowRecoverPass = $allowRecoverPass;
        $this->allowRecoverPassAssigned = true;
        return $this;
    }
    public function isAllowRecoverPass(): ?bool
    {
        return is_a($this->allowRecoverPass, TenantConfigAllowRecoverPassVO::class) ? $this->allowRecoverPass->value() : $this->allowRecoverPass;
    }
    public function unsetAllowRecoverPass(): static
    {
        $this->allowRecoverPass = null;
        $this->allowRecoverPassAssigned = false;
        return $this;
    }
    protected function withDefaultAllowRecoverPass(): void
    {
        if ($this->allowRecoverPass === null) {
            $this->allowRecoverPass = true;
        }
    }
    protected function withAssertedAllowRecoverPassRules(self $value, ConstraintFailList $errorsList): void
    {
        if ($value->allowRecoverPassAssigned = $this->allowRecoverPassAssigned) {
            $value->allowRecoverPass = TenantConfigAllowRecoverPassVO::tryFrom($this->allowRecoverPass, $errorsList);
        }
    }
}
