<?php

# @autogenerated
declare(strict_types=1);

namespace Civi\Lughauth\Features\Access\UserAccessTemporalCode\Infrastructure\Driven;

use Psr\EventDispatcher\EventDispatcherInterface;
use Closure;
use Override;
use Throwable;
use Civi\Lughauth\Features\Access\User\Domain\UserRef;
use Civi\Lughauth\Features\Access\UserAccessTemporalCode\Domain\Gateway\UserAccessTemporalCodeWriteRepository;
use Civi\Lughauth\Features\Access\UserAccessTemporalCode\Infrastructure\Connector\Pdo\UserAccessTemporalCodePdoConnector;
use Civi\Lughauth\Features\Access\UserAccessTemporalCode\Domain\Gateway\UserAccessTemporalCodeSlide;
use Civi\Lughauth\Features\Access\UserAccessTemporalCode\Domain\Gateway\UserAccessTemporalCodeCursor;
use Civi\Lughauth\Features\Access\UserAccessTemporalCode\Domain\Gateway\UserAccessTemporalCodeFilter;
use Civi\Lughauth\Features\Access\UserAccessTemporalCode\Domain\UserAccessTemporalCodeRef;
use Civi\Lughauth\Features\Access\UserAccessTemporalCode\Domain\UserAccessTemporalCode;
use Civi\Lughauth\Shared\Observability\LoggerAwareTrait;
use Civi\Lughauth\Shared\Observability\TracerAwareTrait;
use Civi\Lughauth\Shared\Infrastructure\EntityChangelog\EntityChangelogService;

class UserAccessTemporalCodeWriteRepositoryAdapter implements UserAccessTemporalCodeWriteRepository
{
    use LoggerAwareTrait;
    use TracerAwareTrait;

    public function __construct(
        private readonly UserAccessTemporalCodePdoConnector $conn,
        private readonly EventDispatcherInterface $dispacher,
        private readonly EntityChangelogService $changelog,
    ) {
    }
    #[Override]
    public function resolveForUpdate(UserAccessTemporalCodeRef $ref): ?UserAccessTemporalCode
    {
        return $this->conn->retrieveForUpdate(new UserAccessTemporalCodeFilter(uids: [ $ref->uid() ]));
    }
    #[Override]
    public function listForUpdate(?UserAccessTemporalCodeFilter $filter = null, ?UserAccessTemporalCodeCursor $sort = null): UserAccessTemporalCodeSlide
    {
        $this->logDebug("Count for User access temporal code on adapter ");
        $span = $this->startSpan("Count for User access temporal code on adapter");
        try {
            $values = $this->conn->listForUpdate($filter, $sort);
            $last = end($values);
            return new UserAccessTemporalCodeSlide(function ($slide, $next) use ($filter) {
                return $this->listForUpdate($filter, $next);
            }, new UserAccessTemporalCodeCursor($sort?->limit ?? 100, $last->uid ?? null), $values);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    #[Override]
    public function retrieveForUpdate(UserAccessTemporalCodeFilter $filter): ?UserAccessTemporalCode
    {
        $this->logDebug("Count for User access temporal code on adapter ");
        $span = $this->startSpan("Count for User access temporal code on adapter");
        try {
            return $this->conn->retrieveForUpdate($filter);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    #[Override]
    public function existsForUpdate(?UserAccessTemporalCodeFilter $filter): bool
    {
        $this->logDebug("Count for User access temporal code on adapter ");
        $span = $this->startSpan("Count for User access temporal code on adapter");
        try {
            return $this->conn->existsForUpdate($filter);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    #[Override]
    public function countForUpdate(?UserAccessTemporalCodeFilter $filter = null): int
    {
        $this->logDebug("Count for User access temporal code on adapter ");
        $span = $this->startSpan("Count for User access temporal code on adapter");
        try {
            return $this->conn->countForUpdate($filter);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    #[Override]
    public function create(UserAccessTemporalCode $entity, ?Closure $verify = null): UserAccessTemporalCode
    {
        $this->logDebug("Count for User access temporal code on adapter ");
        $span = $this->startSpan("Count for User access temporal code on adapter");
        try {
            $created = $this->conn->create($entity, $verify);
            $this->dispach($entity);
            $this->changelog->recordChange('user-access-temporal-code', $entity->uid(), $entity->asPublicJson(), []);
            return $created;
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    #[Override]
    public function update(UserAccessTemporalCodeRef $reference, UserAccessTemporalCode $entity): UserAccessTemporalCode
    {
        $this->logDebug("Count for User access temporal code on adapter ");
        $span = $this->startSpan("Count for User access temporal code on adapter");
        try {
            $updated = $this->conn->update($entity);
            $this->dispach($entity);
            $original = ($reference instanceof UserAccessTemporalCode) ? $reference : $this->conn->retrieve(new UserAccessTemporalCodeFilter(uids: [ $reference->uid() ]));
            $this->changelog->recordChange('user-access-temporal-code', $entity->uid(), $entity->asPublicJson(), $original->asPublicJson());
            return $updated;
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    #[Override]
    public function delete(UserAccessTemporalCode $entity): bool
    {
        $this->logDebug("Count for User access temporal code on adapter ");
        $span = $this->startSpan("Count for User access temporal code on adapter");
        try {
            $result = $this->conn->delete($entity);
            $this->dispach($entity);
            $this->changelog->recordDeletion('user-access-temporal-code', $entity->uid(), $entity->asPublicJson());
            return $result;
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    #[Override]
    public function findOneForUpdateByUid(string $uid): ?UserAccessTemporalCode
    {
        $this->logDebug("Find on by uid for User access temporal code on adapter");
        $span = $this->startSpan("Find on by uid for User access temporal code on adapter");
        try {
            return $this->conn->retrieveForUpdate(new UserAccessTemporalCodeFilter(uids: [$uid]));
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    #[Override]
    public function findOneForUpdateByUser(UserRef $user): ?UserAccessTemporalCode
    {
        $this->logDebug("Find on by user for User access temporal code on adapter");
        $span = $this->startSpan("Find on by user for User access temporal code on adapter");
        try {
            return $this->conn->retrieveForUpdate(new UserAccessTemporalCodeFilter(user: $user));
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    #[Override]
    public function findOneForUpdateByRegisterCode(?string $registerCode): ?UserAccessTemporalCode
    {
        $this->logDebug("Find on by register code for User access temporal code on adapter");
        $span = $this->startSpan("Find on by register code for User access temporal code on adapter");
        try {
            return $this->conn->retrieveForUpdate(new UserAccessTemporalCodeFilter(registerCode: $registerCode));
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    #[Override]
    public function findOneForUpdateByRecoveryCode(?string $recoveryCode): ?UserAccessTemporalCode
    {
        $this->logDebug("Find on by recovery code for User access temporal code on adapter");
        $span = $this->startSpan("Find on by recovery code for User access temporal code on adapter");
        try {
            return $this->conn->retrieveForUpdate(new UserAccessTemporalCodeFilter(recoveryCode: $recoveryCode));
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function dispach(UserAccessTemporalCode $entity)
    {
        $this->logDebug("Count for User access temporal code on adapter ");
        $span = $this->startSpan("Count for User access temporal code on adapter");
        try {
            foreach ($entity->getTheEvents() as $event) {
                $this->dispacher->dispatch($event);
            }
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
}
