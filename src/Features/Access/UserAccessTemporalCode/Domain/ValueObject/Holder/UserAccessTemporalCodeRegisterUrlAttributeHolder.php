<?php

# @autogenerated
declare(strict_types=1);

namespace Civi\Lughauth\Features\Access\UserAccessTemporalCode\Domain\ValueObject\Holder;

use Civi\Lughauth\Shared\Value\Validation\ConstraintFailList;
use Civi\Lughauth\Features\Access\UserAccessTemporalCode\Domain\ValueObject\UserAccessTemporalCodeRegisterUrlVO;

trait UserAccessTemporalCodeRegisterUrlAttributeHolder
{
    protected UserAccessTemporalCodeRegisterUrlVO|string|null $registerUrl = null;
    protected bool $registerUrlAssigned = false;

    public function getRegisterUrlOrDefault(?UserAccessTemporalCodeRegisterUrlVO $registerUrl): UserAccessTemporalCodeRegisterUrlVO|string|null
    {
        return $this->registerUrlAssigned ? ($this->registerUrl !== null ? UserAccessTemporalCodeRegisterUrlVO::from($this->registerUrl) : null) : $registerUrl;
    }
    public function registerUrl(UserAccessTemporalCodeRegisterUrlVO|string|null $registerUrl): static
    {
        $this->registerUrl = $registerUrl;
        $this->registerUrlAssigned = true;
        return $this;
    }
    public function getRegisterUrl(): ?string
    {
        return is_a($this->registerUrl, UserAccessTemporalCodeRegisterUrlVO::class) ? $this->registerUrl->value() : $this->registerUrl;
    }
    public function unsetRegisterUrl(): static
    {
        $this->registerUrl = null;
        $this->registerUrlAssigned = false;
        return $this;
    }
    protected function withDefaultRegisterUrl(): void
    {
    }
    protected function withAssertedRegisterUrlRules(self $value, ConstraintFailList $errorsList): void
    {
        if ($value->registerUrlAssigned = $this->registerUrlAssigned) {
            $value->registerUrl = UserAccessTemporalCodeRegisterUrlVO::tryFrom($this->registerUrl, $errorsList);
        }
    }
}
