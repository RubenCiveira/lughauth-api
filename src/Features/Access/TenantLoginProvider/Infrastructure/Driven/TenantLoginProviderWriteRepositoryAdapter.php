<?php

# @autogenerated
declare(strict_types=1);

namespace Civi\Lughauth\Features\Access\TenantLoginProvider\Infrastructure\Driven;

use Psr\EventDispatcher\EventDispatcherInterface;
use Closure;
use Override;
use Throwable;
use Civi\Lughauth\Shared\Connector\FileStorage\FileStoreKey;
use Civi\Lughauth\Shared\Connector\FileStorage\BinaryContent;
use Civi\Lughauth\Shared\Exception\NotFoundException;
use Civi\Lughauth\Shared\Infrastructure\Connector\FileStorage\PdoFileStorage;
use Civi\Lughauth\Features\Access\Tenant\Domain\TenantRef;
use Civi\Lughauth\Features\Access\TenantLoginProvider\Domain\Gateway\TenantLoginProviderWriteRepository;
use Civi\Lughauth\Features\Access\TenantLoginProvider\Domain\Gateway\TenantLoginProviderSlide;
use Civi\Lughauth\Features\Access\TenantLoginProvider\Domain\Gateway\TenantLoginProviderCursor;
use Civi\Lughauth\Features\Access\TenantLoginProvider\Domain\Gateway\TenantLoginProviderFilter;
use Civi\Lughauth\Features\Access\TenantLoginProvider\Domain\TenantLoginProviderRef;
use Civi\Lughauth\Features\Access\TenantLoginProvider\Domain\TenantLoginProvider;
use Civi\Lughauth\Shared\Observability\LoggerAwareTrait;
use Civi\Lughauth\Shared\Observability\TracerAwareTrait;

class TenantLoginProviderWriteRepositoryAdapter implements TenantLoginProviderWriteRepository
{
    use LoggerAwareTrait;
    use TracerAwareTrait;

    public function __construct(
        private readonly PdoFileStorage $store,
        private readonly TenantLoginProviderPdoConnector $conn,
        private readonly EventDispatcherInterface $dispacher,
    ) {
    }
    #[Override]
    public function listForUpdate(?TenantLoginProviderFilter $filter = null, ?TenantLoginProviderCursor $sort = null): TenantLoginProviderSlide
    {
        $this->logDebug("Count for Tenant login provider on adapter ");
        $span = $this->startSpan("Count for Tenant login provider on adapter");
        try {
            $values = $this->conn->list($filter, $sort);
            $last = end($values);
            return new TenantLoginProviderSlide(function ($slide, $next) use ($filter) {
                return $this->listForUpdate($filter, $next);
            }, new TenantLoginProviderCursor($sort?->limit ?? 100, $last->uid ?? null), $values);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    #[Override]
    public function retrieveForUpdate(TenantLoginProviderFilter $filter): ?TenantLoginProvider
    {
        $this->logDebug("Count for Tenant login provider on adapter ");
        $span = $this->startSpan("Count for Tenant login provider on adapter");
        try {
            return $this->conn->retrieveForUpdate($filter);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    #[Override]
    public function existsForUpdate(?TenantLoginProviderFilter $filter): bool
    {
        $this->logDebug("Count for Tenant login provider on adapter ");
        $span = $this->startSpan("Count for Tenant login provider on adapter");
        try {
            return $this->conn->exists($filter);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    #[Override]
    public function countForUpdate(?TenantLoginProviderFilter $filter = null): int
    {
        $this->logDebug("Count for Tenant login provider on adapter ");
        $span = $this->startSpan("Count for Tenant login provider on adapter");
        try {
            return $this->conn->count($filter);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    #[Override]
    public function create(TenantLoginProvider $entity, ?Closure $verify = null): TenantLoginProvider
    {
        $this->logDebug("Count for Tenant login provider on adapter ");
        $span = $this->startSpan("Count for Tenant login provider on adapter");
        try {
            if ($entity->getMetadata()) {
                $entity->commitMetadataWith($this->store);
            }
            $created = $this->conn->create($entity, $verify);
            $this->dispach($entity);
            return $created;
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    #[Override]
    public function update(TenantLoginProviderRef $reference, TenantLoginProvider $entity): TenantLoginProvider
    {
        $this->logDebug("Count for Tenant login provider on adapter ");
        $span = $this->startSpan("Count for Tenant login provider on adapter");
        try {
            $original = $reference instanceof TenantLoginProvider ? $reference : $this->retrieveForUpdate(new TenantLoginProviderFilter(uids: [$reference->uid()]));
            $prevMetadata = $original->getMetadata();
            $currMetadata = $entity->getMetadata();
            if ($prevMetadata != $currMetadata) {
                if ($prevMetadata) {
                    $this->store->deleteFile(new FileStoreKey($prevMetadata));
                }
                if ($currMetadata) {
                    $entity->commitMetadataWith($this->store);
                }
            }
            $updated = $this->conn->update($entity);
            $this->dispach($entity);
            return $updated;
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    #[Override]
    public function delete(TenantLoginProvider $entity): bool
    {
        $this->logDebug("Count for Tenant login provider on adapter ");
        $span = $this->startSpan("Count for Tenant login provider on adapter");
        try {
            $result = $this->conn->delete($entity);
            $currMetadata = $entity->getMetadata();
            if ($currMetadata) {
                $this->store->deleteFile(new FileStoreKey($currMetadata));
            }
            $this->dispach($entity);
            return $result;
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    #[Override]
    public function temporalStoreMetadata(BinaryContent $binary): string
    {
        $this->logDebug("Tempora store Metadata childs for Tenant login provider on adapter ");
        $span = $this->startSpan("Tempora store Metadata childs for Tenant login provider on adapter");
        try {
            return $this->store->tempStore($binary)->key;
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    #[Override]
    public function readTemporalMetadata(string $key): BinaryContent
    {
        $this->logDebug("Read temporal Metadata childs for Tenant login provider on adapter ");
        $span = $this->startSpan("Read temporal Metadata childs for Tenant login provider on adapter");
        try {
            $binary = $this->store->retrieveTempFile(new FileStoreKey($key));
            if ($binary) {
                return $binary;
            } else {
                throw new NotFoundException('');
            }
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    #[Override]
    public function commitMetadata(string $key, ?string $previous = null): string
    {
        $this->logDebug("Commit Metadata childs for Tenant login provider on adapter ");
        $span = $this->startSpan("Commit Metadata childs for Tenant login provider on adapter");
        try {
            if ($previous) {
                $this->store->deleteFile(new FileStoreKey($previous));
            }
            return $this->store->commitContent(new FileStoreKey($key))->key;
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    #[Override]
    public function findOneForUpdateByUid(string $uid): ?TenantLoginProvider
    {
        $this->logDebug("Find on by uid for Tenant login provider on adapter");
        $span = $this->startSpan("Find on by uid for Tenant login provider on adapter");
        try {
            return $this->conn->retrieveForUpdate(new TenantLoginProviderFilter(uids: [$uid]));
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    #[Override]
    public function findOneForUpdateByTenantAndName(TenantRef $tenant, string $name): ?TenantLoginProvider
    {
        $this->logDebug("Find on by tenant name for Tenant login provider on adapter");
        $span = $this->startSpan("Find on by tenant name for Tenant login provider on adapter");
        try {
            return $this->conn->retrieveForUpdate(new TenantLoginProviderFilter(tenantAndName: TenantLoginProviderFilter::tenantAndNameFilter(tenant: $tenant, name: $name)));
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function dispach(TenantLoginProvider $entity)
    {
        $this->logDebug("Count for Tenant login provider on adapter ");
        $span = $this->startSpan("Count for Tenant login provider on adapter");
        try {
            foreach ($entity->getTheEvents() as $event) {
                $this->dispacher->dispatch($event);
            }
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
}
