<?php

# @autogenerated
declare(strict_types=1);

namespace Civi\Lughauth\Features\Access\User\Domain\ValueObject\Holder;

use Civi\Lughauth\Shared\Value\Validation\ConstraintFailList;
use Civi\Lughauth\Features\Access\User\Domain\ValueObject\UserTemporalPasswordVO;

trait UserTemporalPasswordAttributeHolder
{
    protected UserTemporalPasswordVO|bool|null $temporalPassword = null;
    protected bool $temporalPasswordAssigned = false;

    public function getTemporalPasswordOrDefault(?UserTemporalPasswordVO $temporalPassword): UserTemporalPasswordVO|bool|null
    {
        return $this->temporalPasswordAssigned ? ($this->temporalPassword !== null ? UserTemporalPasswordVO::from($this->temporalPassword) : null) : $temporalPassword;
    }
    public function temporalPassword(UserTemporalPasswordVO|bool|null $temporalPassword): static
    {
        $this->temporalPassword = $temporalPassword;
        $this->temporalPasswordAssigned = true;
        return $this;
    }
    public function getTemporalPassword(): ?bool
    {
        return is_a($this->temporalPassword, UserTemporalPasswordVO::class) ? $this->temporalPassword->value() : $this->temporalPassword;
    }
    public function unsetTemporalPassword(): static
    {
        $this->temporalPassword = null;
        $this->temporalPasswordAssigned = false;
        return $this;
    }
    protected function withDefaultTemporalPassword(): void
    {
        if ($this->temporalPassword === null) {
            $this->temporalPassword = false;
        }
    }
    protected function withAssertedTemporalPasswordRules(self $value, ConstraintFailList $errorsList): void
    {
        if ($value->temporalPasswordAssigned = $this->temporalPasswordAssigned) {
            $value->temporalPassword = UserTemporalPasswordVO::tryFrom($this->temporalPassword, $errorsList);
        }
    }
}
