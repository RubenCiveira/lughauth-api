<?php

# @autogenerated
declare(strict_types=1);

namespace Civi\Lughauth\Features\Access\User\Infrastructure\Driven;

use Throwable;
use Closure;
use Civi\Lughauth\Shared\Infrastructure\Sql\SqlParam;
use Civi\Lughauth\Shared\Infrastructure\Sql\SqlTemplate;
use Civi\Lughauth\Shared\Exception\NotFoundException;
use Civi\Lughauth\Shared\Exception\NotUniqueException;
use Civi\Lughauth\Shared\Exception\ConstraintException;
use Civi\Lughauth\Shared\Exception\OptimistLockException;
use Civi\Lughauth\Shared\Exception\NotEmptyChildsException;
use Civi\Lughauth\Features\Access\User\Domain\Gateway\UserFilter;
use Civi\Lughauth\Features\Access\User\Domain\Gateway\UserCursor;
use Civi\Lughauth\Features\Access\User\Domain\User;
use Civi\Lughauth\Features\Access\User\Domain\UserRef;
use Civi\Lughauth\Shared\Observability\LoggerAwareTrait;
use Civi\Lughauth\Shared\Observability\TracerAwareTrait;
use Civi\Lughauth\Features\Access\Tenant\Domain\TenantRef;
use Civi\Lughauth\Features\Access\User\Domain\ValueObject\UserPasswordVO;
use Civi\Lughauth\Shared\Security\AesCypherService;
use Civi\Lughauth\Features\Access\User\Domain\ValueObject\UserSecondFactorSeedVO;
use Civi\Lughauth\Features\Access\User\Domain\ValueObject\UserTempSecondFactorSeedVO;

class UserPdoConnector
{
    use LoggerAwareTrait;
    use TracerAwareTrait;

    public function __construct(
        private readonly AesCypherService $cypher,
        private readonly SqlTemplate $db,
    ) {
    }
    public function list(?UserFilter $filter = null, ?UserCursor $sort = null): array
    {
        $this->logDebug("List query for User");
        $span = $this->startSpan("List query for User");
        try {
            $sqlFilter = $this->filter(false, $filter, $sort, false);
            return $this->query($sqlFilter['query'], $sqlFilter['params']);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function listForUpdate(?UserFilter $filter = null, ?UserCursor $sort = null): array
    {
        $this->logDebug("List query for update of User");
        $span = $this->startSpan("List query for update of User");
        try {
            $sqlFilter = $this->filter(true, $filter, $sort, false);
            return $this->query($sqlFilter['query'], $sqlFilter['params']);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function query(string $query, ?array $params = []): array
    {
        $this->logDebug("Make query for entities for User");
        $span = $this->startSpan("Make query for entities for User");
        try {
            return $this->db->query($query, $params, fn ($row) => $this->mapper($row));
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function rawQuery(string $query, ?array $params = []): array
    {
        $this->logDebug("Make raw query for User");
        $span = $this->startSpan("Make raw query for User");
        try {
            return $this->db->query($query, $params, fn ($row) => $row);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function retrieve(UserFilter $filter): ?User
    {
        $this->logDebug("Retrieve query for User");
        $span = $this->startSpan("Retrieve query for User");
        try {
            $sqlFilter = $this->filter(false, $filter, null, false);
            return $this->db->findOne($sqlFilter['query'], $sqlFilter['params'], fn ($row) => $this->mapper($row));
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function retrieveForUpdate(UserFilter $filter): ?User
    {
        $this->logDebug("Retrieve query for update of User");
        $span = $this->startSpan("Retrieve query for update of User");
        try {
            $sqlFilter = $this->filter(true, $filter, null, false);
            return $this->db->findOne($sqlFilter['query'], $sqlFilter['params'], fn ($row) => $this->mapper($row));
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function create(User $entity, ?Closure $verify = null): User
    {
        $this->logDebug("Execute insert sql query for User");
        $span = $this->startSpan("Execute insert sql query for User");
        try {
            try {
                $this->db->execute('INSERT INTO "access_user" ( "uid", "tenant", "name", "password", "email", "enabled", "temporal_password", "use_second_factors", "second_factor_seed", "temp_second_factor_seed", "failed_login_attempts", "blocked_until", "recovery_code", "recovery_code_expiration", "language", "provider", "version") VALUES ( :uid, :tenant, :name, :password, :email, :enabled, :temporalPassword, :useSecondFactors, :secondFactorSeed, :tempSecondFactorSeed, :failedLoginAttempts, :blockedUntil, :recoveryCode, :recoveryCodeExpiration, :language, :provider, :version)', [
                     new SqlParam(name: 'uid', value: $entity->uid(), type: SqlParam::STR),
                     new SqlParam(name: 'tenant', value: $entity->getTenant()?->uid(), type: SqlParam::STR),
                     new SqlParam(name: 'name', value: $entity->getName(), type: SqlParam::STR),
                     new SqlParam(name: 'password', value: $entity->getCypheredPassword($this->cypher), type: SqlParam::STR),
                     new SqlParam(name: 'email', value: $entity->getEmail(), type: SqlParam::STR),
                     new SqlParam(name: 'enabled', value: $entity->getEnabled(), type: SqlParam::BOOL),
                     new SqlParam(name: 'temporalPassword', value: $entity->getTemporalPassword(), type: SqlParam::BOOL),
                     new SqlParam(name: 'useSecondFactors', value: $entity->getUseSecondFactors(), type: SqlParam::BOOL),
                     new SqlParam(name: 'secondFactorSeed', value: $entity->getCypheredSecondFactorSeed($this->cypher), type: SqlParam::STR),
                     new SqlParam(name: 'tempSecondFactorSeed', value: $entity->getCypheredTempSecondFactorSeed($this->cypher), type: SqlParam::STR),
                     new SqlParam(name: 'failedLoginAttempts', value: $entity->getFailedLoginAttempts(), type: SqlParam::INT),
                     new SqlParam(name: 'blockedUntil', value: $entity->getBlockedUntil(), type: SqlParam::STR),
                     new SqlParam(name: 'recoveryCode', value: $entity->getRecoveryCode(), type: SqlParam::STR),
                     new SqlParam(name: 'recoveryCodeExpiration', value: $entity->getRecoveryCodeExpiration(), type: SqlParam::STR),
                     new SqlParam(name: 'language', value: $entity->getLanguage(), type: SqlParam::STR),
                     new SqlParam(name: 'provider', value: $entity->getProvider(), type: SqlParam::STR),
                     new SqlParam(name: 'version', value: 0, type: SqlParam::INT)
                ]);
            } catch (NotUniqueException $ex) {
                $this->checkDuplicates($entity, true);
                throw $ex;
            }
            $created = $entity->withVersion(0);
            if ($verify && !$verify($created)) {
                $this->db->execute('DELETE FROM "access_user" where "uid" = :uid', [
                  new SqlParam(name: 'uid', value: $entity->uid(), type: SqlParam::STR)
                ]);
                throw new NotFoundException('Insertion of not visible values');
            }
            return $created;
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function update(User $update): ?User
    {
        $this->logDebug("Execute update sql query for User");
        $span = $this->startSpan("Execute update sql query for User");
        try {
            try {
                $result = $this->db->execute('UPDATE "access_user" SET "tenant" = :tenant , "name" = :name , "password" = :password , "email" = :email , "enabled" = :enabled , "temporal_password" = :temporalPassword , "use_second_factors" = :useSecondFactors , "second_factor_seed" = :secondFactorSeed , "temp_second_factor_seed" = :tempSecondFactorSeed , "failed_login_attempts" = :failedLoginAttempts , "blocked_until" = :blockedUntil , "recovery_code" = :recoveryCode , "recovery_code_expiration" = :recoveryCodeExpiration , "language" = :language , "provider" = :provider , "version" = :version WHERE "uid" = :uid and "version" = :_lock_version', [
                     new SqlParam(name: 'uid', value: $update->uid(), type: SqlParam::STR),
                     new SqlParam(name: 'tenant', value: $update->getTenant()?->uid(), type: SqlParam::STR),
                     new SqlParam(name: 'name', value: $update->getName(), type: SqlParam::STR),
                     new SqlParam(name: 'password', value: $update->getCypheredPassword($this->cypher), type: SqlParam::STR),
                     new SqlParam(name: 'email', value: $update->getEmail(), type: SqlParam::STR),
                     new SqlParam(name: 'enabled', value: $update->getEnabled(), type: SqlParam::BOOL),
                     new SqlParam(name: 'temporalPassword', value: $update->getTemporalPassword(), type: SqlParam::BOOL),
                     new SqlParam(name: 'useSecondFactors', value: $update->getUseSecondFactors(), type: SqlParam::BOOL),
                     new SqlParam(name: 'secondFactorSeed', value: $update->getCypheredSecondFactorSeed($this->cypher), type: SqlParam::STR),
                     new SqlParam(name: 'tempSecondFactorSeed', value: $update->getCypheredTempSecondFactorSeed($this->cypher), type: SqlParam::STR),
                     new SqlParam(name: 'failedLoginAttempts', value: $update->getFailedLoginAttempts(), type: SqlParam::INT),
                     new SqlParam(name: 'blockedUntil', value: $update->getBlockedUntil(), type: SqlParam::STR),
                     new SqlParam(name: 'recoveryCode', value: $update->getRecoveryCode(), type: SqlParam::STR),
                     new SqlParam(name: 'recoveryCodeExpiration', value: $update->getRecoveryCodeExpiration(), type: SqlParam::STR),
                     new SqlParam(name: 'language', value: $update->getLanguage(), type: SqlParam::STR),
                     new SqlParam(name: 'provider', value: $update->getProvider(), type: SqlParam::STR),
                     new SqlParam(name: 'version', value: $update->getVersion() + 1, type: SqlParam::INT),
                     new SqlParam(name: '_lock_version', value: $update->getVersion(), type: SqlParam::INT)
                ]);
                if (!$result && $this->db->exists('select "uid" from "access_user" where "uid" = :uid', ['uid' => $update->uid() ])) {
                    throw new OptimistLockException($update->uid(), "version: " . $update->getVersion());
                } elseif (!$result) {
                    throw new NotFoundException($update->uid());
                }
            } catch (NotUniqueException $ex) {
                $this->checkDuplicates($update, false);
                throw $ex;
            }
            return $update->withVersion($update->getVersion() + 1);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function delete(UserRef $ref): bool
    {
        $this->logDebug("Execute delete sql query for User");
        $span = $this->startSpan("Execute delete sql query for User");
        try {
            try {
                return $this->db->execute('DELETE FROM "access_user" where "uid" = :uid', [new SqlParam(name: 'uid', value: $ref->uid(), type:SqlParam::STR)]);
            } catch (NotEmptyChildsException $ex) {
                throw ConstraintException::ofError('not-empty', ['uid'], [$ref->uid()]);
            }
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function exists(UserFilter $filter): bool
    {
        $this->logDebug("Execute exists sql query for User");
        $span = $this->startSpan("Execute exists sql query for User");
        try {
            $sqlFilter = $this->filter(false, $filter, null, false);
            return $this->db->exists($sqlFilter['query'], $sqlFilter['params']);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function existsForUpdate(UserFilter $filter): bool
    {
        $this->logDebug("Execute exists sql query for update of User");
        $span = $this->startSpan("Execute update sql query for update of User");
        try {
            $sqlFilter = $this->filter(false, $filter, null, false);
            return $this->db->exists($sqlFilter['query'], $sqlFilter['params']);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function count(?UserFilter $filter = null): int
    {
        $this->logDebug("Execute count sql query for User");
        $span = $this->startSpan("Execute count sql query for User");
        try {
            $sqlFilter = $this->filter(true, $filter, null, true);
            return $this->db->findOne($sqlFilter['query'], $sqlFilter['params'], fn ($row) => $row['count']);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function countForUpdate(?UserFilter $filter = null): int
    {
        $this->logDebug("Execute count sql query for update of User");
        $span = $this->startSpan("Execute count sql query for update of User");
        try {
            $sqlFilter = $this->filter(false, $filter, null, true);
            return $this->db->findOne($sqlFilter['query'], $sqlFilter['params'], fn ($row) => $row['count']);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function checkDuplicates(User $entity, bool $creation)
    {
        $this->logDebug("Query to check duplicates for User");
        $span = $this->startSpan("Query to check duplicates for User");
        try {
            $values = ['uid' => $entity->uid()];
            if ($creation &&  $this->db->exists('SELECT  "uid" from "access_user" where "uid" = :uid', $values)) {
                throw ConstraintException::ofError('not-unique', array_keys($values), array_values($values));
            }
            $values = ['tenant' => $entity->getTenant()?->uid(), 'name' => $entity->getName(), 'uid' => $entity->uid()];
            if ($this->db->exists('SELECT  "tenant", "name" from "access_user" where "tenant" = :tenant and "name" = :name and "uid" != :uid', $values)) {
                throw ConstraintException::ofError('not-unique', ['tenant', 'name'], [$entity->getTenant()?->uid(), $entity->getName()]);
            }
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function filter(bool $forUpdate, ?UserFilter $filter, ?UserCursor $sort, bool $count)
    {
        $this->logDebug("Build query filter of User");
        $span = $this->startSpan("Build query filter of User");
        try {
            $join = '';
            $query = '';
            $params = [];
            $order = '';
            $limit = '';
            if ($filter) {
                $filterUids = $filter->uids();
                if ($filterUids && count($filterUids) > 1) {
                    $query .= ' and "uid" in (:uids)';
                    $params[] = new SqlParam(name:'uids', value: $filterUids, type: SqlParam::STR);
                } elseif ($filterUids) {
                    $query .= ' and "uid" = :uid';
                    $params[] = new SqlParam(name:'uid', value: $filterUids[0], type: SqlParam::STR);
                }
                $filterSearch = $filter->search();
                if ($filterSearch) {
                    $query .= ' and ( "name" like :search)';
                    $params[] = new SqlParam(name:'search', value: '%'. $filterSearch . '%', type: SqlParam::STR);
                }
                $filterTenantAndName = $filter->tenantAndName();
                if ($filterTenantAndName) {
                    $query .= ' and ( "tenant" = :tenantNameTenant and "name" = :tenantNameName)';
                    $params[] = new SqlParam(name: 'tenantNameTenant', value: $filterTenantAndName['tenant']->uid(), type: SqlParam::STR);
                    $params[] = new SqlParam(name: 'tenantNameName', value: $filterTenantAndName['name'], type: SqlParam::STR);
                }
                if ($filterNameOrEmail = $filter->nameOrEmail()) {
                    $query .= ' and ("email" = :emailNameOrEmail or "name" = :nameNameOrEmail)';
                    $params[] = new SqlParam(name: 'emailNameOrEmail', value: $filterNameOrEmail, type: SqlParam::STR);
                    $params[] = new SqlParam(name: 'nameNameOrEmail', value: $filterNameOrEmail, type: SqlParam::STR);
                }
                if ($filterName = $filter->name()) {
                    $query .= ' and "name" = :name ';
                    $params[] = new SqlParam(name: 'name', value: $filterName, type: SqlParam::STR);
                }
                if ($filterTenant = $filter->tenant()) {
                    $query .= ' and "tenant" = :tenant ';
                    $params[] = new SqlParam(name: 'tenant', value: $filterTenant->uid(), type: SqlParam::STR);
                }
                if ($filterTenants = $filter->tenants()) {
                    $query .= ' and "tenant" in (:tenants)  ';
                    $params[] = new SqlParam(name: 'tenants', value: $filterTenants, type: SqlParam::STR);
                }
                if ($filterTenantTenantAccesible = $filter->tenantTenantAccesible()) {
                    $join .= ' LEFT JOIN "access_tenant" as "tenantTenantAccesibleTenant" ON "tenantTenantAccesibleTenant"."uid" = "access_user"."tenant"';
                    $query .= ' and "tenantTenantAccesibleTenant"."name" = :tenantTenantAccesible';
                    $params[] = new SqlParam(name: 'tenantTenantAccesible', value: $filterTenantTenantAccesible, type: SqlParam::STR);
                }
            }
            if ($sort) {
                $sortLimit = $sort->limit();
                if ($sortLimit) {
                    $limit = ' LIMIT ' . $this->db->escapeValue($sortLimit, SqlParam::INT);
                }
                $sortOrder = $sort->order();
                if ($sortOrder) {
                    foreach ($sortOrder as $ord) {
                        $equals = '';
                        if ($ord === 'nameAsc') {
                            $sortSinceName = $sort->sinceName();
                            if ($sortSinceName) {
                                $query .= " and " . ($equals ? substr($equals, 4) . ' and ' : '') . ' "name" > :sinceName';
                                $equals .= ' and "name" = :sinceName';
                                $params[] = new SqlParam(name: 'sinceName', value: $sortSinceName, type: SqlParam::STR);
                            }
                            $order .= ', "access_user"."name" asc';
                        }
                        if ($ord === 'nameDesc') {
                            $sortSinceName = $sort->sinceName();
                            if ($sortSinceName) {
                                $query .= " and " . ($equals ? substr($equals, 4) . ' and ' : '') . ' "name" < :sinceName';
                                $equals .= ' and "name" = :sinceName';
                                $params[] = new SqlParam(name: 'sinceName', value: $sortSinceName, type: SqlParam::STR);
                            }
                            $order .= ', "access_user"."name" desc';
                        }
                    }
                } else {
                    $sortSinceUid = $sort->sinceUid();
                    if ($sortSinceUid) {
                        $query .= ' and  "uid" < :sinceUid';
                        $params[] = new SqlParam(name: 'sinceUid', value: $sortSinceUid, type: SqlParam::STR);
                    }
                    $order = ', "access_user"."uid" desc';
                }
            }
            return [
              'query' => 'SELECT '.($count ? ' count(*) as count ' : '*').' FROM "access_user"'
                . $join
                . ($query ? ' WHERE ' . substr($query, 4) : '')
                . ($order ? ' ORDER BY ' . substr($order, 2) : '') . $limit . ($forUpdate ? " FOR UPDATE" : ""),
              'params' => $params];
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function mapper($row): User
    {
        $this->logDebug("Mapping from sql to entity for User");
        $span = $this->startSpan("Mapping from sql to enttiy for User");
        try {
            return new User(
                uid: $row['uid'] ?? null,
                tenant: isset($row['tenant']) ? new TenantRef(uid: $row['tenant']) : null,
                name: $row['name'] ?? null,
                password: UserPasswordVO::fromCypheredText($this->cypher, $row['password'] ?? ''),
                email: $row['email'] ?? null,
                enabled: isset($row['enabled']) ? !! $row['enabled'] : null,
                temporalPassword: isset($row['temporal_password']) ? !! $row['temporal_password'] : null,
                useSecondFactors: isset($row['use_second_factors']) ? !! $row['use_second_factors'] : null,
                secondFactorSeed: isset($row['second_factor_seed']) && $row['second_factor_seed'] ? UserSecondFactorSeedVO::fromCypheredText($this->cypher, $row['second_factor_seed']) : UserSecondFactorSeedVO::empty(),
                tempSecondFactorSeed: isset($row['temp_second_factor_seed']) && $row['temp_second_factor_seed'] ? UserTempSecondFactorSeedVO::fromCypheredText($this->cypher, $row['temp_second_factor_seed']) : UserTempSecondFactorSeedVO::empty(),
                failedLoginAttempts: $row['failed_login_attempts'] ?? null,
                blockedUntil: $row['blocked_until'] ? new \DateTimeImmutable($row['blocked_until']) : null,
                recoveryCode: $row['recovery_code'] ?? null,
                recoveryCodeExpiration: $row['recovery_code_expiration'] ? new \DateTimeImmutable($row['recovery_code_expiration']) : null,
                language: $row['language'] ?? null,
                provider: $row['provider'] ?? null,
                version: $row['version'] ?? null,
            );
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
}
