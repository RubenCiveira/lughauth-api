<?php

# @autogenerated
declare(strict_types=1);

namespace Civi\Lughauth\Features\Access\Master\UserIdentity\Domain\ValueObject\Holder;

use Civi\Lughauth\Shared\Value\Validation\ConstraintFailList;
use Civi\Lughauth\Features\Access\Master\UserIdentity\Domain\ValueObject\UserIdentityRolesRoleVO;
use Civi\Lughauth\Features\Access\Master\Role\Domain\RoleRef;

trait UserIdentityRolesRoleAttributeHolder
{
    protected UserIdentityRolesRoleVO|RoleRef|null $role = null;
    protected bool $roleAssigned = false;

    public function getRoleOrDefault(?UserIdentityRolesRoleVO $role): ?UserIdentityRolesRoleVO
    {
        return $this->roleAssigned ? ($this->role !== null ? UserIdentityRolesRoleVO::from($this->role) : null) : $role;
    }
    public function role(UserIdentityRolesRoleVO|RoleRef|null $role): static
    {
        $this->role = $role;
        $this->roleAssigned = true;
        return $this;
    }
    public function getRole(): ?RoleRef
    {
        return is_a($this->role, UserIdentityRolesRoleVO::class) ? $this->role->value() : $this->role;
    }
    public function unsetRole(): static
    {
        $this->role = null;
        $this->roleAssigned = false;
        return $this;
    }
    protected function withDefaultRole(): void
    {
    }
    protected function withAssertedRoleRules(self $value, ConstraintFailList $errorsList): void
    {
        if ($value->roleAssigned = $this->roleAssigned) {
            $value->role = UserIdentityRolesRoleVO::tryFrom($this->role, $errorsList);
        }
    }
}
