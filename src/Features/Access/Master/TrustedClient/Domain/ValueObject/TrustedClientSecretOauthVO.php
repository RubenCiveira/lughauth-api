<?php

# @autogenerated
declare(strict_types=1);

namespace Civi\Lughauth\Features\Access\Master\TrustedClient\Domain\ValueObject;

use Civi\Lughauth\Shared\Security\AesCypherService;
use Civi\Lughauth\Shared\Value\Validation\ConstraintFailList;
use Civi\Lughauth\Shared\Value\Validation\ConstraintFail;
use Civi\Lughauth\Shared\Value\Validation\Rule\Length;

class TrustedClientSecretOauthVO
{
    public static function fromCypheredText(AesCypherService $cypher, string $value): TrustedClientSecretOauthVO
    {
        return self::from('cyphered://' . $value);
    }
    public static function fromPlainText(AesCypherService $cypher, string $value): TrustedClientSecretOauthVO
    {
        return self::from(self::isCyphered($value) ? $value : 'cyphered://' . $cypher->encryptForAll($value));
    }
    public static function tryFromCypheredText(AesCypherService $cypher, string $value, ConstraintFailList $list): TrustedClientSecretOauthVO
    {
        return self::tryFrom('cyphered://' . $value, $list);
    }
    public static function tryFromPlainText(AesCypherService $cypher, string $value, ConstraintFailList $list): TrustedClientSecretOauthVO
    {
        return self::tryFrom(self::isCyphered($value) ? $value : 'cyphered://' . $cypher->encryptForAll($value), $list);
    }
    private static function isCyphered(string $value): bool
    {
        return strpos($value, 'cyphered://') === 0;
    }
    public static function empty(): TrustedClientSecretOauthVO
    {
        return new TrustedClientSecretOauthVO(null);
    }
    public static function from(TrustedClientSecretOauthVO|string|null $value): TrustedClientSecretOauthVO
    {
        if (is_a($value, TrustedClientSecretOauthVO::class)) {
            // If is a ValueObject, its already validated
            return $value;
        } else {
            // If is not a ValueObject, validation is need and exception throw
            $errorsList = new ConstraintFailList();
            $candidate = self::tryFrom($value, $errorsList);
            if ($errorsList->hasErrors()) {
                throw $errorsList->asConstraintException();
            }
            return $candidate;
        }
    }
    public static function tryFrom(mixed $value, ConstraintFailList $list): ?TrustedClientSecretOauthVO
    {
        if (is_a($value, TrustedClientSecretOauthVO::class)) {
            // If is a ValueObject, its already validated... nothing to append
            return $value;
        } elseif (!$value) {
            return new TrustedClientSecretOauthVO($value);
        } elseif (is_string($value)) {
            // If is a ValueObject, we need to append all the errors for the context
            $valid = true;
            foreach (self::rules() as $rule) {
                if ($fail = $rule->check($value)) {
                    $list->add(ConstraintFail::fromRuleFail('secretOauth', $fail));
                    $valid = false;
                }
            }
            return $valid ? new TrustedClientSecretOauthVO($value) : null;
        } else {
            $list->add(new ConstraintFail('wrong_type', ['secretOauth'], [$value], ['string']));
            return null;
        }
    }
    public static function rules(): array
    {
        return [
          new Length(min: null, max: 250),
        ];
    }
    /**
     * private constructor to avoid build a value without all the rule validations.
     */
    private function __construct(
        private readonly ?string $secretOauth
    ) {
        $this->validateCyphered($this->secretOauth);
    }
    private function validateCyphered(?string $key)
    {
        if ($key && strpos($key, 'cyphered://') !== 0) {
            throw new \InvalidArgumentException($key . ' is not a valid chypered text');
        }
    }
    public function value(): ?string
    {
        return $this->secretOauth ? "****" . substr($this->secretOauth, -2) : null;
    }
    public function cypheredValueWith(AesCypherService $cypher): ?string
    {
        return $this->secretOauth ? substr($this->secretOauth, 11) : null;
    }
    public function plainValueWith(AesCypherService $cypher): ?string
    {
        return $this->secretOauth ? $cypher->decryptForAll(substr($this->secretOauth, 11)) : null;
    }
}
