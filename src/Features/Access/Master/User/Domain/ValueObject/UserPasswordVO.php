<?php

# @autogenerated
declare(strict_types=1);

namespace Civi\Lughauth\Features\Access\Master\User\Domain\ValueObject;

use Civi\Lughauth\Shared\Security\AesCypherService;
use Civi\Lughauth\Shared\Value\Validation\ConstraintFailList;
use Civi\Lughauth\Shared\Value\Validation\ConstraintFail;
use Civi\Lughauth\Shared\Value\Validation\Rule\Length;

class UserPasswordVO
{
    public static function fromCypheredText(AesCypherService $cypher, string $value): UserPasswordVO
    {
        return self::from('cyphered://' . $value);
    }
    public static function fromPlainText(AesCypherService $cypher, string $value): UserPasswordVO
    {
        return self::from(self::isCyphered($value) ? $value : 'cyphered://' . $cypher->encryptForAll($value));
    }
    public static function tryFromCypheredText(AesCypherService $cypher, string $value, ConstraintFailList $list): UserPasswordVO
    {
        return self::tryFrom('cyphered://' . $value, $list);
    }
    public static function tryFromPlainText(AesCypherService $cypher, string $value, ConstraintFailList $list): UserPasswordVO
    {
        return self::tryFrom(self::isCyphered($value) ? $value : 'cyphered://' . $cypher->encryptForAll($value), $list);
    }
    private static function isCyphered(string $value): bool
    {
        return strpos($value, 'cyphered://') === 0;
    }
    public static function from(UserPasswordVO|string $value): UserPasswordVO
    {
        if (is_a($value, UserPasswordVO::class)) {
            // If is a ValueObject, its already validated
            return $value;
        } else {
            // If is not a ValueObject, validation is need and exception throw
            $errorsList = new ConstraintFailList();
            $candidate = self::tryFrom($value, $errorsList);
            if ($errorsList->hasErrors()) {
                throw $errorsList->asConstraintException();
            }
            return $candidate;
        }
    }
    public static function tryFrom(mixed $value, ConstraintFailList $list): ?UserPasswordVO
    {
        if (is_a($value, UserPasswordVO::class)) {
            // If is a ValueObject, its already validated... nothing to append
            return $value;
        } elseif (is_string($value)) {
            // If is a ValueObject, we need to append all the errors for the context
            $valid = true;
            foreach (self::rules() as $rule) {
                if ($fail = $rule->check($value)) {
                    $list->add(ConstraintFail::fromRuleFail('password', $fail));
                    $valid = false;
                }
            }
            return $valid ? new UserPasswordVO($value) : null;
        } else {
            $list->add(new ConstraintFail('wrong_type', ['password'], [$value], ['string']));
            return null;
        }
    }
    public static function rules(): array
    {
        return [
          new Length(min: null, max: 250),
        ];
    }
    /**
     * private constructor to avoid build a value without all the rule validations.
     */
    private function __construct(
        private readonly string $password
    ) {
        $this->validateCyphered($this->password);
    }
    private function validateCyphered(?string $key)
    {
        if ($key && strpos($key, 'cyphered://') !== 0) {
            throw new \InvalidArgumentException($key . ' is not a valid chypered text');
        }
    }
    public function value(): string
    {
        return "****" . substr($this->password, -2);
    }
    public function cypheredValueWith(AesCypherService $cypher): string
    {
        return $this->password ? substr($this->password, 11) : "";
    }
    public function plainValueWith(AesCypherService $cypher): string
    {
        return $this->password ? $cypher->decryptForAll(substr($this->password, 11)) : "";
    }
}
