<?php

# @autogenerated
declare(strict_types=1);

namespace Civi\Lughauth\Features\Access\Master\User\Domain\ValueObject\Holder;

use Civi\Lughauth\Shared\Value\Validation\ConstraintFailList;
use Civi\Lughauth\Features\Access\Master\User\Domain\ValueObject\UserBlockedUntilVO;

trait UserBlockedUntilAttributeHolder
{
    protected UserBlockedUntilVO|\DateTimeImmutable|null $blockedUntil = null;
    protected bool $blockedUntilAssigned = false;

    public function getBlockedUntilOrDefault(?UserBlockedUntilVO $blockedUntil): ?UserBlockedUntilVO
    {
        return $this->blockedUntilAssigned ? ($this->blockedUntil !== null ? UserBlockedUntilVO::from($this->blockedUntil) : null) : $blockedUntil;
    }
    public function blockedUntil(UserBlockedUntilVO|\DateTimeImmutable|null $blockedUntil): static
    {
        $this->blockedUntil = $blockedUntil;
        $this->blockedUntilAssigned = true;
        return $this;
    }
    public function getBlockedUntil(): ?\DateTimeImmutable
    {
        return is_a($this->blockedUntil, UserBlockedUntilVO::class) ? $this->blockedUntil->value() : $this->blockedUntil;
    }
    public function unsetBlockedUntil(): static
    {
        $this->blockedUntil = null;
        $this->blockedUntilAssigned = false;
        return $this;
    }
    protected function withDefaultBlockedUntil(): void
    {
    }
    protected function withAssertedBlockedUntilRules(self $value, ConstraintFailList $errorsList): void
    {
        if ($value->blockedUntilAssigned = $this->blockedUntilAssigned) {
            $value->blockedUntil = UserBlockedUntilVO::tryFrom($this->blockedUntil, $errorsList);
        }
    }
}
