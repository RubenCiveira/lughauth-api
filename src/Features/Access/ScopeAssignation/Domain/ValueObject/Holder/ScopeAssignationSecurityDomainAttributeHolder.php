<?php

# @autogenerated
declare(strict_types=1);

namespace Civi\Lughauth\Features\Access\ScopeAssignation\Domain\ValueObject\Holder;

use Civi\Lughauth\Shared\Value\Validation\ConstraintFailList;
use Civi\Lughauth\Features\Access\ScopeAssignation\Domain\ValueObject\ScopeAssignationSecurityDomainVO;
use Civi\Lughauth\Features\Access\SecurityDomain\Domain\SecurityDomainRef;

trait ScopeAssignationSecurityDomainAttributeHolder
{
    protected ScopeAssignationSecurityDomainVO|SecurityDomainRef|null $securityDomain = null;
    protected bool $securityDomainAssigned = false;

    public function getSecurityDomainOrDefault(?ScopeAssignationSecurityDomainVO $securityDomain): ScopeAssignationSecurityDomainVO|SecurityDomainRef|null
    {
        return $this->securityDomainAssigned ? ($this->securityDomain !== null ? ScopeAssignationSecurityDomainVO::from($this->securityDomain) : null) : $securityDomain;
    }
    public function securityDomain(ScopeAssignationSecurityDomainVO|SecurityDomainRef|null $securityDomain): static
    {
        $this->securityDomain = $securityDomain;
        $this->securityDomainAssigned = true;
        return $this;
    }
    public function getSecurityDomain(): ?SecurityDomainRef
    {
        return is_a($this->securityDomain, ScopeAssignationSecurityDomainVO::class) ? $this->securityDomain->value() : $this->securityDomain;
    }
    public function unsetSecurityDomain(): static
    {
        $this->securityDomain = null;
        $this->securityDomainAssigned = false;
        return $this;
    }
    protected function withDefaultSecurityDomain(): void
    {
    }
    protected function withAssertedSecurityDomainRules(self $value, ConstraintFailList $errorsList): void
    {
        if ($value->securityDomainAssigned = $this->securityDomainAssigned) {
            $value->securityDomain = ScopeAssignationSecurityDomainVO::tryFrom($this->securityDomain, $errorsList);
        }
    }
}
