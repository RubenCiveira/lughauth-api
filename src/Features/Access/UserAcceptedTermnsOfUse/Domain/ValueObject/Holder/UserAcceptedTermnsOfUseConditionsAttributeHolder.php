<?php

# @autogenerated
declare(strict_types=1);

namespace Civi\Lughauth\Features\Access\UserAcceptedTermnsOfUse\Domain\ValueObject\Holder;

use Civi\Lughauth\Shared\Value\Validation\ConstraintFailList;
use Civi\Lughauth\Features\Access\UserAcceptedTermnsOfUse\Domain\ValueObject\UserAcceptedTermnsOfUseConditionsVO;
use Civi\Lughauth\Features\Access\TenantTermsOfUse\Domain\TenantTermsOfUseRef;

trait UserAcceptedTermnsOfUseConditionsAttributeHolder
{
    protected UserAcceptedTermnsOfUseConditionsVO|TenantTermsOfUseRef|null $conditions = null;
    protected bool $conditionsAssigned = false;

    public function getConditionsOrDefault(?UserAcceptedTermnsOfUseConditionsVO $conditions): ?UserAcceptedTermnsOfUseConditionsVO
    {
        return $this->conditionsAssigned ? ($this->conditions !== null ? UserAcceptedTermnsOfUseConditionsVO::from($this->conditions) : null) : $conditions;
    }
    public function conditions(UserAcceptedTermnsOfUseConditionsVO|TenantTermsOfUseRef|null $conditions): static
    {
        $this->conditions = $conditions;
        $this->conditionsAssigned = true;
        return $this;
    }
    public function getConditions(): ?TenantTermsOfUseRef
    {
        return is_a($this->conditions, UserAcceptedTermnsOfUseConditionsVO::class) ? $this->conditions->value() : $this->conditions;
    }
    public function unsetConditions(): static
    {
        $this->conditions = null;
        $this->conditionsAssigned = false;
        return $this;
    }
    protected function withDefaultConditions(): void
    {
    }
    protected function withAssertedConditionsRules(self $value, ConstraintFailList $errorsList): void
    {
        if ($value->conditionsAssigned = $this->conditionsAssigned) {
            $value->conditions = UserAcceptedTermnsOfUseConditionsVO::tryFrom($this->conditions, $errorsList);
        }
    }
}
