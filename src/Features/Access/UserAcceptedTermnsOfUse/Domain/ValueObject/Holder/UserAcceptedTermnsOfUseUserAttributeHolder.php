<?php

# @autogenerated
declare(strict_types=1);

namespace Civi\Lughauth\Features\Access\UserAcceptedTermnsOfUse\Domain\ValueObject\Holder;

use Civi\Lughauth\Shared\Value\Validation\ConstraintFailList;
use Civi\Lughauth\Features\Access\UserAcceptedTermnsOfUse\Domain\ValueObject\UserAcceptedTermnsOfUseUserVO;
use Civi\Lughauth\Features\Access\User\Domain\UserRef;

trait UserAcceptedTermnsOfUseUserAttributeHolder
{
    protected UserAcceptedTermnsOfUseUserVO|UserRef|null $user = null;
    protected bool $userAssigned = false;

    public function getUserOrDefault(?UserAcceptedTermnsOfUseUserVO $user): ?UserAcceptedTermnsOfUseUserVO
    {
        return $this->userAssigned ? ($this->user !== null ? UserAcceptedTermnsOfUseUserVO::from($this->user) : null) : $user;
    }
    public function user(UserAcceptedTermnsOfUseUserVO|UserRef|null $user): static
    {
        $this->user = $user;
        $this->userAssigned = true;
        return $this;
    }
    public function getUser(): ?UserRef
    {
        return is_a($this->user, UserAcceptedTermnsOfUseUserVO::class) ? $this->user->value() : $this->user;
    }
    public function unsetUser(): static
    {
        $this->user = null;
        $this->userAssigned = false;
        return $this;
    }
    protected function withDefaultUser(): void
    {
    }
    protected function withAssertedUserRules(self $value, ConstraintFailList $errorsList): void
    {
        if ($value->userAssigned = $this->userAssigned) {
            $value->user = UserAcceptedTermnsOfUseUserVO::tryFrom($this->user, $errorsList);
        }
    }
}
