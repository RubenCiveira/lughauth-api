<?php

# @autogenerated
declare(strict_types=1);

namespace Civi\Lughauth\Features\Access\UserAcceptedTermnsOfUse\Infrastructure\Driven;

use Throwable;
use Closure;
use Civi\Lughauth\Shared\Infrastructure\Sql\SqlParam;
use Civi\Lughauth\Shared\Infrastructure\Sql\SqlTemplate;
use Civi\Lughauth\Shared\Exception\NotFoundException;
use Civi\Lughauth\Shared\Exception\NotUniqueException;
use Civi\Lughauth\Shared\Exception\ConstraintException;
use Civi\Lughauth\Shared\Exception\OptimistLockException;
use Civi\Lughauth\Shared\Exception\NotEmptyChildsException;
use Civi\Lughauth\Features\Access\UserAcceptedTermnsOfUse\Domain\Gateway\UserAcceptedTermnsOfUseFilter;
use Civi\Lughauth\Features\Access\UserAcceptedTermnsOfUse\Domain\Gateway\UserAcceptedTermnsOfUseCursor;
use Civi\Lughauth\Features\Access\UserAcceptedTermnsOfUse\Domain\UserAcceptedTermnsOfUse;
use Civi\Lughauth\Features\Access\UserAcceptedTermnsOfUse\Domain\UserAcceptedTermnsOfUseRef;
use Civi\Lughauth\Shared\Observability\LoggerAwareTrait;
use Civi\Lughauth\Shared\Observability\TracerAwareTrait;
use Civi\Lughauth\Features\Access\User\Domain\UserRef;
use Civi\Lughauth\Features\Access\TenantTermsOfUse\Domain\TenantTermsOfUseRef;

class UserAcceptedTermnsOfUsePdoConnector
{
    use LoggerAwareTrait;
    use TracerAwareTrait;

    public function __construct(
        private readonly SqlTemplate $db,
    ) {
    }
    public function list(?UserAcceptedTermnsOfUseFilter $filter = null, ?UserAcceptedTermnsOfUseCursor $sort = null): array
    {
        $this->logDebug("List query for User accepted termns of use");
        $span = $this->startSpan("List query for User accepted termns of use");
        try {
            $sqlFilter = $this->filter($filter, $sort, false);
            return $this->query($sqlFilter['query'], $sqlFilter['params']);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function listForUpdate(?UserAcceptedTermnsOfUseFilter $filter = null, ?UserAcceptedTermnsOfUseCursor $sort = null): array
    {
        $this->logDebug("List query for update of User accepted termns of use");
        $span = $this->startSpan("List query for update of User accepted termns of use");
        try {
            $sqlFilter = $this->filter($filter, $sort, false);
            return $this->queryForUpdate($sqlFilter['query'], $sqlFilter['params']);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function query(string $query, ?array $params = []): array
    {
        return $this->theQuery(false, $query, $params);
    }
    private function rawQuery(string $query, ?array $params = []): array
    {
        return $this->theRawQuery(false, $query, $params);
    }
    private function queryForUpdate(string $query, ?array $params = []): array
    {
        return $this->theQuery(true, $query, $params);
    }
    private function rawQueryForUpdate(string $query, ?array $params = []): array
    {
        return $this->theRawQuery(true, $query, $params);
    }
    private function theQuery(bool $forUpdate, string $query, ?array $params = []): array
    {
        $this->logDebug("Make query for entities for User accepted termns of use");
        $span = $this->startSpan("Make query for entities for User accepted termns of use");
        try {
            return $forUpdate ? $this->db->queryForUpdate($query, $params, fn ($row) => $this->mapper($row)) : $this->db->query($query, $params, fn ($row) => $this->mapper($row));
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function theRawQuery(bool $forUpdate, string $query, ?array $params = []): array
    {
        $this->logDebug("Make raw query for User accepted termns of use");
        $span = $this->startSpan("Make raw query for User accepted termns of use");
        try {
            return $forUpdate ? $this->db->queryForUpdate($query, $params, fn ($row) => $row) : $this->db->query($query, $params, fn ($row) => $row);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function retrieve(UserAcceptedTermnsOfUseFilter $filter): ?UserAcceptedTermnsOfUse
    {
        $this->logDebug("Retrieve query for User accepted termns of use");
        $span = $this->startSpan("Retrieve query for User accepted termns of use");
        try {
            $sqlFilter = $this->filter($filter, null, false);
            return $this->db->findOne($sqlFilter['query'], $sqlFilter['params'], fn ($row) => $this->mapper($row));
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function retrieveForUpdate(UserAcceptedTermnsOfUseFilter $filter): ?UserAcceptedTermnsOfUse
    {
        $this->logDebug("Retrieve query for update of User accepted termns of use");
        $span = $this->startSpan("Retrieve query for update of User accepted termns of use");
        try {
            $sqlFilter = $this->filter($filter, null, false);
            return $this->db->findOneForUpdate($sqlFilter['query'], $sqlFilter['params'], fn ($row) => $this->mapper($row));
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function create(UserAcceptedTermnsOfUse $entity, ?Closure $verify = null): UserAcceptedTermnsOfUse
    {
        $this->logDebug("Execute insert sql query for User accepted termns of use");
        $span = $this->startSpan("Execute insert sql query for User accepted termns of use");
        try {
            try {
                $this->db->execute('INSERT INTO "access_user_accepted_termns_of_use" ( "uid", "user", "conditions", "accept_date", "version") VALUES ( :uid, :user, :conditions, :acceptDate, :version)', [
                     new SqlParam(name: 'uid', value: $entity->uid(), type: SqlParam::STR),
                     new SqlParam(name: 'user', value: $entity->getUser()?->uid(), type: SqlParam::STR),
                     new SqlParam(name: 'conditions', value: $entity->getConditions()?->uid(), type: SqlParam::STR),
                     new SqlParam(name: 'acceptDate', value: $entity->getAcceptDate(), type: SqlParam::STR),
                     new SqlParam(name: 'version', value: 0, type: SqlParam::INT)
                ]);
            } catch (NotUniqueException $ex) {
                $this->checkDuplicates($entity, true);
                throw $ex;
            }
            $created = $entity->withVersion(0);
            if ($verify && !$verify($created)) {
                $this->db->execute('DELETE FROM "access_user_accepted_termns_of_use" where "uid" = :uid', [
                  new SqlParam(name: 'uid', value: $entity->uid(), type: SqlParam::STR)
                ]);
                throw new NotFoundException('Insertion of not visible values');
            }
            return $created;
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function update(UserAcceptedTermnsOfUse $update): ?UserAcceptedTermnsOfUse
    {
        $this->logDebug("Execute update sql query for User accepted termns of use");
        $span = $this->startSpan("Execute update sql query for User accepted termns of use");
        try {
            try {
                $result = $this->db->execute('UPDATE "access_user_accepted_termns_of_use" SET "user" = :user , "conditions" = :conditions , "accept_date" = :acceptDate , "version" = :version WHERE "uid" = :uid and "version" = :_lock_version', [
                     new SqlParam(name: 'uid', value: $update->uid(), type: SqlParam::STR),
                     new SqlParam(name: 'user', value: $update->getUser()?->uid(), type: SqlParam::STR),
                     new SqlParam(name: 'conditions', value: $update->getConditions()?->uid(), type: SqlParam::STR),
                     new SqlParam(name: 'acceptDate', value: $update->getAcceptDate(), type: SqlParam::STR),
                     new SqlParam(name: 'version', value: $update->getVersion() + 1, type: SqlParam::INT),
                     new SqlParam(name: '_lock_version', value: $update->getVersion(), type: SqlParam::INT)
                ]);
                if (!$result && $this->db->exists('select "uid" from "access_user_accepted_termns_of_use" where "uid" = :uid', ['uid' => $update->uid() ])) {
                    throw new OptimistLockException($update->uid(), "version: " . $update->getVersion());
                } elseif (!$result) {
                    throw new NotFoundException($update->uid());
                }
            } catch (NotUniqueException $ex) {
                $this->checkDuplicates($update, false);
                throw $ex;
            }
            return $update->withVersion($update->getVersion() + 1);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function delete(UserAcceptedTermnsOfUseRef $ref): bool
    {
        $this->logDebug("Execute delete sql query for User accepted termns of use");
        $span = $this->startSpan("Execute delete sql query for User accepted termns of use");
        try {
            try {
                return $this->db->execute('DELETE FROM "access_user_accepted_termns_of_use" where "uid" = :uid', [new SqlParam(name: 'uid', value: $ref->uid(), type:SqlParam::STR)]);
            } catch (NotEmptyChildsException $ex) {
                throw ConstraintException::ofError('not-empty', ['uid'], [$ref->uid()]);
            }
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function exists(UserAcceptedTermnsOfUseFilter $filter): bool
    {
        $this->logDebug("Execute exists sql query for User accepted termns of use");
        $span = $this->startSpan("Execute exists sql query for User accepted termns of use");
        try {
            $sqlFilter = $this->filter($filter, null, false);
            return $this->db->exists($sqlFilter['query'], $sqlFilter['params']);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function existsForUpdate(UserAcceptedTermnsOfUseFilter $filter): bool
    {
        $this->logDebug("Execute exists sql query for update of User accepted termns of use");
        $span = $this->startSpan("Execute update sql query for update of User accepted termns of use");
        try {
            $sqlFilter = $this->filter($filter, null, false);
            return $this->db->existsForUpdate($sqlFilter['query'], $sqlFilter['params']);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function count(?UserAcceptedTermnsOfUseFilter $filter = null): int
    {
        $this->logDebug("Execute count sql query for User accepted termns of use");
        $span = $this->startSpan("Execute count sql query for User accepted termns of use");
        try {
            $sqlFilter = $this->filter($filter, null, true);
            return $this->db->findOne($sqlFilter['query'], $sqlFilter['params'], fn ($row) => $row['count']);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function countForUpdate(?UserAcceptedTermnsOfUseFilter $filter = null): int
    {
        $this->logDebug("Execute count sql query for update of User accepted termns of use");
        $span = $this->startSpan("Execute count sql query for update of User accepted termns of use");
        try {
            $sqlFilter = $this->filter($filter, null, true);
            return $this->db->findOneForUpdate($sqlFilter['query'], $sqlFilter['params'], fn ($row) => $row['count']);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function checkDuplicates(UserAcceptedTermnsOfUse $entity, bool $creation)
    {
        $this->logDebug("Query to check duplicates for User accepted termns of use");
        $span = $this->startSpan("Query to check duplicates for User accepted termns of use");
        try {
            $values = ['uid' => $entity->uid()];
            if ($creation &&  $this->db->exists('SELECT  "uid" from "access_user_accepted_termns_of_use" where "uid" = :uid', $values)) {
                throw ConstraintException::ofError('not-unique', array_keys($values), array_values($values));
            }
            $values = ['user' => $entity->getUser()?->uid(), 'conditions' => $entity->getConditions()?->uid(), 'uid' => $entity->uid()];
            if ($this->db->exists('SELECT  "user", "conditions" from "access_user_accepted_termns_of_use" where "user" = :user and "conditions" = :conditions and "uid" != :uid', $values)) {
                throw ConstraintException::ofError('not-unique', ['user', 'conditions'], [$entity->getUser()?->uid(), $entity->getConditions()?->uid()]);
            }
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function filter(?UserAcceptedTermnsOfUseFilter $filter, ?UserAcceptedTermnsOfUseCursor $sort, bool $count)
    {
        $this->logDebug("Build query filter of User accepted termns of use");
        $span = $this->startSpan("Build query filter of User accepted termns of use");
        try {
            $join = '';
            $query = '';
            $params = [];
            $order = '';
            $limit = '';
            if ($filter) {
                $filterUids = $filter->uids();
                if ($filterUids && count($filterUids) > 1) {
                    $query .= ' and "access_user_accepted_termns_of_use"."uid" in (:uids)';
                    $params[] = new SqlParam(name:'uids', value: $filterUids, type: SqlParam::STR);
                } elseif ($filterUids) {
                    $query .= ' and "access_user_accepted_termns_of_use"."uid" = :uid';
                    $params[] = new SqlParam(name:'uid', value: $filterUids[0], type: SqlParam::STR);
                }
                $filterSearch = $filter->search();
                if ($filterSearch) {
                    $query .= ' and ( "access_user_accepted_termns_of_use"."uid" like :search)';
                    $params[] = new SqlParam(name:'search', value: '%'. $filterSearch . '%', type: SqlParam::STR);
                }
                $filterUserAndConditions = $filter->userAndConditions();
                if ($filterUserAndConditions) {
                    $query .= ' and ( "access_user_accepted_termns_of_use"."user" = :userConditionsUser and "access_user_accepted_termns_of_use"."conditions" = :userConditionsConditions)';
                    $params[] = new SqlParam(name: 'userConditionsUser', value: $filterUserAndConditions['user']->uid(), type: SqlParam::STR);
                    $params[] = new SqlParam(name: 'userConditionsConditions', value: $filterUserAndConditions['conditions']->uid(), type: SqlParam::STR);
                }
                if ($filterUser = $filter->user()) {
                    $query .= ' and "access_user_accepted_termns_of_use"."user" = :user ';
                    $params[] = new SqlParam(name: 'user', value: $filterUser->uid(), type: SqlParam::STR);
                }
                if ($filterUsers = $filter->users()) {
                    $query .= ' and "access_user_accepted_termns_of_use"."user" in (:users)  ';
                    $params[] = new SqlParam(name: 'users', value: $filterUsers, type: SqlParam::STR);
                }
                if ($filterConditions = $filter->conditions()) {
                    $query .= ' and "access_user_accepted_termns_of_use"."conditions" = :conditions ';
                    $params[] = new SqlParam(name: 'conditions', value: $filterConditions->uid(), type: SqlParam::STR);
                }
                if ($filterConditionss = $filter->conditionss()) {
                    $query .= ' and "access_user_accepted_termns_of_use"."conditions" in (:conditionss)  ';
                    $params[] = new SqlParam(name: 'conditionss', value: $filterConditionss, type: SqlParam::STR);
                }
                if ($filterUserTenantTenantAccesible = $filter->userTenantTenantAccesible()) {
                    $join .= ' LEFT JOIN "access_user" as "userTenantTenantAccesibleUser" ON "userTenantTenantAccesibleUser"."uid" = "access_user_accepted_termns_of_use"."user" LEFT JOIN "access_tenant" as "userTenantTenantAccesibleTenant" ON "userTenantTenantAccesibleTenant"."uid" = "userTenantTenantAccesibleUser"."tenant"';
                    $query .= ' and "userTenantTenantAccesibleUser"."userTenantTenantAccesibleTenant"."uid" = :userTenantTenantAccesible';
                    $params[] = new SqlParam(name: 'userTenantTenantAccesible', value: $filterUserTenantTenantAccesible, type: SqlParam::STR);
                }
            }
            if ($sort) {
                $sortLimit = $sort->limit();
                if ($sortLimit) {
                    $limit = ' LIMIT ' . $this->db->escapeValue($sortLimit, SqlParam::INT);
                }
                $sortSinceUid = $sort->sinceUid();
                if ($sortSinceUid) {
                    $query .= ' and  "uid" < :sinceUid';
                    $params[] = new SqlParam(name: 'sinceUid', value: $sortSinceUid, type: SqlParam::STR);
                }
                $order = ', "access_user_accepted_termns_of_use"."uid" desc';
            }
            return [
              'query' => 'SELECT '.($count ? ' count("access_user_accepted_termns_of_use".*) as count ' : '"access_user_accepted_termns_of_use".*').' FROM "access_user_accepted_termns_of_use"'
                . $join
                . ($query ? ' WHERE ' . substr($query, 4) : '')
                . ($order ? ' ORDER BY ' . substr($order, 2) : '') . $limit,
              'params' => $params];
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function mapper($row): UserAcceptedTermnsOfUse
    {
        $this->logDebug("Mapping from sql to entity for User accepted termns of use");
        $span = $this->startSpan("Mapping from sql to enttiy for User accepted termns of use");
        try {
            return new UserAcceptedTermnsOfUse(
                uid: $row['uid'] ?? null,
                user: isset($row['user']) ? new UserRef(uid: $row['user']) : null,
                conditions: isset($row['conditions']) ? new TenantTermsOfUseRef(uid: $row['conditions']) : null,
                acceptDate: $row['accept_date'] ? new \DateTimeImmutable($row['accept_date']) : null,
                version: $row['version'] ?? null,
            );
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
}
