<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Features\Access\Oidc\Session\Infrastructure\Driven;

use PDO;
use Jose\Component\Core\JWK;
use Jose\Component\Signature\Serializer\CompactSerializer;
use Jose\Component\Signature\Algorithm\HS256;
use Jose\Component\Signature\JWSVerifier;
use Jose\Component\Core\AlgorithmManager;
use Civi\Lughauth\Features\Access\Oidc\Authentication\Domain\AuthenticationRequest;
use Civi\Lughauth\Features\Access\Oidc\Authentication\Domain\AuthenticationResult;
use Civi\Lughauth\Features\Access\Oidc\Client\Domain\ClientData;
use Civi\Lughauth\Features\Access\Oidc\Session\Domain\Gateway\TemporalKeysRepository;
use Civi\Lughauth\Features\Access\Oidc\Session\Domain\TemporalAuthCode;
use Civi\Lughauth\Shared\Security\AesCypherService;
use Civi\Lughauth\Shared\Value\Random;

class TemporalKeysSqlAdapter implements TemporalKeysRepository
{
    public function __construct(
        private readonly PDO $pdo,
        private readonly AesCypherService $cipher
    ) {
        $this->clearTemp();
    }

    public function verifyToken(string $token): ?string
    {
        $current = $this->getCurrent();
        return $this->verifyTokenContent($token, $current['current'], $current['old']);
    }

    public function encrypt(string $value): ?string
    {
        $current = $this->getCurrent();
        return $this->cipher->encrypt($value, $current['current']);
    }

    public function verifyCypher(string $value): ?string
    {
        $current = $this->getCurrent();
        $dec = $this->cipher->decrypt($value, $current['current']);
        if (!$dec) {
            $dec = $this->cipher->decrypt($value, $current['current']) ?? '';
        }
        return $dec;
    }

    public function currentKey(): string
    {
        return ($this->getCurrent())['current'];
    }

    private function clearTemp()
    {
        $now = new \DateTimeImmutable();
        $row = $this->getCurrent();
        if ($row && $now > $row['expiration']) {
            $this->execute('UPDATE _oauth_temporal_keys set current = :new, old = :old, expiration = :expiration', $row['current']);
        } elseif (!$row) {
            $this->execute('INSERT INTO _oauth_temporal_keys (current, old, expiration) VALUES(:new, :old, :expiration)', '-');
        }
        $delCodes = $this->pdo->prepare('DELETE FROM _oauth_temporal_codes where expiration < :now');
        $delCodes->bindValue('now', $now->format('Y-m-d H:i:s'), PDO::PARAM_STR);
        $delCodes->execute();
    }

    private function execute($sql, $old)
    {
        $expires = (new \DateTimeImmutable())->add(new \DateInterval('PT1H'));
        $api = str_replace('\'', '"', Random::apiSecret());
        $stmt = $this->pdo->prepare($sql);
        $stmt->bindValue('new', $api, PDO::PARAM_STR);
        $stmt->bindValue('old', $old, PDO::PARAM_STR);
        $stmt->bindValue('expiration', $expires->format('Y-m-d H:i:s'), PDO::PARAM_STR);
        $stmt->execute();
    }

    private function getCurrent()
    {
        $stmt = $this->pdo->prepare('SELECT expiration, current, old FROM _oauth_temporal_keys');
        $stmt->execute();
        if ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
            return ['expiration' => new \DateTimeImmutable($row['expiration']), 'current' => $row['current'], 'old' => $row['old']];
        } else {
            return null;
        }
    }

    private function verifyTokenContent(
        string $token,
        string $key,
        ?string $fallback
    ): ?string {
        try {
            // Crear una clave JWK
            $jwk = new JWK([
                'kty' => 'oct',
                'k' => base64_encode($key),
            ]);

            // Crear un verificador JWS usando el algoritmo HS256
            $algorithm = new HS256();
            $jwsVerifier = new JWSVerifier(new AlgorithmManager([$algorithm]));

            // Crear un cargador de JWS (JSON Web Signature)
            $serializer = new CompactSerializer();

            // Cargar el token (JWS)
            $jws = $serializer->unserialize($token);

            // Verificar el JWS con la clave proporcionada
            $isVerified = $jwsVerifier->verifyWithKey($jws, $jwk, 0);

            if ($isVerified) {
                // Obtener el payload del token
                $payload = json_decode($jws->getPayload(), true);
                // Retornar el valor del claim 'identity', si existe
                return $payload['identity'] ?? null;
            } else {
                throw new \Exception("Signature verification failed");
            }
        } catch (\Exception $e) {
            if ($fallback === null) {
                // Log la excepción
                // $this->logger->warning('Unable to verify token', ['exception' => $e]);
                // Retornar un Optional vacío
                return null;
            } else {
                // Llamada recursiva con la clave de reserva (fallback)
                return $this->verifyTokenContent($token, $fallback, null);
            }
        }
    }

    public function registerTemporalAuthCode(TemporalAuthCode $code): string
    {
        $uid = Random::uuid();
        $encoded = json_encode($code);
        $expires = (new \DateTimeImmutable())->add(new \DateInterval('PT3M'));
        $stmt = $this->pdo->prepare('INSERT INTO _oauth_temporal_codes (code, code_data, expiration) VALUES (:code, :code_data, :expiration)');
        $stmt->bindValue('code', $uid, PDO::PARAM_STR);
        $stmt->bindValue('code_data', $encoded, PDO::PARAM_STR);
        $stmt->bindValue('expiration', $expires->format('Y-m-d H:i:s'), PDO::PARAM_STR);
        $stmt->execute();
        return $uid;
    }

    public function retrieveTemporalAuthCode(string $code): ?TemporalAuthCode
    {
        $now = (new \DateTimeImmutable());
        $stmt = $this->pdo->prepare('SELECT code_data FROM _oauth_temporal_codes where code = :code and expiration >= :now ');
        $stmt->bindValue('now', $now->format('Y-m-d H:i:s'), PDO::PARAM_STR);
        $stmt->bindValue('code', $code, PDO::PARAM_STR);
        $stmt->execute();
        if ($row = $stmt->fetch()) {
            $res = json_decode($row[0], true);
            $data = new AuthenticationResult(
                valid: $res['data']['valid'] ?? false,
                id: $res['data']['id'] ?? null,
                name: $res['data']['name'] ?? null,
                email: $res['data']['email'] ?? null,
                error: $res['data']['error'] ?? null,
                tenant: $res['data']['tenant'] ?? null,
                tenantName: $res['data']['tenantName'] ?? null,
                scope: $res['data']['scope'] ?? null,
                audiences: $res['data']['audiences'] ?? [],
                roles: $res['data']['roles'] ?? null,
                groups: $res['data']['groups'] ?? null
            );
            $client = new ClientData(
                id: $res['client']['id'] ?? '-',
                grants: $res['client']['grants'] ?? [],
                secretLogin: $res['client']['secretLogin'] ?? false,
            );
            $request = new AuthenticationRequest(
                client: $client,
                scope: $res['request']['scope'] ?? '-',
                redirect: $res['request']['redirect'] ?? '-',
                audiences: $res['request']['audiences'] ?? [],
            );
            $stmt = $this->pdo->prepare('DELETE FROM _oauth_temporal_codes where code = :code and expiration >= :now ');
            $stmt->bindValue('now', $now->format('Y-m-d H:i:s'), PDO::PARAM_STR);
            $stmt->bindValue('code', $code, PDO::PARAM_STR);
            $stmt->execute();
            return new TemporalAuthCode(
                data: $data,
                nonce: $res['nonce'] ?? '',
                client: $client,
                request: $request
            );
        } else {
            return null;
        }
    }
}
