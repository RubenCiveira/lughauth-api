<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Features\Access\Oidc\User\Infrastructure\Driven;

use Override;
use DateInterval;
use DateTimeImmutable;
use Civi\Lughauth\Shared\Value\Random;
use Civi\Lughauth\Shared\Exception\ConstraintException;
use Civi\Lughauth\Shared\Security\AesCypherService;
use Civi\Lughauth\Features\Access\Master\TenantConfig\Domain\Gateway\TenantConfigReadGateway;
use Civi\Lughauth\Features\Access\Master\User\Domain\Gateway\UserWriteGateway;
use Civi\Lughauth\Features\Access\Master\User\Domain\User;
use Civi\Lughauth\Features\Access\Master\User\Domain\UserApproveOptions;
use Civi\Lughauth\Features\Access\Master\User\Domain\ValueObject\UserPasswordVO;
use Civi\Lughauth\Features\Access\Master\UserAcceptedTermnsOfUse\Domain\Gateway\UserAcceptedTermnsOfUseWriteGateway;
use Civi\Lughauth\Features\Access\Master\UserAcceptedTermnsOfUse\Domain\UserAcceptedTermnsOfUse;
use Civi\Lughauth\Features\Access\Master\UserAcceptedTermnsOfUse\Domain\UserAcceptedTermnsOfUseAttributes;
use Civi\Lughauth\Features\Access\Master\UserAccessTemporalCode\Domain\Gateway\UserAccessTemporalCodeWriteGateway;
use Civi\Lughauth\Features\Access\Oidc\Common\Infrastructure\Driven\UserLoaderAdapter;
use Civi\Lughauth\Features\Access\Oidc\User\Domain\Gateway\RegisterUserRepository;

class RegisterUserAdapter implements RegisterUserRepository
{
    public function __construct(
        private readonly UserLoaderAdapter $users,
        private readonly TenantConfigReadGateway $configs,
        private readonly UserWriteGateway $repository,
        private readonly UserAccessTemporalCodeWriteGateway $codes,
        private readonly AesCypherService $cypher,
        private readonly UserAcceptedTermnsOfUseWriteGateway $writerUserTerms,
        private readonly Random $randomizer,
    ) {
    }

    #[Override]
    public function allowRegister(string $tenant): bool
    {
        $theTenant = $this->users->checkTenant($tenant, '-');
        $conf = $this->configs->findOneByTenant($theTenant);
        return ($conf && $conf->isAllowRegister());
    }

    #[Override]
    public function getRegisterConsent(string $tenant): ?string
    {
        $theTenant = $this->users->checkTenant($tenant, '-');
        $terms = $this->users->loadTenantTerms($theTenant);
        return $terms ? $terms->getText() : '';
    }

    #[Override]
    public function requestForRegister(string $url, string $tenant, string $email, string $password)
    {
        $theTenant = $this->users->checkTenant($tenant, '-');
        $conf = $this->configs->findOneByTenant($theTenant);
        try {
            if ($conf && $conf->isAllowRegister()) {
                $theTenant = $this->users->checkTenant($tenant, '-');
                $terms = $this->users->loadTenantTerms($theTenant);
                $theUser = $this->repository->create(User::register(
                    uid:  $this->randomizer->comb(),
                    name: $email,
                    email: $email,
                    cypher: $this->cypher,
                    password: $password,
                    tenant: $theTenant
                ));
                if ($terms) {
                    $acepted = new UserAcceptedTermnsOfUseAttributes();
                    $acepted->uid(Random::comb());
                    $acepted->user($theUser);
                    $acepted->conditions($terms);
                    $acepted->acceptDate(new DateTimeImmutable());
                    $this->writerUserTerms->create(UserAcceptedTermnsOfUse::create($acepted));
                }
                $code = $this->users->userCodeForUpdate($theUser);
                $verify = md5($this->randomizer->comb());
                $this->users->updateCode($code->generatedRegisterVerification($verify, str_ends_with($url, '=') ? $url . $verify : $url, new DateTimeImmutable()->add(new DateInterval("P1D"))));
            }
        } catch (ConstraintException $ex) {
            // Noting to do on a not-unique
            if (!$ex->includeViolationCode('not-unique')) {
                throw $ex;
            } else {
                $theUser = $this->repository->findOneForUpdateByTenantAndName($theTenant, $email);
                if ($theUser->getApprove() == UserApproveOptions::UNVERIFIED) {
                    $att = $theUser->toAttributes();
                    $att->password(UserPasswordVO::fromPlainText($this->cypher, $password));
                    $updated = $this->repository->update($theUser, $theUser->replace($att));
                    $code = $this->users->userCodeForUpdate($updated);
                    $verify = md5($this->randomizer->comb());
                    // str_ends_with($url, '=') ? $url . $verify : $url
                    $this->users->updateCode($code->generatedRegisterVerification($verify, 'every', new DateTimeImmutable()->add(new DateInterval("P1D"))));
                }
            }
        }
    }

    #[Override]
    public function verifyRegister(string $tenant, string $code): ?string
    {
        $theTenant = $this->users->checkTenant($tenant, '-');
        [$user, $userCode] = $this->users->checkUserByRegisterCode($theTenant, $code);
        if ($code !== $userCode->getRegisterCode()) {
            return null;
        }
        $conf = $this->configs->findOneByTenant($theTenant);
        $this->repository->update($user, $user->verify(
            $conf?->isEnableRegisterUsers() ? UserApproveOptions::ACCEPTED : UserApproveOptions::PENDING
        ));
        $this->codes->update($userCode, $userCode->resetRegisterVerification());
        return $user->getName();
    }
}
