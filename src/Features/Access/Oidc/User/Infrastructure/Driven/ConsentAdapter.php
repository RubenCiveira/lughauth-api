<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Features\Access\Oidc\User\Infrastructure\Driven;

use Override;
use DateTimeImmutable;
use Civi\Lughauth\Shared\Value\Random;
use Civi\Lughauth\Features\Access\Master\TenantTermsOfUse\Domain\Gateway\TenantTermsOfUseReadGateway;
use Civi\Lughauth\Features\Access\Master\UserAcceptedTermnsOfUse\Domain\Gateway\UserAcceptedTermnsOfUseWriteGateway;
use Civi\Lughauth\Features\Access\Master\UserAcceptedTermnsOfUse\Domain\UserAcceptedTermnsOfUse;
use Civi\Lughauth\Features\Access\Master\UserAcceptedTermnsOfUse\Domain\UserAcceptedTermnsOfUseAttributes;
use Civi\Lughauth\Features\Access\Oidc\Common\Infrastructure\Driven\UserLoaderAdapter;
use Civi\Lughauth\Features\Access\Oidc\User\Domain\Gateway\ConsentRepository;

class ConsentAdapter implements ConsentRepository
{
    public function __construct(
        private readonly UserLoaderAdapter $users,
        private readonly TenantTermsOfUseReadGateway $terms,
        private readonly UserAcceptedTermnsOfUseWriteGateway $writerUserTerms,
    ) {
    }

    #[Override]
    public function getPendingConsent(string $tenant, string $username): ?string
    {
        $theTenant = $this->users->checkTenant($tenant, $username);
        $terms = $this->users->loadTenantTerms($theTenant);
        return $terms ? $terms->getText() : null;
    }

    #[Override]
    public function storeAcceptedConsent(string $tenant, string $username): void
    {
        $theTenant = $this->users->checkTenant($tenant, $username);
        $theUser = $this->users->checkUser($theTenant, $username);
        $terms = $this->users->loadTenantTerms($theTenant);
        $acepted = new UserAcceptedTermnsOfUseAttributes();
        $acepted->uid(Random::comb());
        $acepted->user($theUser);
        $acepted->conditions($terms);
        $acepted->acceptDate(new DateTimeImmutable());
        $this->writerUserTerms->create(UserAcceptedTermnsOfUse::create($acepted));
    }
}
