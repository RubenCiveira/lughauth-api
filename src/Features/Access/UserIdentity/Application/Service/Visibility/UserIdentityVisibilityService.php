<?php

# @autogenerated
declare(strict_types=1);

namespace Civi\Lughauth\Features\Access\UserIdentity\Application\Service\Visibility;

use Psr\EventDispatcher\EventDispatcherInterface;
use Throwable;
use Civi\Lughauth\Features\Access\User\Application\Service\Visibility\UserVisibilityService;
use Civi\Lughauth\Features\Access\RelyingParty\Application\Service\Visibility\RelyingPartyVisibilityService;
use Civi\Lughauth\Features\Access\TrustedClient\Application\Service\Visibility\TrustedClientVisibilityService;
use Civi\Lughauth\Features\Access\UserIdentity\Domain\ValueObject\UserIdentityRolesListRef;
use Civi\Lughauth\Features\Access\Role\Application\Service\Visibility\RoleVisibilityService;
use Civi\Lughauth\Shared\Exception\NotFoundException;
use Civi\Lughauth\Features\Access\UserIdentity\Domain\UserIdentityRef;
use Civi\Lughauth\Features\Access\UserIdentity\Domain\UserIdentityAttributes;
use Civi\Lughauth\Features\Access\UserIdentity\Domain\UserIdentity;
use Civi\Lughauth\Features\Access\UserIdentity\Domain\Gateway\UserIdentityFilter;
use Civi\Lughauth\Features\Access\UserIdentity\Domain\Gateway\UserIdentityCursor;
use Civi\Lughauth\Features\Access\UserIdentity\Domain\Gateway\UserIdentityReadGateway;
use Civi\Lughauth\Features\Access\UserIdentity\Domain\Gateway\UserIdentitySlide;
use Civi\Lughauth\Features\Access\UserIdentity\Domain\Gateway\UserIdentityWriteGateway;
use Civi\Lughauth\Shared\Observability\LoggerAwareTrait;
use Civi\Lughauth\Shared\Observability\TracerAwareTrait;

class UserIdentityVisibilityService
{
    use LoggerAwareTrait;
    use TracerAwareTrait;

    public function __construct(
        private readonly EventDispatcherInterface $dispacher,
        private readonly UserIdentityReadGateway $readGateway,
        private readonly UserIdentityWriteGateway $writeGateway,
        private readonly UserVisibilityService $userVisibilityService,
        private readonly RelyingPartyVisibilityService $relyingPartyVisibilityService,
        private readonly TrustedClientVisibilityService $trustedClientVisibilityService,
        private readonly RoleVisibilityService $roleVisibilityService
    ) {
    }

    public function prepareVisibleDataInList(UserIdentity $content): UserIdentityAttributes
    {
        return $this->prepareVisibleDataCallback($content, true);
    }
    public function prepareVisibleData(UserIdentity $content): UserIdentityAttributes
    {
        return $this->prepareVisibleDataCallback($content, false);
    }
    public function copyWithFixed(UserIdentityAttributes $attributes, ?UserIdentity $original = null): UserIdentityAttributes
    {
        $this->logDebug("Copy with fixed for User identity");
        $span = $this->startSpan("Copy with fixed for  User identity");
        try {
            $visible = $this->visiblesReferences($attributes);
            $fixed = $this->fieldsToFix($original);
            foreach ($fixed as $field) {
                $visible->unset($field);
            }
            $result = $this->dispacher->dispatch(new UserIdentityPresetValues($attributes, $original));
            return $result->attributes;
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }

    public function copyWithHidden(UserIdentityAttributes $attributes, ?UserIdentity $original = null): UserIdentityAttributes
    {
        $this->logDebug("Copy with hidden for User identity");
        $span = $this->startSpan("Copy with hidden for  User identity");
        try {
            $hidden = $this->fieldsToHide($original);
            foreach ($hidden as $field) {
                $attributes->unset($field);
            }
            return $attributes;
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }

    public function checkVisibility(\Iterator|string|UserIdentityRef $value): bool
    {
        $this->logDebug("Check visibility of an iterator for User identity");
        $span = $this->startSpan("Check visibility of an iterator for  User identity");
        try {
            if (is_a($value, \Iterator::class)) {
                $ids = [];
                foreach ($value as $val) {
                    $ids[] = $val->uid();
                }
                $filter = new UserIdentityFilter(uids: $ids);
                return count($ids) == $this->countVisibles($filter);
            } elseif (is_a($value, UserIdentityRef::class)) {
                return !!$this->retrieveVisibleForUpdate($value);
            } else {
                return !!$this->retrieveVisibleForUpdate(new UserIdentityRef($value));
            }
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function listVisibles(UserIdentityFilter $filter, ?UserIdentityCursor $cursor = null): UserIdentitySlide
    {
        $this->logDebug("List visibles for User identity");
        $span = $this->startSpan("List visibles for  User identity");
        try {
            $visibleFilter = $this->applyPreVisibilityFilter($filter);
            $result = $this->readGateway->list($visibleFilter, $cursor);
            return $result->slide(function ($item) {
                return $this->evaluatePostVisibility($item);
            });
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function countVisibles(UserIdentityFilter $filter): int
    {
        $this->logDebug("Count visibles for User identity");
        $span = $this->startSpan("Count visibles for  User identity");
        try {
            $visibleFilter = $this->applyPreVisibilityFilter($filter);
            return $this->readGateway->count($visibleFilter);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function listVisiblesForUpdate(UserIdentityFilter $filter, ?UserIdentityCursor $cursor = null): UserIdentitySlide
    {
        $this->logDebug("List visibles for update for User identity");
        $span = $this->startSpan("List visibles for update for  User identity");
        try {
            $visibleFilter = $this->applyPreVisibilityFilter($filter);
            $result = $this->writeGateway->listForUpdate($visibleFilter, $cursor);
            return $result->slide(function ($item) {
                return $this->evaluatePostVisibility($item);
            });
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function countVisiblesForUpdate(UserIdentityFilter $filter): int
    {
        $this->logDebug("Count visibles for update for User identity");
        $span = $this->startSpan("Count visibles for update for  User identity");
        try {
            $visibleFilter = $this->applyPreVisibilityFilter($filter);
            return $this->writeGateway->countForUpdate($visibleFilter);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function retrieveVisible(UserIdentityRef $ref): ?UserIdentity
    {
        $this->logDebug("Retrieve visible for User identity");
        $span = $this->startSpan("Retrieve visible for  User identity");
        try {
            $filter = new UserIdentityFilter(uids: [$ref->uid()]);
            $visibleFilter = $this->applyPreVisibilityFilter($filter);
            if ($readed = $this->readGateway->retrieve($visibleFilter)) {
                return $this->evaluatePostVisibility($readed) ? $readed : null;
            } else {
                return null;
            }
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function retrieveVisibleForUpdate(UserIdentityRef $ref): ?UserIdentity
    {
        $this->logDebug("Retrieve visible for update for User identity");
        $span = $this->startSpan("Retrieve visible for update for  User identity");
        try {
            $filter = new UserIdentityFilter(uids: [$ref->uid()]);
            $visibleFilter = $this->applyPreVisibilityFilter($filter);
            if ($readed = $this->writeGateway->retrieveForUpdate($visibleFilter)) {
                return $this->evaluatePostVisibility($readed) ? $readed : null;
            } else {
                return null;
            }
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function fieldsToFix(?UserIdentityRef $ref = null): array
    {
        $this->logDebug("Check fields to fix for User identity");
        $span = $this->startSpan("Check fields for fix for User identity");
        try {
            $result = $this->dispacher->dispatch(new UserIdentityCollectNonEditableFields(UserIdentity::calculatedFields(), $ref));
            return array_unique(array_merge($this->fieldsToHide($ref), $result->fields));
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }

    public function fieldsToHide(?UserIdentityRef $ref = null): array
    {
        $this->logDebug("Check fields to hide for User identity");
        $span = $this->startSpan("Check fields to hide for  User identity");
        try {
            $result = $this->dispacher->dispatch(new UserIdentityCollectNonVisibleFields([], $ref));
            return array_unique($result->fields);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }

    private function visiblesReferences(UserIdentityAttributes $attributes): UserIdentityAttributes
    {
        $this->logDebug("Check visibility of parent references for User identity");
        $span = $this->startSpan("Check visibility of parent references for  User identity");
        try {
            if ($attributes->getUser() && !$this->userVisibilityService->checkVisibility($attributes->getUser())) {
                throw new NotFoundException("Unknow User " . $attributes->getUser());
            }
            if ($attributes->getRelyingParty() && !$this->relyingPartyVisibilityService->checkVisibility($attributes->getRelyingParty())) {
                throw new NotFoundException("Unknow RelyingParty " . $attributes->getRelyingParty());
            }
            if ($attributes->getTrustedClient() && !$this->trustedClientVisibilityService->checkVisibility($attributes->getTrustedClient())) {
                throw new NotFoundException("Unknow TrustedClient " . $attributes->getTrustedClient());
            }
            if ($attributes->getRoles() && !$this->checkVisibilityForRoles($attributes->getRoles())) {
                throw new NotFoundException("Unknow Roles " . $attributes->getRoles()->uid());
            }
            return $attributes;
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function applyPreVisibilityFilter(UserIdentityFilter $filter)
    {
        $this->logDebug("Compose visibility filter for User identity");
        $span = $this->startSpan("Compose visibility filter for  User identity");
        try {
            $result = $this->dispacher->dispatch(new UserIdentityRestrictFilterToVisibility($filter));
            return $result->userIdentityFilter;
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function checkVisibilityForRoles(UserIdentityRolesListRef $items): UserIdentityRolesListRef
    {
        $this->logDebug("Copy with fixed for User identity");
        $span = $this->startSpan("Copy with fixed for  User identity");
        try {
            foreach ($items as $item) {
                if ($item->getRole() && !$this->roleVisibilityService->checkVisibility($item->getRole())) {
                    throw new NotFoundException("Unknow Role " . $item->getRole()->uid());
                }
            }
            return $items;
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function evaluatePostVisibility(UserIdentity $value): bool
    {
        $this->logDebug("Check if item is visible for User identity");
        $span = $this->startSpan("Check if item is visible for  User identity");
        try {
            $result = $this->dispacher->dispatch(new UserIdentityVisibilityCheck(true, $value));
            return $result->visible;
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function prepareVisibleDataCallback(UserIdentity $content, bool $inlist): UserIdentityAttributes
    {
        $this->logDebug("Prepare hidratation to visible data for User identity");
        $span = $this->startSpan("Prepare hidratation to visible data for User identity");
        try {
            $attributes = $content->toAttributes();
            $result = $this->dispacher->dispatch(new UserIdentityEnrichForView($content, $inlist, $attributes));
            return $result->getAttributes();
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
}
