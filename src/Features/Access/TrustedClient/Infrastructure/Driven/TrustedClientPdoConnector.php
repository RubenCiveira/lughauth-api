<?php

# @autogenerated
declare(strict_types=1);

namespace Civi\Lughauth\Features\Access\TrustedClient\Infrastructure\Driven;

use Throwable;
use Closure;
use Civi\Lughauth\Shared\Infrastructure\Sql\SqlParam;
use Civi\Lughauth\Shared\Infrastructure\Sql\SqlTemplate;
use Civi\Lughauth\Shared\Exception\NotFoundException;
use Civi\Lughauth\Shared\Exception\NotUniqueException;
use Civi\Lughauth\Shared\Exception\ConstraintException;
use Civi\Lughauth\Shared\Exception\OptimistLockException;
use Civi\Lughauth\Shared\Exception\NotEmptyChildsException;
use Civi\Lughauth\Features\Access\TrustedClient\Domain\Gateway\TrustedClientFilter;
use Civi\Lughauth\Features\Access\TrustedClient\Domain\Gateway\TrustedClientCursor;
use Civi\Lughauth\Features\Access\TrustedClient\Domain\TrustedClient;
use Civi\Lughauth\Features\Access\TrustedClient\Domain\TrustedClientRef;
use Civi\Lughauth\Shared\Observability\LoggerAwareTrait;
use Civi\Lughauth\Shared\Observability\TracerAwareTrait;
use Civi\Lughauth\Features\Access\TrustedClient\Domain\ValueObject\TrustedClientAllowedRedirectsItem;
use Civi\Lughauth\Features\Access\TrustedClient\Domain\ValueObject\TrustedClientAllowedRedirectsListRef;
use Civi\Lughauth\Shared\Value\Random;
use Civi\Lughauth\Features\Access\TrustedClient\Domain\ValueObject\TrustedClientSecretOauthVO;
use Civi\Lughauth\Shared\Security\AesCypherService;
use Civi\Lughauth\Features\Access\TrustedClient\Domain\ValueObject\TrustedClientAllowedRedirectsVO;
use Civi\Lughauth\Features\Access\TrustedClient\Domain\ValueObject\TrustedClientAllowedRedirectsUidVO;
use Civi\Lughauth\Features\Access\TrustedClient\Domain\ValueObject\TrustedClientAllowedRedirectsUrlVO;
use Civi\Lughauth\Features\Access\TrustedClient\Domain\ValueObject\TrustedClientAllowedRedirectsVersionVO;

class TrustedClientPdoConnector
{
    use LoggerAwareTrait;
    use TracerAwareTrait;

    public function __construct(
        private readonly AesCypherService $cypher,
        private readonly SqlTemplate $db,
    ) {
    }
    public function list(?TrustedClientFilter $filter = null, ?TrustedClientCursor $sort = null): array
    {
        $this->logDebug("List query for Trusted client");
        $span = $this->startSpan("List query for Trusted client");
        try {
            $sqlFilter = $this->filter($filter, $sort, false);
            return $this->query($sqlFilter['query'], $sqlFilter['params']);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function listForUpdate(?TrustedClientFilter $filter = null, ?TrustedClientCursor $sort = null): array
    {
        $this->logDebug("List query for update of Trusted client");
        $span = $this->startSpan("List query for update of Trusted client");
        try {
            $sqlFilter = $this->filter($filter, $sort, false);
            return $this->queryForUpdate($sqlFilter['query'], $sqlFilter['params']);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function query(string $query, ?array $params = []): array
    {
        return $this->theQuery(false, $query, $params);
    }
    private function rawQuery(string $query, ?array $params = []): array
    {
        return $this->theRawQuery(false, $query, $params);
    }
    private function queryForUpdate(string $query, ?array $params = []): array
    {
        return $this->theQuery(true, $query, $params);
    }
    private function rawQueryForUpdate(string $query, ?array $params = []): array
    {
        return $this->theRawQuery(true, $query, $params);
    }
    private function theQuery(bool $forUpdate, string $query, ?array $params = []): array
    {
        $this->logDebug("Make query for entities for Trusted client");
        $span = $this->startSpan("Make query for entities for Trusted client");
        try {
            return $this->queryWithChilds($forUpdate, $query, $params);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function theRawQuery(bool $forUpdate, string $query, ?array $params = []): array
    {
        $this->logDebug("Make raw query for Trusted client");
        $span = $this->startSpan("Make raw query for Trusted client");
        try {
            return $this->db->query($query, $params, fn ($row) => $row);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function retrieve(TrustedClientFilter $filter): ?TrustedClient
    {
        $this->logDebug("Retrieve query for Trusted client");
        $span = $this->startSpan("Retrieve query for Trusted client");
        try {
            $sqlFilter = $this->filter($filter, null, false);
            return $this->findOneWithChilds(false, $sqlFilter['query'], $sqlFilter['params']);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function retrieveForUpdate(TrustedClientFilter $filter): ?TrustedClient
    {
        $this->logDebug("Retrieve query for update of Trusted client");
        $span = $this->startSpan("Retrieve query for update of Trusted client");
        try {
            $sqlFilter = $this->filter($filter, null, false);
            return $this->findOneWithChilds(true, $sqlFilter['query'], $sqlFilter['params']);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function create(TrustedClient $entity, ?Closure $verify = null): TrustedClient
    {
        $this->logDebug("Execute insert sql query for Trusted client");
        $span = $this->startSpan("Execute insert sql query for Trusted client");
        try {
            try {
                $this->db->execute('INSERT INTO "access_trusted_client" ( "uid", "code", "public_allow", "secret_oauth", "enabled", "version") VALUES ( :uid, :code, :publicAllow, :secretOauth, :enabled, :version)', [
                     new SqlParam(name: 'uid', value: $entity->uid(), type: SqlParam::STR),
                     new SqlParam(name: 'code', value: $entity->getCode(), type: SqlParam::STR),
                     new SqlParam(name: 'publicAllow', value: $entity->isPublicAllow(), type: SqlParam::BOOL),
                     new SqlParam(name: 'secretOauth', value: $entity->getCypheredSecretOauth($this->cypher), type: SqlParam::STR),
                     new SqlParam(name: 'enabled', value: $entity->isEnabled(), type: SqlParam::BOOL),
                     new SqlParam(name: 'version', value: 0, type: SqlParam::INT)
                ]);
                $entity = $this->saveChilds($entity);
            } catch (NotUniqueException $ex) {
                $this->checkDuplicates($entity, true);
                throw $ex;
            }
            $created = $entity->withVersion(0);
            if ($verify && !$verify($created)) {
                $this->db->execute('DELETE FROM "access_trusted_client" where "uid" = :uid', [
                  new SqlParam(name: 'uid', value: $entity->uid(), type: SqlParam::STR)
                ]);
                throw new NotFoundException('Insertion of not visible values');
            }
            return $created;
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function update(TrustedClient $update): ?TrustedClient
    {
        $this->logDebug("Execute update sql query for Trusted client");
        $span = $this->startSpan("Execute update sql query for Trusted client");
        try {
            try {
                $result = $this->db->execute('UPDATE "access_trusted_client" SET "code" = :code , "public_allow" = :publicAllow , "secret_oauth" = :secretOauth , "enabled" = :enabled , "version" = :version WHERE "uid" = :uid and "version" = :_lock_version', [
                     new SqlParam(name: 'uid', value: $update->uid(), type: SqlParam::STR),
                     new SqlParam(name: 'code', value: $update->getCode(), type: SqlParam::STR),
                     new SqlParam(name: 'publicAllow', value: $update->isPublicAllow(), type: SqlParam::BOOL),
                     new SqlParam(name: 'secretOauth', value: $update->getCypheredSecretOauth($this->cypher), type: SqlParam::STR),
                     new SqlParam(name: 'enabled', value: $update->isEnabled(), type: SqlParam::BOOL),
                     new SqlParam(name: 'version', value: $update->getVersion() + 1, type: SqlParam::INT),
                     new SqlParam(name: '_lock_version', value: $update->getVersion(), type: SqlParam::INT)
                ]);
                if (!$result && $this->db->exists('select "uid" from "access_trusted_client" where "uid" = :uid', ['uid' => $update->uid() ])) {
                    throw new OptimistLockException($update->uid(), "version: " . $update->getVersion());
                } elseif (!$result) {
                    throw new NotFoundException($update->uid());
                }
                $update = $this->saveChilds($update);
            } catch (NotUniqueException $ex) {
                $this->checkDuplicates($update, false);
                throw $ex;
            }
            return $update->withVersion($update->getVersion() + 1);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function delete(TrustedClientRef $ref): bool
    {
        $this->logDebug("Execute delete sql query for Trusted client");
        $span = $this->startSpan("Execute delete sql query for Trusted client");
        try {
            try {
                $this->db->execute('DELETE FROM "access_trusted_client_allowed_redirect" where "client" = :parent', [new SqlParam(name:'parent', value:$ref->uid(), type:SqlParam::STR) ]);
                return $this->db->execute('DELETE FROM "access_trusted_client" where "uid" = :uid', [new SqlParam(name: 'uid', value: $ref->uid(), type:SqlParam::STR)]);
            } catch (NotEmptyChildsException $ex) {
                throw ConstraintException::ofError('not-empty', ['uid'], [$ref->uid()]);
            }
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function exists(TrustedClientFilter $filter): bool
    {
        $this->logDebug("Execute exists sql query for Trusted client");
        $span = $this->startSpan("Execute exists sql query for Trusted client");
        try {
            $sqlFilter = $this->filter($filter, null, false);
            return $this->db->exists($sqlFilter['query'], $sqlFilter['params']);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function existsForUpdate(TrustedClientFilter $filter): bool
    {
        $this->logDebug("Execute exists sql query for update of Trusted client");
        $span = $this->startSpan("Execute update sql query for update of Trusted client");
        try {
            $sqlFilter = $this->filter($filter, null, false);
            return $this->db->existsForUpdate($sqlFilter['query'], $sqlFilter['params']);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function count(?TrustedClientFilter $filter = null): int
    {
        $this->logDebug("Execute count sql query for Trusted client");
        $span = $this->startSpan("Execute count sql query for Trusted client");
        try {
            $sqlFilter = $this->filter($filter, null, true);
            return $this->db->findOne($sqlFilter['query'], $sqlFilter['params'], fn ($row) => $row['count']);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    public function countForUpdate(?TrustedClientFilter $filter = null): int
    {
        $this->logDebug("Execute count sql query for update of Trusted client");
        $span = $this->startSpan("Execute count sql query for update of Trusted client");
        try {
            $sqlFilter = $this->filter($filter, null, true);
            return $this->db->findOneForUpdate($sqlFilter['query'], $sqlFilter['params'], fn ($row) => $row['count']);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function checkDuplicates(TrustedClient $entity, bool $creation)
    {
        $this->logDebug("Query to check duplicates for Trusted client");
        $span = $this->startSpan("Query to check duplicates for Trusted client");
        try {
            $values = ['uid' => $entity->uid()];
            if ($creation &&  $this->db->exists('SELECT  "uid" from "access_trusted_client" where "uid" = :uid', $values)) {
                throw ConstraintException::ofError('not-unique', array_keys($values), array_values($values));
            }
            $values = ['code' => $entity->getCode(), 'uid' => $entity->uid()];
            if ($this->db->exists('SELECT  "code" from "access_trusted_client" where "code" = :code and "uid" != :uid', $values)) {
                throw ConstraintException::ofError('not-unique', ['code'], [$entity->getCode()]);
            }
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function filter(?TrustedClientFilter $filter, ?TrustedClientCursor $sort, bool $count)
    {
        $this->logDebug("Build query filter of Trusted client");
        $span = $this->startSpan("Build query filter of Trusted client");
        try {
            $join = '';
            $query = '';
            $params = [];
            $order = '';
            $limit = '';
            if ($filter) {
                $filterUids = $filter->uids();
                if ($filterUids && count($filterUids) > 1) {
                    $query .= ' and "uid" in (:uids)';
                    $params[] = new SqlParam(name:'uids', value: $filterUids, type: SqlParam::STR);
                } elseif ($filterUids) {
                    $query .= ' and "uid" = :uid';
                    $params[] = new SqlParam(name:'uid', value: $filterUids[0], type: SqlParam::STR);
                }
                $filterSearch = $filter->search();
                if ($filterSearch) {
                    $query .= ' and ( "code" like :search)';
                    $params[] = new SqlParam(name:'search', value: '%'. $filterSearch . '%', type: SqlParam::STR);
                }
                $filterCode = $filter->code();
                if ($filterCode) {
                    $query .= ' and "code" = :code';
                    $params[] = new SqlParam(name: 'code', value: $filterCode, type: SqlParam::STR);
                }
                if ($filterCode = $filter->code()) {
                    $query .= ' and "code" = :code ';
                    $params[] = new SqlParam(name: 'code', value: $filterCode, type: SqlParam::STR);
                }
            }
            if ($sort) {
                $sortLimit = $sort->limit();
                if ($sortLimit) {
                    $limit = ' LIMIT ' . $this->db->escapeValue($sortLimit, SqlParam::INT);
                }
                $sortOrder = $sort->order();
                if ($sortOrder) {
                    foreach ($sortOrder as $ord) {
                        $equals = '';
                        if ($ord === 'codeAsc') {
                            $sortSinceCode = $sort->sinceCode();
                            if ($sortSinceCode) {
                                $query .= " and " . ($equals ? substr($equals, 4) . ' and ' : '') . ' "code" > :sinceCode';
                                $equals .= ' and "code" = :sinceCode';
                                $params[] = new SqlParam(name: 'sinceCode', value: $sortSinceCode, type: SqlParam::STR);
                            }
                            $order .= ', "access_trusted_client"."code" asc';
                        }
                        if ($ord === 'codeDesc') {
                            $sortSinceCode = $sort->sinceCode();
                            if ($sortSinceCode) {
                                $query .= " and " . ($equals ? substr($equals, 4) . ' and ' : '') . ' "code" < :sinceCode';
                                $equals .= ' and "code" = :sinceCode';
                                $params[] = new SqlParam(name: 'sinceCode', value: $sortSinceCode, type: SqlParam::STR);
                            }
                            $order .= ', "access_trusted_client"."code" desc';
                        }
                    }
                } else {
                    $sortSinceUid = $sort->sinceUid();
                    if ($sortSinceUid) {
                        $query .= ' and  "uid" < :sinceUid';
                        $params[] = new SqlParam(name: 'sinceUid', value: $sortSinceUid, type: SqlParam::STR);
                    }
                    $order = ', "access_trusted_client"."uid" desc';
                }
            }
            return [
              'query' => 'SELECT '.($count ? ' count(*) as count ' : '*').' FROM "access_trusted_client"'
                . $join
                . ($query ? ' WHERE ' . substr($query, 4) : '')
                . ($order ? ' ORDER BY ' . substr($order, 2) : '') . $limit,
              'params' => $params];
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function saveChilds(TrustedClient $parent): TrustedClient
    {
        $this->logDebug("Execute save childs sql query for Trusted client");
        $span = $this->startSpan("Execute save childs sql query for Trusted client");
        try {
            $allowedRedirects = $parent->getAllowedRedirects();
            if ($allowedRedirects) {
                $uids = [];
                $saved = [];
                foreach ($allowedRedirects as $child) {
                    if (!$this->existsAllowedRedirects($parent->uid(), $child->uid())) {
                        $insertedChild = $this->insertAllowedRedirects($parent->uid(), $child);
                        $saved[] = $insertedChild;
                        $uids[] = $insertedChild->uid();
                    } else {
                        $updatedChild = $this->updateAllowedRedirects($parent->uid(), $child);
                        $saved[] = $updatedChild;
                        $uids[] = $updatedChild->uid();
                    }
                }
                $this->db->execute('DELETE FROM "access_trusted_client_allowed_redirect" WHERE "client" = :parent and  "uid" NOT IN (:uids)', [
                  new SqlParam(name: 'parent', value: $parent->uid(), type: SqlParam::STR),
                  new SqlParam(name: 'uids', value: $uids, type: SqlParam::STR),
                ]);
                $parent = $parent->withAllowedRedirects(TrustedClientAllowedRedirectsListRef::fromArray($saved));
            }
            return $parent;
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function insertAllowedRedirects(string $entity, TrustedClientAllowedRedirectsItem $child): TrustedClientAllowedRedirectsItem
    {
        $this->logDebug("Execute insert AllowedRedirects childs sql query for Trusted client");
        $span = $this->startSpan("Execute insert AllowedRedirects childs sql query for Trusted client");
        try {
            $uid = $child->uid() ?? Random::comb();
            if (!$this->db->execute('insert into "access_trusted_client_allowed_redirect" ("uid", "client", "url", "version") VALUES(:uid, :client, :url, :version) ', [
                new SqlParam(name: 'uid', value: $uid, type: SqlParam::STR),
                new SqlParam(name: 'client', value: $entity, type: SqlParam::STR),
                new SqlParam(name: 'url', value: $child->getUrl(), type: SqlParam::STR),
                new SqlParam(name: 'version', value: $child->getVersion() ?? 0, type: SqlParam::INT),
            ])) {
                throw new OptimistLockException("Insert child TrustedClientAllowedRedirectsItem for TrustedClient", $uid);
            }
            return $child->withVersion(0);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function updateAllowedRedirects(string $entity, TrustedClientAllowedRedirectsItem $child): TrustedClientAllowedRedirectsItem
    {
        $this->logDebug("Execute insert AllowedRedirects childs sql query for Trusted client");
        $span = $this->startSpan("Execute insert AllowedRedirects childs sql query for Trusted client");
        try {
            $uid = $child->uid();
            if (!$this->db->execute('update "access_trusted_client_allowed_redirect" set "url" = :url, "version" = :nextVersion where "uid" = :uid and "client" = :client and "version" = :version ', [
                new SqlParam(name: 'uid', value: $uid, type: SqlParam::STR),
                new SqlParam(name: 'client', value: $entity, type: SqlParam::STR),
                new SqlParam(name: 'url', value: $child->getUrl(), type: SqlParam::STR),
                new SqlParam(name: 'nextVersion', value: ($child->getVersion() ?? 0) + 1, type: SqlParam::INT),
                new SqlParam(name: 'version', value: $child->getVersion() ?? 0, type: SqlParam::INT),
            ])) {
                throw new OptimistLockException("Update child TrustedClientAllowedRedirectsItem for TrustedClient", $uid);
            }
            return $child->withVersion($child->getVersion() + 1);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function existsAllowedRedirects($entity, $reference): bool
    {
        $this->logDebug("Execute exsits AllowedRedirects childs sql query for Trusted client");
        $span = $this->startSpan("Execute exists AllowedRedirects childs sql query for Trusted client");
        try {
            return $this->db->exists('select * from "access_trusted_client_allowed_redirect" where "client" = :entity and "uid" = :uid', [
                new SqlParam(name: 'entity', value: $entity, type: SqlParam::STR),
                new SqlParam(name: 'uid', value: $reference, type: SqlParam::STR),
            ]);
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function mapper($row): TrustedClient
    {
        $this->logDebug("Mapping from sql to entity for Trusted client");
        $span = $this->startSpan("Mapping from sql to enttiy for Trusted client");
        try {
            return new TrustedClient(
                uid: $row['uid'] ?? null,
                code: $row['code'] ?? null,
                publicAllow: isset($row['public_allow']) ? !! $row['public_allow'] : null,
                secretOauth: isset($row['secret_oauth']) && $row['secret_oauth'] ? TrustedClientSecretOauthVO::fromCypheredText($this->cypher, $row['secret_oauth']) : TrustedClientSecretOauthVO::empty(),
                enabled: isset($row['enabled']) ? !! $row['enabled'] : null,
                allowedRedirects: TrustedClientAllowedRedirectsVO::from(TrustedClientAllowedRedirectsListRef::fromArray($row['allowed_redirects'] ?? [])),
                version: $row['version'] ?? null,
            );
        } catch (Throwable $ex) {
            $span->recordException($ex);
            throw $ex;
        } finally {
            $span->end();
        }
    }
    private function queryWithChilds(bool $forUpdate, string $query, ?array $params = []): array
    {
        $values = $forUpdate ? $this->db->queryForUpdate($query, $params, fn ($row) => $row) : $this->db->query($query, $params, fn ($row) => $row);
        $mapped = [];
        $ids = [];
        foreach ($values as $value) {
            $ids[] = $value['uid'];
            $value['allowed_redirects'] = [];
            $mapped[$value['uid']] = $value;
        }
        $childsAllowedRedirects = $forUpdate ? $this->db->queryForUpdate('select "uid", "client", "url", "version" from "access_trusted_client_allowed_redirect" where "client" in (:parents)', [
          new SqlParam(name: 'parents', value: $ids, type: SqlParam::STR)
        ]) : $this->db->query('select "uid", "client", "url", "version" from "access_trusted_client_allowed_redirect" where "client" in (:parents)', [
          new SqlParam(name: 'parents', value: $ids, type: SqlParam::STR)
        ]);
        foreach ($childsAllowedRedirects as $childAllowedRedirects) {
            $parent = $childAllowedRedirects['client'];
            $mapped[$parent]['allowed_redirects'][] = new TrustedClientAllowedRedirectsItem(
                uid: TrustedClientAllowedRedirectsUidVO::from($childAllowedRedirects['uid']),
                url: TrustedClientAllowedRedirectsUrlVO::from($childAllowedRedirects['url']),
                version: TrustedClientAllowedRedirectsVersionVO::from($childAllowedRedirects['version']),
            );
        }
        return array_values(array_map(fn ($row) => $this->mapper($row), $mapped));
    }
    private function findOneWithChilds(bool $forUpdate, string $query, ?array $params = []): ?TrustedClient
    {
        if ($value = $forUpdate ? $this->db->findOne($query, $params, fn ($row) => $row) : $this->db->findOne($query, $params, fn ($row) => $row)) {
            $value['allowed_redirects'] = [];
            $childsAllowedRedirects = $forUpdate ? $this->db->queryForUpdate('select "uid", "client", "url", "version" from "access_trusted_client_allowed_redirect" where "client" = :parent', [
              new SqlParam(name: 'parent', value: $value['uid'], type: SqlParam::STR)
            ]) : $this->db->query('select "uid", "client", "url", "version" from "access_trusted_client_allowed_redirect" where "client" = :parent', [
              new SqlParam(name: 'parent', value: $value['uid'], type: SqlParam::STR)
            ]);
            foreach ($childsAllowedRedirects as $childAllowedRedirects) {
                $value['allowed_redirects'][] = new TrustedClientAllowedRedirectsItem(
                    uid: TrustedClientAllowedRedirectsUidVO::from($childAllowedRedirects['uid']),
                    url: TrustedClientAllowedRedirectsUrlVO::from($childAllowedRedirects['url']),
                    version: TrustedClientAllowedRedirectsVersionVO::from($childAllowedRedirects['version']),
                );
            }
            return $this->mapper($value);
        }
        return $value;
    }
}
