<?php

# @autogenerated
declare(strict_types=1);

namespace Civi\Lughauth\Features\Access\TrustedClient\Domain\ValueObject\Holder;

use Civi\Lughauth\Shared\Value\Validation\ConstraintFailList;
use Civi\Lughauth\Features\Access\TrustedClient\Domain\ValueObject\TrustedClientSecretOauthVO;

trait TrustedClientSecretOauthAttributeHolder
{
    protected TrustedClientSecretOauthVO|string|null $secretOauth = null;
    protected bool $secretOauthAssigned = false;

    public function getSecretOauthOrDefault(?TrustedClientSecretOauthVO $secretOauth): ?TrustedClientSecretOauthVO
    {
        return $this->secretOauthAssigned ? ($this->secretOauth !== null ? TrustedClientSecretOauthVO::from($this->secretOauth) : null) : $secretOauth;
    }
    public function secretOauth(TrustedClientSecretOauthVO|string|null $secretOauth): static
    {
        $this->secretOauth = $secretOauth;
        $this->secretOauthAssigned = true;
        return $this;
    }
    public function getSecretOauth(): ?string
    {
        return is_a($this->secretOauth, TrustedClientSecretOauthVO::class) ? $this->secretOauth->value() : $this->secretOauth;
    }
    public function unsetSecretOauth(): static
    {
        $this->secretOauth = null;
        $this->secretOauthAssigned = false;
        return $this;
    }
    protected function withDefaultSecretOauth(): void
    {
    }
    protected function withAssertedSecretOauthRules(self $value, ConstraintFailList $errorsList): void
    {
        if ($value->secretOauthAssigned = $this->secretOauthAssigned) {
            $value->secretOauth = TrustedClientSecretOauthVO::tryFrom($this->secretOauth, $errorsList);
        }
    }
}
