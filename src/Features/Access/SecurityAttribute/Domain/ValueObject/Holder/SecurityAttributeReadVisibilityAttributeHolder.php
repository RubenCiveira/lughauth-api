<?php

# @autogenerated
declare(strict_types=1);

namespace Civi\Lughauth\Features\Access\SecurityAttribute\Domain\ValueObject\Holder;

use Civi\Lughauth\Shared\Value\Validation\ConstraintFailList;
use Civi\Lughauth\Features\Access\SecurityAttribute\Domain\ValueObject\SecurityAttributeReadVisibilityVO;

trait SecurityAttributeReadVisibilityAttributeHolder
{
    protected SecurityAttributeReadVisibilityVO|string|null $readVisibility = null;
    protected bool $readVisibilityAssigned = false;

    public function getReadVisibilityOrDefault(?SecurityAttributeReadVisibilityVO $readVisibility): ?SecurityAttributeReadVisibilityVO
    {
        return $this->readVisibilityAssigned ? ($this->readVisibility !== null ? SecurityAttributeReadVisibilityVO::from($this->readVisibility) : null) : $readVisibility;
    }
    public function readVisibility(SecurityAttributeReadVisibilityVO|string|null $readVisibility): static
    {
        $this->readVisibility = $readVisibility;
        $this->readVisibilityAssigned = true;
        return $this;
    }
    public function getReadVisibility(): ?string
    {
        return is_a($this->readVisibility, SecurityAttributeReadVisibilityVO::class) ? $this->readVisibility->value() : $this->readVisibility;
    }
    public function unsetReadVisibility(): static
    {
        $this->readVisibility = null;
        $this->readVisibilityAssigned = false;
        return $this;
    }
    protected function withDefaultReadVisibility(): void
    {
        if ($this->readVisibility === null) {
            $this->readVisibility = 'EXPLICIT';
        }
    }
    protected function withAssertedReadVisibilityRules(self $value, ConstraintFailList $errorsList): void
    {
        if ($value->readVisibilityAssigned = $this->readVisibilityAssigned) {
            $value->readVisibility = SecurityAttributeReadVisibilityVO::tryFrom($this->readVisibility, $errorsList);
        }
    }
}
