<?php

/* @autogenerated */
declare(strict_types=1);

namespace Civi\Lughauth\Features\Rcab\Resource\Infrastructure\Driven;

use Override;
use Civi\Lughauth\Features\Access\RelyingParty\Domain\Gateway\RelyingPartyReadGateway;
use Civi\Lughauth\Features\Access\RelyingParty\Domain\RelyingParty;
use Civi\Lughauth\Features\Access\Role\Domain\Gateway\RoleReadGateway;
use Civi\Lughauth\Features\Access\SecurityAttribute\Domain\Gateway\SecurityAttributeFilter;
use Civi\Lughauth\Features\Access\SecurityAttribute\Domain\Gateway\SecurityAttributeReadGateway;
use Civi\Lughauth\Features\Access\SecurityAttribute\Domain\Gateway\SecurityAttributeWriteGateway;
use Civi\Lughauth\Features\Access\SecurityAttribute\Domain\SecurityAttribute;
use Civi\Lughauth\Features\Access\SecurityAttribute\Domain\SecurityAttributeAttributes;
use Civi\Lughauth\Features\Access\SecurityDomain\Domain\Gateway\SecurityDomainReadGateway;
use Civi\Lughauth\Features\Access\SecurityDomain\Domain\SecurityDomain;
use Civi\Lughauth\Features\Access\SecurityScope\Domain\Gateway\SecurityScopeFilter;
use Civi\Lughauth\Features\Access\SecurityScope\Domain\Gateway\SecurityScopeReadGateway;
use Civi\Lughauth\Features\Access\SecurityScope\Domain\Gateway\SecurityScopeWriteGateway;
use Civi\Lughauth\Features\Access\SecurityScope\Domain\SecurityScope;
use Civi\Lughauth\Features\Access\SecurityScope\Domain\SecurityScopeAttributes;
use Civi\Lughauth\Features\Rcab\Resource\Domain\Gateway\RbacStoreRepository;
use Civi\Lughauth\Features\Rcab\Resource\Domain\RoleGrant;
use Civi\Lughauth\Features\Rcab\Resource\Domain\ScopeKind;
use Civi\Lughauth\Shared\Exception\NotFoundException;
use Civi\Lughauth\Shared\Value\Random;

class RbacStoreAdapter implements RbacStoreRepository
{
    public function __construct(
        private readonly RelyingPartyReadGateway $parties,
        private readonly RoleReadGateway $roles,
        private readonly SecurityScopeReadGateway $scopes,
        private readonly SecurityScopeWriteGateway $writeScopes,
        private readonly SecurityAttributeReadGateway $atributes,
        private readonly SecurityAttributeWriteGateway $writeAtributes,
        private readonly SecurityDomainReadGateway $domains
    ) {
    }
    /**
     * @param string $relyingParty
     * @param list<ScopeList> $paramMap
     */
    #[Override]
    public function registerScopes(string $relyingParty, array $paramMap): void
    {
        $party = $this->parties->findOneByCode($relyingParty);
        if ($party === null) {
            return;
        }
        foreach ($paramMap as $scopeList) {
            $resource = $scopeList->resource;
            $scopes = $this->writeScopes->listForUpdate(
                new SecurityScopeFilter(
                    resource: $resource->name,
                    relyingParty: $party
                )
            );
            $existing = [...$scopes];


            foreach ($scopeList->scopes as $scope) {
                $match = $this->findMatchingScope($existing, $scope->name);

                if ($match === null) {
                    $att = new SecurityScopeAttributes();
                    $att->uid(Random::comb());
                    $att->relyingParty($party);
                    $att->resource($resource->name);
                    $att->enabled(true);
                    $att->scope($scope->name);
                    $att->kind($this->convertKind($scope->kind));
                    $att->visibility('EXPLICIT');
                    $this->writeScopes->create(
                        SecurityScope::create($att)
                    );
                } else {
                    // ya existe, se elimina de la lista para no volver a tocarlo
                    $existing = array_filter(
                        $existing,
                        fn (SecurityScope $s) => $s->getScope() !== $scope->name
                    );
                }
            }

            foreach ($existing as $remaining) {
                $this->writeScopes->update($remaining, $remaining->enable());
            }
        }
    }

    /**
     * @param string $relyingParty
     * @param list<Property> $paramMap
     */
    #[Override]
    public function registerSchema(string $relyingParty, array $paramMap): void
    {
        $party = $this->parties->findOneByCode($relyingParty);
        if ($party === null) {
            return;
        }
        foreach ($paramMap as $scopeList) {
            $resource = $scopeList->resource;
            $scopes = $this->writeAtributes->listForUpdate(
                new SecurityAttributeFilter(
                    resource: $resource->name,
                    relyingParty: $party
                )
            );
            $existing = [...$scopes];

            foreach ($scopeList->scopes as $scope) {
                $match = $this->findMatchingScope($existing, $scope->name);

                if ($match === null) {
                    $att = new SecurityAttributeAttributes();
                    $att->uid(Random::comb());
                    $att->relyingParty($party);
                    $att->resource($resource->name);
                    $att->enabled(true);
                    $att->attribute($scope->name);
                    $att->readVisibility('EXPLICIT');
                    $att->writeVisibility('EXPLICIT');
                    $this->writeAtributes->create(
                        SecurityAttribute::create($att)
                    );
                } else {
                    // ya existe, se elimina de la lista para no volver a tocarlo
                    $existing = array_filter(
                        $existing,
                        fn (SecurityScope $s) => $s->getScope() !== $scope->name
                    );
                }
            }

            foreach ($existing as $remaining) {
                $this->writeAtributes->update($remaining, $remaining->enable());
            }
        }
    }

    /**
     * @param string $relyingParty
     * @return list<RoleGrant>
     */
    #[Override]
    public function granted(string $relyingParty): array
    {
        $party = $this->parties->findOneByCode($relyingParty);
        if (!$party) {
            throw new NotFoundException('.');
        }
        return $party ? $this->grantedForRely($party) : [];
    }

    /**
     * @return RoleGrant[]
     */
    private function grantedForRely(RelyingParty $party): array
    {
        $secScopes = $this->scopes->list(new SecurityScopeFilter(relyingParty: $party));
        $secAttrs = $this->atributes->list(new SecurityAttributeFilter(relyingParty: $party));
        if (empty($secScopes) && empty($secScopes)) {
            return [];
        }

        $secDomains = $this->domains->list();
        $secRoles = $this->roles->list();

        $roleSecs = []; // string => list<string>
        foreach ($secRoles as $role) {
            foreach ($role->getDomains() as $roleDomain) {
                $this->appendArray($role->getName(), $roleDomain->getSecurityDomain()->uid(), 'scope', $roleSecs);
            }
        }

        $byRole = []; // roleName => list<resource:scope>
        $bySec = [];  // domainUid => list<resource:scope>

        foreach ($secScopes as $securityScope) {
            if ($this->checkPublic($securityScope)) {
                $this->appendType('-', $securityScope, 'scope', $byRole);
            }

            foreach ($secDomains as $securityDomain) {
                $kind = $securityScope->getKind();
                if ($kind !== null) {
                    $allowed =
                        $this->checkReadAll($kind, $securityDomain, $securityScope) ||
                        $this->checkWriteAll($kind, $securityDomain, $securityScope) ||
                        $this->checkManageAll($kind, $securityDomain, $securityScope) ||
                        $this->checkPublic($securityScope) ||
                        $this->checkAuthorized($securityScope);

                    if ($allowed) {
                        $this->appendType($securityDomain->uid(), $securityScope, 'scope', $bySec);
                    } else {
                        // Check explicit asignation.
                    }
                }
            }
        }

        foreach ($secAttrs as $securityAttributes) {
            $readVisibility = $securityAttributes->getReadVisibility() ?? 'EXPLICIT';
            $writeVisibility = $securityAttributes->getWriteVisibility() ?? 'EXPLICIT';
            if ($readVisibility === 'PUBLIC') {
                $this->appendType('-', $securityScope, 'view', $byRole);
            }
            if ($writeVisibility === 'PUBLIC') {
                $this->appendType('-', $securityScope, 'modify', $byRole);
            }
            foreach ($secDomains as $securityDomain) {
                $view = true;
                $modify = true;
                $view = $view && $securityDomain->getViewAllAttributes();
                $modify = $view && $securityDomain->getModifyAllAttributes();
                if (!$view) {
                    // Chekxk explicit asignation
                }
                if (!$modify) {
                    // Chekxk explicit asignation
                }
            }
            // $this->appendType($securityDomain->uid(), $securityScope, 'scope', $bySec);

        }

        foreach ($bySec as $domainId => $domainScopes) {
            foreach ($roleSecs as $roleName => $roleDomains) {
                if (in_array($domainId, $roleDomains['scope'], true)) {
                    foreach ($domainScopes['scope'] as $domainScope) {
                        $this->appendArray($roleName, $domainScope, 'scope', $byRole);
                    }
                }
                if (in_array($domainId, $roleDomains['view'], true)) {
                    foreach ($domainScopes['view'] as $domainScope) {
                        $this->appendArray($roleName, $domainScope, 'view', $byRole);
                    }
                }
                if (in_array($domainId, $roleDomains['modify'], true)) {
                    foreach ($domainScopes['modify'] as $domainScope) {
                        $this->appendArray($roleName, $domainScope, 'modify', $byRole);
                    }
                }
            }
        }

        $grants = [];
        foreach ($byRole as $roleName => $scopes) {
            $grants[] = new RoleGrant(
                rolename: $roleName,
                allowedScopes: array_values(array_unique($scopes['scope'])),
                hiddenFields: array_values(array_unique($scopes['modify'])),
                fixedFields: array_values(array_unique($scopes['view']))
            );
        }

        return $grants;
    }

    private function checkPublic(SecurityScope $securityScope): bool
    {
        return ($securityScope->getVisibility() ?? 'EXPLICIT') === 'PUBLIC';
    }

    private function checkAuthorized(SecurityScope $securityScope): bool
    {
        return ($securityScope->getVisibility() ?? 'EXPLICIT') === 'AUTHORIZED';
    }

    private function checkReadAll(string $kind, SecurityDomain $domain, SecurityScope $scope): bool
    {
        return $kind === 'READ' && $domain->getReadAll();
    }

    private function checkWriteAll(string $kind, SecurityDomain $domain, SecurityScope $scope): bool
    {
        return $kind === 'WRITE' && $domain->getWriteAll();
    }

    private function checkManageAll(string $kind, SecurityDomain $domain, SecurityScope $scope): bool
    {
        return $kind === 'MANAGE' && $domain->getManageAll();
    }

    /**
     * @param array<string, list<string>> $map
     */
    private function appendType(string $key, SecurityScope $scope, string $on, array &$map): void
    {
        $this->appendArray($key, $scope->getResource() . ':' . $scope->getScope(), $on, $map);
    }

    /**
     * @param array<string, list<string>> $map
     */
    private function appendArray(string $key, string $value, string $on, array &$map): void
    {
        if (!array_key_exists($key, $map)) {
            $map[$key] = [];
        }
        if (!isset($map[$key][$on])) {
            $map[$key][$on] = [];
        }
        $map[$key][$on][] = $value;
    }

    private function findMatchingScope(array $scopes, string $name): ?SecurityScope
    {
        foreach ($scopes as $scope) {
            if ($scope->getScope() === $name) {
                return $scope;
            }
        }
        return null;
    }

    private function convertKind(ScopeKind $kind): string
    {
        return match ($kind) {
            ScopeKind::READ => 'READ',
            ScopeKind::WRITE => 'WRITE',
            ScopeKind::MANAGE => 'MANAGE',
        };
    }
}
